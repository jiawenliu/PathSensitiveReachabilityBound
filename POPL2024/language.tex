We consider a standard while-like language equipped with a trace-based operational semantics.\\

\noindent\emph{Labeled Commands.}
The set of programs $\cdom$ we consider is generated by the following \emph{syntax with labels}: 
\begin{center}
\highlight{$
\begin{array}{ll}
{c} ::= &
\clabel{\assign{x}{\expr}}^l 
~|~ \clabel{\eskip}^l
~|~ \ewhile \clabel{\bexpr}^{l} \edo ({c})
~|~ \eif(\clabel{\bexpr}^{l} , {c}, {c}) 
~|~ {c};{c} \\
\aexpr ::= &
n \in \mathbb{Z} ~|~ x \in \vardom ~|~ n \times \aexpr~|~ \aexpr \% n ~|~ \aexpr + \aexpr ~|~ \aexpr - \aexpr\\
% ~|~ \emax (a, a) ~|~ \emin(a, a)\\
\bexpr ::= & 
%
\etrue ~|~ \efalse  ~|~ \neg \bexpr
 ~|~ \bexpr \land \bexpr
%
~|~ \bexpr \lor \bexpr 
~|~ \aexpr \leq \aexpr 
~|~ \aexpr < \aexpr 
~|~ \aexpr = \aexpr 
\end{array}
$}
\end{center}
\mg{Please spell out what the arithmetic operations are and why some of them are formed by values instead of arithmetic expressions.}
where $l$ is a label in $\mathbb{N}$, $x$ is a variable from
some set $\vardom$, $\bexpr$ is a boolean expression from some set
$\booldom$, and $e$ is an expression consisting of either an
arithmetic expression $\aexpr \in \mathcal{A}$ or a boolean
expression.
\highlight{An arithmetic expression $\aexpr$ is an expression over variables $x_1, x_2, \ldots \in \vardom$
and integers $n_0, n_1, n_2, \ldots \in \mathbb{Z}$ that is composed using arithmetic operators,
multiplication($\times $), mod($\%$), addition($+$), subtraction($-$) in the form of linear polynomial such as $v_0 + n_1 x_1 + n_2 x_2 + \ldots$ or $n_0 + x_1 \% n_1 + n_2 x_2 \ldots$ where operators $\times$ and $\%$ can only compose an arithmetic expression with an integer.
}%
A value $v\in \valdom$ is either an integer in $\mathbb{Z}$ or a boolean in $\mathbb{B}$.
We 
assume that the labeling of programs is such that each program
point is uniquely annotated with a label $l\in\mathbb{N}$.
\highlight{$\inpvar(c)$ is the set of input variables in a program $c$, which is all the free variables
in program expressions that are used before it is defined.
}
\mg{I don't think this is accurate. Accordingly to this definition, the following program has no input variables: y=x+2; x=x+1. I imagine that x here should be an input variable. Am I wrong?}
%
%% Expressions include integer arithmetic expression,
%% $\aexpr \in \mathcal{A}$ (with the value
%% $n \in \mathbb{N} \cup \{ \infty\}$ and the variable $x$ from a finite
%% universe $\vardom$) and boolean expression, $\bexpr \in \booldom$,
%% where we denote by $\infty$ a value s.t. $n < \infty $ for all
%% $n \in \mathbb{N}$.
%% % The operator $\kw{FV}: \expr \to \mathcal{P}(\mathcal{V})$ computes the set of free variables in an expression.
%% We denote by $\cdom$ the universe of all labeled commands, $\ldom$ for
%% all labels, $\inpvar(c) \subseteq \vardom$ the set of all input
%% variables in a program $c$, and $\infty$ a value s.t. $n < \infty $
%% for all $n \in \mathbb{N}$.\\
%% % We use $\infty$ a value s.t. $n < \infty $ for all $n \in \mathbb{N}$.

\noindent\emph{Set of labels.} While we assume that programs points are annotated only with natural numbers as labels, in the following we will use a more general set of labels: $\ldom = \mathbb{N}\cup\{\lin,\lex\}$. The label $\lin$ will be used to denote input variables in traces, while $\lex$ will be used in our program analysis to identify program exit points.
We denote by  $\lvar(c) \subseteq \ldom$ the set of all the unique labels of $c$.





\noindent\emph{Events and Traces.} 
An event, $\event \in \eventset$ is either an \emph{assignment event}, which is  a triple of the shape $({x}, l,v)$, or a \emph{testing event}, which is a triple of the shape $(\bexpr, l, v)$. An assignment event tracks the execution of an assignment, while a testing event tracks the evaluation
of a boolean guard $b$ in an if or a while command.
% if and while commands, specifically the evaluation of the boolean expression $b$ in 
%the guard for a $\eif(\clabel{b}^l, c_1, c_2)$ command or
%$\ewhile \clabel{b}^l \edo (c)$ respectively.
%% Its first element is the variable name $x$
%% or the boolean expression $b$, 
%% following by 
%% the label, $l$ of this command, and the evaluated value.
We will use projection notation $\pi_i$ to select the $i^{th}$ element
from an event.
%% To select the $i^{th}$ element of an event we will use
%% : $\pi_i : \eventset \to \vardom \cup \booldom \cup \ldom $.


A trace $\trace$ is a potentially infinite list of events, 
collecting the events generated  during program execution. 
We use list notation for traces, where $[]$ is the empty trace, and
the operator $\tracecat$ concatenates two traces. We use set notation $\event \in \trace$ or $\event \notin \trace$ to denote whether an event $\event$ belongs or not to $\trace$.
We denote the set of finite traces by $\ftdom$, the set of infinite traces by $\inftdom$ and the set of traces by $\tdom = \ftdom \cup \inftdom$.
We use the notation $\trace[j]$ for the $j^{th}$ event in the trace $\trace$ counting from the head of the list, with $\trace[1]$ denoting the first event.
We use an operator $\tracel: \tdom \to \mathcal{P}{(\ldom)}$ which projects the labels of every event in a trace as a list of program points. This is defined as follows,
% \mg{the previous definition was not well defined since it was missing the otherwise. In particular, both cases were applying to an infinite trace.}
\[
\begin{array}{rcll}
\tracel(\trace) &\triangleq & [] &\qquad  \mbox{if}~~ \trace = [] \lor \trace \in \inftdom
\\ 
\tracel([(\_, l, \_)] \tracecat \trace') &\triangleq & [l] \tracecat \tracel(\trace') &\qquad  \mbox{otherwise}
\end{array}
\]
%
% We denote by $\bot$ a value s.t. $\bot < v $ for all $v \in \mathbb{Z}$
\mg{Why do we need $\bot$ to be smaller than all the integers?}
\jl{Because in Definition~\ref{def:counter}, the counter was returning $\bot$ when the trace is an infinite trace, requiring the $\bot$ to be smaller than all integers can guarantee the soundness in the case of non-terminating execution.}, 
We use the operator $\env: {\tdom} \to \vardom \to \mathbb{Z}$ 
\mg{In which case do we get $\infty$?}
\jl{When the estimated reachability-bound is $\infty$} to fetch the latest value assigned to a variable in the trace,
 which returns $\bot$ if the variable doesn't show up in the trace, or the trace is an infinite trace.
 \highlight{
    \[
\begin{array}{lll}
\env(\trace \traceadd (y, l, v)) x \triangleq \env(\trace) x ~ \text{if}~ y \neq x
&
\env(\trace ) x \triangleq \bot ~ \text{if}~ \trace \in \inftdom
\\
\env(\trace  \traceadd (x, l, v)) x \triangleq v
&
\env({[]} ) x \triangleq \bot
&
\env(\trace \traceadd (b, l, v)) x \triangleq \env(\trace) x
\end{array}
\]
 }
% In the rest of the paper, We denote by $\bot$ a value s.t. $\bot < n $ for all $n \in \mathbb{N}$.
%% We use $\ftdom_0(c)$ to denote the set of all initial traces for the program $c$, and each input variable $x \in \inpvar(c)$ has an initial value in an initial trace $\trace_0 \in \ftdom_0(c)$\mg{Is this the definition of initial trace?  a trace where every input variable has a value?}.\\
    \begin{defn}[Initial Trace]
        \label{def:initial_trace}
        Given a program $c$, a finite trace $\trace$ is an initial trace of $c$ if and only if all the input variables of $c$ have an initial value in this trace.\mg{This is inconsistent, since $\bot$ \bf{is a value}.}
        \[
        \forall c \in \cdom, \trace \in \ftdom \st \trace \in \ftdom_0(c) \iff 
        \forall x \in \inpvar(c) \st \env(\trace_0) x \neq \bot
        \]
        We use $\ftdom_0(c)$ to denote the set of all initial traces for program $c$.
        \end{defn}
        As an example, the initial trace of $\kw{nestedOdd}(n, m)$ example contains the initial value of the input variable $n$ and $m$.
\\


\emph{Semantics}
We evaluate the expression using the usual arithmetic operator semantics, denoted by
$\econfig{} : \mathcal{A} \cup \booldom \to \tdom \to \mathcal{V}$ where
$\econfig{\expr}(\trace)$ evaluates $\expr$ under trace $\trace$.
% Our symbolic bound expression is a subset of the arithmetic expressions, and we use the same evaluation notation for evaluating the bound expression.
The trace-based operational semantics is described in terms of a small step evaluation relation $\config{c, \trace} \to \config{c', \trace'}$ describing how a configuration program-trace evaluates to another
one.
The rules are standard and omitted here.
We use $\to^*$ for the reflexive and transitive closure of $\to$. 
If $\config{c, \trace_0} \rightarrow^{*} \config{\clabel{\eskip}^l, \trace_0 \tracecat \trace}$ under an initial trace 
$\trace_0 \in \ftdom_0(c)$,
then the program's execution terminates and produces a finite execution trace $\trace \in \ftdom$. We also have non-terminating execution denoted by $\config{c, \trace_0} \uparrow^{\infty} \trace$ that produces an infinite trace $\trace \in \inftdom$. The complete rules and definition can be found in the supplementary materials.
