We consider a standard while-like language equipped with a trace-based operational semantics.\\
%We use labels to identify different program locations.

\noindent\emph{Labeled Commands.}
The set of programs $\cdom$ we consider is generated by the following \emph{syntax with labels}: 
\\
\[
{c} ::= 
\clabel{\assign{x}{\expr}}^l 
~|~ \clabel{\eskip}^l
~|~ \ewhile \clabel{\bexpr}^{l} \edo ({c})
~|~ \eif(\clabel{\bexpr}^{l} , {c}, {c}) 
~|~ {c};{c} 
\]
\\
where $l$ is a label in $\mathbb{N}$, $x$ is a variable from
some set $\vardom$, $\bexpr$ is a boolean expression from some set
$\booldom$, and $e$ is an expression consisting of either an
arithmetic expression $\aexpr \in \mathcal{A}$ or a boolean
expression~\mg{If we have space I suggest we spell out the syntax for expressions or at least we need to do this in the appendix.}.
%
\mg{The next sentence may need to be moved to the semantics part. Also, is $\bot$ a value?}
A value $v\in\valdom$ is either an integer in $\mathbb{Z}$ or a boolean in $\mathbb{B}$.
We 
assume that the labeling of programs is such that each program
point is uniquely annotated with a label $l\in\mathbb{N}$.
\mg{I do not know how the set $\inpvar(c)$ of input variable of a program $c$ is defined. Can we spell it out?}\\


%
%% Expressions include integer arithmetic expression,
%% $\aexpr \in \mathcal{A}$ (with the value
%% $n \in \mathbb{N} \cup \{ \infty\}$ and the variable $x$ from a finite
%% universe $\vardom$) and boolean expression, $\bexpr \in \booldom$,
%% where we denote by $\infty$ a value s.t. $n < \infty $ for all
%% $n \in \mathbb{N}$.
%% % The operator $\kw{FV}: \expr \to \mathcal{P}(\mathcal{V})$ computes the set of free variables in an expression.
%% We denote by $\cdom$ the universe of all labeled commands, $\ldom$ for
%% all labels, $\inpvar(c) \subseteq \vardom$ the set of all input
%% variables in a program $c$, and $\infty$ a value s.t. $n < \infty $
%% for all $n \in \mathbb{N}$.\\
%% % We use $\infty$ a value s.t. $n < \infty $ for all $n \in \mathbb{N}$.

\noindent\emph{Set of labels.} While we assume that programs points are annotated only with natural numbers as labels, in the following we will use a more general set of labels: $\ldom = \mathbb{N}\cup\{\lin,\lex\}$. The label $\lin$ will be used to denote input variables in traces, while $\lex$ will be used in our program analysis to identify program exit points.\\



\noindent\emph{Events and Traces.} 
An event, $\event \in \eventset$ is either an \emph{assignment event}, which is  a triple of the shape $({x}, l,v)$, or a \emph{testing event}, which is a triple of the shape $(\bexpr, l, v)$. An assignment events tracks the execution of an assignment, while a testing event tracks the evaluation
of a boolean guard $b$ in an if or a while command.
% if and while commands, specifically the evaluation of the boolean expression $b$ in 
%the guard for a $\eif(\clabel{b}^l, c_1, c_2)$ command or
%$\ewhile \clabel{b}^l \edo (c)$ respectively.
%% Its first element is the variable name $x$
%% or the boolean expression $b$, 
%% following by 
%% the label, $l$ of this command, and the evaluated value.
We will use projection notation $\pi_i$ to select the $i^{th}$ element
from an event.
%% To select the $i^{th}$ element of an event we will use
%% : $\pi_i : \eventset \to \vardom \cup \booldom \cup \ldom $.


A trace $\trace$ is a potentially infinite list of events, 
collecting the events generated  during program execution. 
We use list notation for traces, where $[]$ is the empty trace, and
% the operator $\traceadd$ combines an event and a trace in a new event, 
the operator $\tracecat$ concatenates two traces. We use set notation $\event \in \trace$ or $\event \notin \trace$ to denote whether an event $\event$ belongs or not to $\trace$.
{
We denote the set of finite traces by $\ftdom$, the set of infinite traces by $\inftdom$ and the set of traces by $\tdom = \ftdom \cup \inftdom$.
% The trace-based semantics with non-terminating execution is defined below following the maximal trace semantics in~\cite{Cousot19}.
}

%
We denote by $\bot$ a value s.t. $\bot < n $ for all $n \in \mathbb{N}$\mg{Why do we need $\bot$ to be smaller than all the integers?}, and we use the operator $\env: {\ftdom} \to \vardom \to(\mathbb{N} \cup \{\bot, \infty\})$ \mg{In which case do we get $\infty$?} to fetch the latest value assigned to a variable in the trace, which returns $\bot$ if the variable doesn't have a value in the trace.
% In the rest of the paper, We denote by $\bot$ a value s.t. $\bot < n $ for all $n \in \mathbb{N}$.
We use $\ftdom_0(c)$ to denote the set of all initial traces for the program $c$, and each input variable $x \in \inpvar(c)$ has an initial value in an initial trace $\trace_0 \in \ftdom_0(c)$\mg{Is this the definition of initial trace?  a trace where every input variable has a value?}.\\


\emph{Semantics}
We evaluate the expression by algorithmic computation in math, denoted by
$\econfig{} : \mathcal{A} \cup \booldom \to \tdom \to \mathcal{V}$ where
% for the expression evaluation, and 
$\econfig{\expr}(\trace)$ evaluates $\expr$ under trace $\trace$.
Our symbolic bound expression is a subset of the arithmetic expressions, and we use the same evaluation notation for evaluating the bound expression.
The trace-based operational semantics is described in terms of a small step evaluation relation $\config{c, \trace} \to \config{c', \trace'}$ describing how a configuration program-trace evaluates to another
one.
The rules are standard and omitted here.
We use $\to^*$ for the reflexive and transitive closure of $\to$. 
If $\config{c, \trace_0} \rightarrow^{*} \config{\clabel{\eskip}^l, \trace_0 \tracecat \trace}$ under an initial trace 
$\trace_0 \in \ftdom_0(c)$,
then the program's execution terminates and produces a finite execution trace $\trace \in \ftdom$. We also have non-terminating execution denoted by $\config{c, \trace_0} \uparrow^{\infty} \trace$ that produces an infinite trace $\trace \in \inftdom$. The complete rules and definition can be found in the supplementary materials.
