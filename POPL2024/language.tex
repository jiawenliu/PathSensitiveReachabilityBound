We consider a standard while-like language equipped with a trace-based operational semantics.\\

\noindent\emph{Labeled Commands.}
The set of programs $\cdom$ we consider is generated by the following \emph{syntax with labels}: 
\begin{center}
\highlight{$
\begin{array}{ll}
{c} ::= &
\clabel{\assign{x}{\expr}}^l 
~|~ \clabel{\eskip}^l
~|~ \ewhile \clabel{\bexpr}^{l} \edo ({c})
~|~ \eif(\clabel{\bexpr}^{l} , {c}, {c}) 
~|~ {c};{c} \\
\aexpr ::= &
v \in \mathbb{Z} ~|~ x \in \vardom ~|~ v \times \aexpr~|~ \aexpr \% v ~|~ \aexpr + \aexpr ~|~ \aexpr - \aexpr\\
% ~|~ \emax (a, a) ~|~ \emin(a, a)\\
\bexpr ::= & 
%
\etrue ~|~ \efalse  ~|~ \neg \bexpr
 ~|~ \bexpr \land \bexpr
%
~|~ \bexpr \lor \bexpr 
~|~ \aexpr \leq \aexpr 
~|~ \aexpr < \aexpr 
~|~ \aexpr = \aexpr 
\end{array}
$}
\end{center}
where $l$ is a label in $\mathbb{N}$, $x$ is a variable from
some set $\vardom$, $\bexpr$ is a boolean expression from some set
$\booldom$, and $e$ is an expression consisting of either an
arithmetic expression $\aexpr \in \mathcal{A}$ or a boolean
expression~\mg{If we have space I suggest we spell out the syntax for expressions or at least we need to do this in the appendix.}.
%
\mg{The next sentence may need to be moved to the semantics part. Also, is $\bot$ a value?}
A value $v\in \valdom$ is either an integer in $\mathbb{Z}$ or a boolean in $\mathbb{B}$.
We 
assume that the labeling of programs is such that each program
point is uniquely annotated with a label $l\in\mathbb{N}$.
\mg{I do not know how the set $\inpvar(c)$ of input variable of a program $c$ is defined. Can we spell it out?}\\
\highlight{$\inpvar(c)$ is the set of input variables in a program $c$. 
It is computed by taking the union of the free variables in every expression in $c$
and then subtracting the set of variables that are assigned in commands.
}
%
%% Expressions include integer arithmetic expression,
%% $\aexpr \in \mathcal{A}$ (with the value
%% $n \in \mathbb{N} \cup \{ \infty\}$ and the variable $x$ from a finite
%% universe $\vardom$) and boolean expression, $\bexpr \in \booldom$,
%% where we denote by $\infty$ a value s.t. $n < \infty $ for all
%% $n \in \mathbb{N}$.
%% % The operator $\kw{FV}: \expr \to \mathcal{P}(\mathcal{V})$ computes the set of free variables in an expression.
%% We denote by $\cdom$ the universe of all labeled commands, $\ldom$ for
%% all labels, $\inpvar(c) \subseteq \vardom$ the set of all input
%% variables in a program $c$, and $\infty$ a value s.t. $n < \infty $
%% for all $n \in \mathbb{N}$.\\
%% % We use $\infty$ a value s.t. $n < \infty $ for all $n \in \mathbb{N}$.

\noindent\emph{Set of labels.} While we assume that programs points are annotated only with natural numbers as labels, in the following we will use a more general set of labels: $\ldom = \mathbb{N}\cup\{\lin,\lex\}$. The label $\lin$ will be used to denote input variables in traces, while $\lex$ will be used in our program analysis to identify program exit points.
\highlight{We use a set $\lvar(c) \subseteq \ldom$ collecting all the program points in a program $c$, which are simply all the unique labels of $c$.
}



\noindent\emph{Events and Traces.} 
An event, $\event \in \eventset$ is either an \emph{assignment event}, which is  a triple of the shape $({x}, l,v)$, or a \emph{testing event}, which is a triple of the shape $(\bexpr, l, v)$. An assignment event tracks the execution of an assignment, while a testing event tracks the evaluation
of a boolean guard $b$ in an if or a while command.
% if and while commands, specifically the evaluation of the boolean expression $b$ in 
%the guard for a $\eif(\clabel{b}^l, c_1, c_2)$ command or
%$\ewhile \clabel{b}^l \edo (c)$ respectively.
%% Its first element is the variable name $x$
%% or the boolean expression $b$, 
%% following by 
%% the label, $l$ of this command, and the evaluated value.
We will use projection notation $\pi_i$ to select the $i^{th}$ element
from an event.
%% To select the $i^{th}$ element of an event we will use
%% : $\pi_i : \eventset \to \vardom \cup \booldom \cup \ldom $.


A trace $\trace$ is a potentially infinite list of events, 
collecting the events generated  during program execution. 
We use list notation for traces, where $[]$ is the empty trace, and
% the operator $\traceadd$ combines an event and a trace in a new event, 
the operator $\tracecat$ concatenates two traces. We use set notation $\event \in \trace$ or $\event \notin \trace$ to denote whether an event $\event$ belongs or not to $\trace$.
{
We denote the set of finite traces by $\ftdom$, the set of infinite traces by $\inftdom$ and the set of traces by $\tdom = \ftdom \cup \inftdom$.
% The trace-based semantics with non-terminating execution is defined below following the maximal trace semantics in~\cite{Cousot19}.
}
\highlight{$\trace[j]$ denotes the $j^{th}$ event in this trace $\trace$ counting from head of the list with $\trace[1]$ for the first event,
and we also define the operator $\tracel: \tdom \to \mathcal{P}{(\ldom)}$ projects the label from every event in a trace as a list of program points as follows,
{\small
\[
\tracel([(\_, l, \_)] \tracecat \trace') \triangleq [l] \tracecat \tracel(\trace')
\qquad
\tracel(\trace) \triangleq []~~ \mbox{if}~~ \trace = [] \lor \trace \in \inftdom
\]
}
}

%
We denote by $\bot$ a value s.t. $\bot < v $ for all $v \in \mathbb{Z}$\mg{Why do we need $\bot$ to be smaller than all the integers?}, and we use the operator $\env: {\ftdom} \to \vardom \to(\mathbb{N} \cup \{\bot\})$ \mg{In which case do we get $\infty$?} to fetch the latest value assigned to a variable in the trace, which returns $\bot$ if the variable doesn't have a value in the trace.
% In the rest of the paper, We denote by $\bot$ a value s.t. $\bot < n $ for all $n \in \mathbb{N}$.
We use $\ftdom_0(c)$ to denote the set of all initial traces for the program $c$, and each input variable $x \in \inpvar(c)$ has an initial value in an initial trace $\trace_0 \in \ftdom_0(c)$\mg{Is this the definition of initial trace?  a trace where every input variable has a value?}.\\
\highlight{
    \begin{defn}[Initial Trace]
        \label{def:initial_trace}
        Given a program $c$, $\trace$ is an initial trace of $c$ if and only if all the input variables of $c$ have an initial value in this trace.
        \[
        \forall c \in \cdom, \trace \in \ftdom \st \trace \in \ftdom_0(c) \iff 
        \forall x \in \inpvar(c) \st \env(\trace_0) x \neq \bot
        \]
        We use $\ftdom_0(c)$ to denote the set of all initial traces for program $c$.
        \end{defn}
        For instance, the initial trace of $\kw{nestedOdd}(n, m)$ example contains the initial value of the input variable $n$ and $m$.
}

\emph{Semantics}
We evaluate the expression using the usual arithmetic operator semantics, denoted by
$\econfig{} : \mathcal{A} \cup \booldom \to \tdom \to \mathcal{V}$ where
$\econfig{\expr}(\trace)$ evaluates $\expr$ under trace $\trace$.
% Our symbolic bound expression is a subset of the arithmetic expressions, and we use the same evaluation notation for evaluating the bound expression.
The trace-based operational semantics is described in terms of a small step evaluation relation $\config{c, \trace} \to \config{c', \trace'}$ describing how a configuration program-trace evaluates to another
one.
The rules are standard and omitted here.
We use $\to^*$ for the reflexive and transitive closure of $\to$. 
If $\config{c, \trace_0} \rightarrow^{*} \config{\clabel{\eskip}^l, \trace_0 \tracecat \trace}$ under an initial trace 
$\trace_0 \in \ftdom_0(c)$,
then the program's execution terminates and produces a finite execution trace $\trace \in \ftdom$. We also have non-terminating execution denoted by $\config{c, \trace_0} \uparrow^{\infty} \trace$ that produces an infinite trace $\trace \in \inftdom$. The complete rules and definition can be found in the supplementary materials.
