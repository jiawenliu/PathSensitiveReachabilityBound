As pre-procedures, this section shows the program abstraction. 
It contains the abstraction transition graph generation
and the program rewriting. 

\subsection{Abstraction Transition Graph}
Our algorithm
is performed on basis of an \emph{Abstract Transition Graph}, $\absG(c)$
% $ =(\absV(c), \absE(c))$ 
for the program $c$.
We first introduce some components of this graph.
\begin{defn}[Symbolic Constant, Symbolic Expression]
 \label{def:symbolic_expr}
A symbolic constant is either a natural number, $\infty$, or a program's input variable. We denote by $\scvardom \subseteq \mathbb{N} \cup \vardom \cup \{\infty \}$ the universe of the \emph{symbolic constant}.
 The set of the \emph{symbolic expression} for a program $c$,
$\scexpr(c) \subseteq \mathcal{A}$ is all the expressions over $\mathbb{N} \cup \inpvar(c) \cup \{\infty \}$ that are
formed using the arithmetical operators addition ($+$), multiplication
($\times $), maximum ($\emax $), minimum ($\emin$).
\end{defn}

\highlight{
\begin{defn}[Symbolic Expression Semantics]
\label{def:symbolic_expr_semantics}
  The semantics function for symbolic expressions, $\sceconfig{}: \scexpr(c) \to (\tdom \to \mathbb{N} \cup \{\infty \})$ evaluates a \emph{symbolic expression}
  $e \in \scexpr(c)$ over a trace $\trace \in \tdom$ using the usual operator semantics (we have 
  $e + \infty = \infty, \emin(e, \infty) = e$, etc.).
\end{defn}
}
\begin{defn}[Difference Constraints]
A difference constraint $d$ is an inequality of
form $x' \leq y + v$ or $x' \leq v$ where $x, y \in \vardom $ and $v \in \scvardom$.
$x' \leq y + v$ (rsp. $x' \leq v$) describes that the value of $x$ in the current state is
at most the value of $y$ in the previous state plus the symbolic constant $v$ (rsp. the value of $v$).
$DC(\vardom \cup \scvardom)$ denotes the universe of all difference constraints over $\vardom \cup \scvardom$.
\end{defn}

\begin{defn}[Constraints]
A constraint $dc \in \dcdom^{\top}$
is either a
difference constraint $d \in DC(\vardom \cup \scvardom)$, a boolean expression $\bexpr \in \booldom$
or $\top$ denotes always true.
\end{defn}

When the constraint in a transition is a difference constrain, $l \xrightarrow{x' \leq y + v} l'$,
% Then $x'$ 
it denotes that
the value of variable $x$
after executing the command at $l$ is at most
% and the right-hand side describes 
the value of variable $y$ plus $v$ before the execution,
and $l \xrightarrow{x' \leq v} l'$ respectively denotes
% value of variable $x$
% after executing the command at $l$ is 
$x$ has at most
% and the right-hand side describes 
the value of the symbolic constant $v$.
% before the execution.
For example in Figure~\ref{fig:relatedNestedWhileOdd-overview}(b), constraint $i' \leq i - 1$ on the edge $7 \xrightarrow{i' \leq i - 1} 1$
describes the execution of
 the command at line $7$, 
$\clabel{\assign{i}{i - 1}}^{7}$. 

% For every expression in each of the label commands, it is computed in three steps via the program abstraction method adopted from Section~6 in~\cite{SinnZV17}. 

The boolean constraint, $\bexpr$ on an edge $l \xrightarrow{b} l'$ describes
that after evaluating the guard with label $l$,
$\bexpr$ holds and the command with label $l$ will execute right after.
In Figure~\ref{fig:relatedNestedWhileOdd-overview}, $i \leq 0 $ on the edge $1 \xrightarrow{i \leq 0} \lex$, 
represents the negation of the testing guard $\clabel{i > 0}^1$
in the $\ewhile$ command, and $i \leq 0$ must hold in order to perform this transition from program point $1$ to
the program exit. 
We also have $\top$, which is preserved for $\eskip$ command or the commands that don't interfere with any guard variable.


% For example in Figure~\ref{fig:relatedNestedWhileOdd-overview}(b), the constraint $i' \leq i - 1$ on the edge $7 \xrightarrow{i' \leq i - 1} 1$
% describes after the execution of
%  the command
% $\clabel{\assign{i}{i - 1}}^{7}$, the value of $i$ is at most the previous $i$'s value minus $1$.
% %
% % For every expression in each of the label commands, it is computed in three steps via the program abstraction method adopted from Section~6 in~\cite{SinnZV17}. 
% %
% The boolean constraint
% % $\bexpr$ on an edge $l \xrightarrow{b} l'$ describes
% % that after evaluating the guard with label $l$,
% % $\bexpr$ holds to execute the command with label $l'$.
% % For example 
% $i \leq 0 $ on the edge $1 \xrightarrow{i \leq 0} \lex$ 
% represents the negation of the testing guard $\clabel{i > 0}^1$
% in the $\ewhile$ command, and $i \leq 0$ must hold to perform the transition from location $1$ to
% the exit $\lex$. 
% $\top$ is preserved for the $\eskip$ command or the commands that don't interfere with any couter.

\begin{defn}[Abstract Transition Graph]
 \label{def:abs_cfg}
 The \emph{abstract transition graph} of a program $c$ is $\absG(c) \triangleq (\absV(c), \absE(c))$, where
 $\absV(c) \triangleq \lvar(c)\cup\{\lex\}$
 and 
 % $\absE(c) \triangleq \{(l_1, dc, l_2) | (l_1, dc, l_2) \in \absflow(c)\}$,
 % and
 % .
 each edge $(l, dc, l') \in \absE(c)$ is an abstract transition
between two program points $l, l'$ if and only if
the command with label $l'$ can execute right after the execution of the command with label $l$.
% if and only if there is a control flow between two program points.
The constraint $dc \in \dcdom$ on each edge
describes the abstract execution of the command with label $l$.
\end{defn}
The edge $(0 \xrightarrow{i' \leq n} 1)$ on the top of Figure~\ref{fig:relatedNestedWhileOdd-overview}(b) tells us the command 
$\clabel{\assign{i}{n}}^0$ is executed with a continuation point $1$, and the while loop with header at location $1$, $\ewhile \clabel{i > 0}^1 \edo \{\ldots\}$ will be executed right after.

\begin{defn}[Path]
 \label{def:abs_cfgpath} 
 A path on $\absG(c)$ is a sequence, $ l_0 \xrightarrow{dc_0} l_1 \xrightarrow{dc_1} \ldots $ with
 \begin{itemize}
 \item the vertices $(l_0, \ldots)$, where $l_i \in \absV(c)$ for every $i = 0, 1, \ldots$ and
 %
 \item the edges $(e_0, \ldots)$, where $e_i = (l_{i}, dc_i, l_{i + 1}) \in \absE(c)$ for every $i = 0, 1, \ldots$.
 \end{itemize}
 A path is cyclic if it has the same start- and end-point. A path is simple if it does not visit a location twice except for the start- and end-location. We use $\paths(\absG(c))$ to denote the set of all the paths on $\absG(c)$,
 and $\pathl(p)$ to represent the list of program points corresponding to the vertices sequence of this path $p \in \paths(\absG(c))$,
 where $\pathl: \paths(\absG(c)) \to \mathcal{P}{(\ldom)}$.
 \end{defn}
 In Figure~\ref{fig:relatedNestedWhileOdd-overview}(b), $1 \to 2 \to 3 \to 4 \to 5 \to 4$ is a \emph{path} but not simple (the program points $4$ is visited twice). The path $4 \to 5 \to 4$ is both cyclic and simple.


\subsection{Program Rewriting}
This step rewrite the program in the form of combinations of execution paths.



\paragraph{Loop Header.}
We first collect the loop headers $\loopl(c) \subseteq \lvar(c)$ from a program $c$, which is the set of all program points corresponding to the loop headers in program $c$.
\begin{defn}[Loop Headers ($\loopl : \cdom \to \mathcal{P}(\ldom)$)]
  \label{def:loopl}
  \[
  \loopl(c) \triangleq 
  \left\{
    \begin{array}{ll}
      \{\}  & {c} = \clabel{\assign x e}^{l} \\
      \loopl({c_1}) \cup \loopl({{c_2}})  & {c} = {c_1};{c_2} \\
      \loopl(c_t) \cup \loopl({{c_f}})   & {c} =\eif(\clabel{\bexpr}^{l}, c_t, c_f) \\
  \loopl(c_w) \cup \{l\}, &  {c}   = \ewhile \clabel{\bexpr}^{l} \edo (c_w)
  \end{array}
\right.
\]
  \end{defn}

  \paragraph{The Simple Transition Path.}
  \begin{defn}[Simple Tansition Path]
  \label{def:tpath}
A \emph{simple transition path}
$\tpath \in \paths(\absG(c))$ for the program $c$, is either a simple cyclic path, which has the same start- and end-point
or a simple path has either different while loop headers, the program entrance or exit as its start- and end-point
without visiting any loop header inside the path.
\\
Specifically, a path $l_0 \xrightarrow{dc_0} l_1 \xrightarrow{dc_1} \ldots l_n \in \paths(\absG(c))$ with the
vertices sequence $(l_0, \ldots, l_n)$, where $l_i \in \absV(c)$ for every $i = 0, \ldots, n$ and
%
the edge sequence $(e_1, \ldots, e_n)$, where $e_i = (l_{i - 1}, dc_i, l_{i}) \in \absE(c)$ for every $i = 1, \ldots, n$,
%
is a \emph{simple transition path} if and only if it satisfies,
\begin{itemize}
  \item $l_i \neq l_j$ for every $i = 0, \ldots, n$ and $j = 0, \ldots, {n - 1}$,
  \item $l_0$ is either the program point of a loop header or the program entrance ($l_0 = 0$),
  i.e., $l_0 \in \loopl(c) \cup \{ 0 \}$
  \item and $l_n$ is either the program point of a loop header or the program exit ($l_n = \lex$),
  i.e., $l_0 \in \loopl(c) \cup \{ \lex \}$,
  \item and $l_i \notin \loopl(c) \cup \{ 0, \lex \}$ for every $i = 1, \ldots, n-1$.
\end{itemize}
\end{defn}
A simple transition path is also an execution path.

\paragraph{Syntax.}
The syntax of the refined program is given below. It is combination of the execution paths.
\[
    \rprog := \tpath ~|~ \rprepeat(\rprog) ~|~ l : \rprepeat(\rprog) ~|~ \rprog;\rprog ~|~ \rpchoose{\rprog, \ldots} 
\]
where $l\in \loopl(c)$ is a loop header.

In the new syntax, $\rprepeat(\rprog)$ is a loop statement iterating over the transitions in $\rprog$.
$l: \rprepeat(\rprog)$ represents that the loop $ \rprepeat(\rprog)$
corresponds to a loop of the source program with loop header $l$.
The multiple-paths statement $\rpchoose{\rprog, \ldots} $ contains all the execution paths of a loop from the source program.

\paragraph{Algorithm.}
Algorithm~\ref{alg:alg-refine_rewrite} transforms the syntax of the while language program 
into the new syntax defined above.
% following~\cite{GulwaniJK09} and preserves the semantics.

In this algorithm, we first use a simple depth-first search strategy to collect all the \emph{simple transition path}s satisfying the Definition~\ref{def:tpath}. 
% It guarantees that every $\tpath$ is equivalent to a path $\rho$ in Definition~4.1 of \cite{GulwaniJK09}.
In line:2, we initialize each candidate $c_i$ with a \emph{simple transition path} $\tpath_i$. 
New candidates generated in line:4, 5, and 6 correspond to the loop statement $\rprepeat(c_i)$, multiple-paths statement $\rpchoose{\ldots}$ and sequence statements $c_i; c_j$ respectively.

\begin{algorithm}
 \caption{Program Rewriting Algorithm. $\kw{Rewrite}(c)$}
 \label{alg:alg-refine_rewrite}
 \begin{algorithmic}[1]
 \REQUIRE program $c$
%  collects all $c$'s \emph{simple transition path}s from $\absG(c)$, $\tpath_1, \ldots, \tpath_n \in \paths(\absG(c))$.
 \STATE \textbf{init}: 
 Set of all \emph{simple transition path}s, 
 $\mathcal{P} = \{ \tpath_1, \ldots, \tpath_n \}$.
 \\
 The candidate set $W = \{c_1, \ldots, c_n\}$, where $c_i = \tpath_i$ for $i = 1, \ldots, n$
 \STATE \textbf{while} $W.size()> 1$:
 \STATE
 \quad create $c' = \rprepeat(c)$ s.t. $c_i \in W \land c[0] = c[-1] \land c[0] \in \loopl(c)$
 \\ \quad $W.add(c[0]: c')$, \qquad $W.remove(c)$
 \STATE \quad create $c' = \rpchoose{c_1, \ldots, c_m}$ 
 s.t. $c_i, c_j \in W \land c_i[0] = c_j[0] = c_i[-1] = c_j[-1]$, $i, j = 1, \ldots, m$.
 \\ \quad $W.add(c')$ \qquad $W.remove(c_1, \ldots, c_m)$
 \STATE \quad create $c' = c_1; c_2$ s.t. $c_1, c_2 \in W \land c_1[-1] = c_2[0]$
 \\
 \quad $W.add(c')$ \qquad $W.remove(c_1, c_2)$
 \STATE \textbf{Endwhile}
 \\ $c^T = W[0]$
 \RETURN $c^T$.
\end{algorithmic}
\end{algorithm}
%
%  in paper~\cite{GulwaniJK09} respectively.
\begin{itemize}
\item
Line:4 find the candidate $c'$ that has the same start- and end-point.
Each candidate corresponds to a loop path, and we create for this candidate a loop statement
$\rprepeat(c')$.

\item
 Line:5 
 finds all the candidates $c_1, \ldots, c_m$ that start and end at the same point.
 These candidates are multiple-paths of a same loop, 
 we create for these candidates a multiple-path loop statement,  $\rpchoose{c_1, \ldots, c_m}$.
\item
Line:6 finds all pairs of candidates $c_1, c_2$ such that  $c_2$ starts with the point where $c_1$ ends.
%  label, rewrite them 
For each pair, we create a sequence statement
 $c_1; c_2$.
\end{itemize}