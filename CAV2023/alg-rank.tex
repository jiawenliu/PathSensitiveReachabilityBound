The approach in this step is inspired mainly from the Algorithm.2 in paper~\cite{SinnZV14},
  % which assigns a variable to each edge on which this variable decrease as its ranking function.
  the Algorithm.3 in paper~\cite{ZulegerGSV11},
  and the Definition.25 in Section 4 of paper~\cite{SinnZV17} with three sub-steps.
  % Algorithm.3 in paper~\cite{ZulegerGSV11} assigns a set of variables to each transition in which these variables decrease as the local bound
  % and estimates the maximum value each variable in this set.
  % Algorithm.2 in paper~\cite{SinnZV14} assigns a variable to each edge on which this variable decrease as its ranking function
  % and then estimates the maximum value for the ranking function.
  % The Definition.25 in paper~\cite{SinnZV17}
  % assigns each transition with a variable that decreases in this transition, as the local bound and computes the bound similarly.

% The three sub-steps are standard and based on the Definition.25 in paper~\cite{SinnZV17}.

\paragraph{Collecting Variable Modifications}
  For each variable $x$ in a program $c$, this step computes three edge sets, $\inc(c, x)$, $\dec(c, x)$,
  and $\reset(c, x)$ for $x$.
  Every edge in a set corresponds to a transition in which $x$ is increased,
  %  $\inc(c, x)$,
  decreased
  % $\dec(c, x)$ and 
  or reset
  % $\reset(c, x)$, 
  respectively.
  \begin{defn}[Variable Modifications]
    \label{def:var_modi}
    For each variable $x$ in a program $c$ with $\absG(c)$,
    $\inc: \cdom \to \vardom \to \mathcal{P}(\absevent) $
    is the set of the edges where the variable increase, $\inc(c, x) = \left\{ \absevent | \absevent = (l, x' \leq x + v, l') \land \absevent \in \absE(c) \right\}$;
    $\dec: \vardom \to \mathcal{P}(\absevent) $
    is the set of abstract events where the variable decrease where
    %\\
    $\dec(c, x) = \left\{\absevent| \absevent = (l,  x' \leq x - v, l') \land \absevent \in \absE(c) \right\}$;
    %\\
    $\reset: \cdom \to \vardom \to \mathcal{P}(\absevent) $ is the set of the abstract events where the variable is reset such that
  %
    $\reset(c, x) = \left\{ \absevent| \absevent = (l,  x' \leq y - v, l') \land x \neq y \land \absevent \in \absE(c) \right\}$.  
  \end{defn}
%   \\
%   $\inc: \cdom \to \vardom \to \mathcal{P}(\absevent) $
%   is the set of the edges where the variable increase, 
%   %\\
%   \[ \inc(c, x) = \left\{ \absevent | \absevent = (l, x' \leq x + v, l') \land \absevent \in \absE(c) \right\} \]
%   %\\
%   $\dec: \vardom \to \mathcal{P}(\absevent) $
%   is the set of abstract events where the variable decrease,
%   %\\
%   \[\dec(c, x) = \left\{\absevent| \absevent = (l,  x' \leq x - v, l') \land \absevent \in \absE(c) \right\}\]
%   %\\
%   $\reset: \cdom \to \vardom \to \mathcal{P}(\absevent) $ is the set of the abstract events where the variable is reset,
% %
%   \[\reset(c, x) = \left\{ \absevent| \absevent = (l,  x' \leq y - v, l') \land x \neq y \land \absevent \in \absE(c) \right\}\]
  Additionally,
  we also implement the reset graph and the reset chain for higher precision. The computation is mainly following the Definition~20 in~\cite{SinnZV17}.
  % \[\resetG(c) = (\resetV(c), \resetE(c))\]
  % \[\resetE(c) = \left\{ (x, \absevent, y) ~\vert~ \absevent \in \reset(c, x) \land \absevent = (l, x' \leq y + c, l') \right\} \]
  % \[\resetV(c) = \left\{ x ~\vert~ (x, \_, \_) \in \resetE(c) \lor (\_, \_, x) \in \resetE(c) \right\} \]
  % In a variable $x$'s reset chain set, $\resetchain(c, x)$, in each chain $(e_0, \ldots, e_m) \in \resetchain(c, x)$
  % a variable $x_i$ is reset by another variable $x_{i + 1}$ on edge $e_{i}$
  % and $x_{i + 1}$ is reset on edge $e_{i + 1}$ recursively
  % for every $i = 0, \ldots, m - 1$.
  % $x$ is reset on the first edge $e_0$ of every sequence in $\resetchain(c, x)$.
  % {Each edge $e_i$ in a sequence $(e_0, \ldots, e_m) \in \resetchain(c, x)$
  % resets a variable $x_i$ by another variable $x_{i + 1}$ such that $x_{i + 1}$
  % is reset on edge $e_{i + 1}$ recursively. The first edge $e_0$ of each sequence resets the variable $x$.}
  % % 
  % \\
  % In the following steps, $c$ is omitted in $\inc(c, x)$,
  % $\dec(c, x)$ and $\reset(c, x)$ for concise when the reference of a program $c$ is clear in the context.

  \paragraph{Assigning The Ranking Function}
  For each edge in the transition graph $\absG(c)$ of a program $c$,
  this step assigns the variable that decreases on this edge as the ranking function of this edge.
  This step adopts the local bound computation method in Section 4 of~\cite{SinnZV17} to assign the local bound to each edge as follows.
  \begin{defn}[Ranking Function Generatation]
  \label{def:ranking_gen}
  For every edge $\absevent$ in the transition graph $\absG(c)$ of a program $c$,
  its \emph{ranking function/local bound}, $\locbound(\absevent, c)$
  is the variable that decreases on this edge, computed as follows,
{\small
\[ 
\begin{array}{ll}
  \locbound(\absevent, c) \triangleq 1 
  & \absevent \notin SCC(\absG(c))
  \\
  \locbound(\absevent, c) \triangleq x
  & \absevent \in SCC(\absG(c)) \land \absevent \in \dec(c, x) \land  \absevent = (\_, \_ , x' \leq x - v) \\
  \locbound(\absevent, c) \triangleq x
  & \absevent \in SCC(\absG(c)) \land 
  \absevent  \notin \bigcup_{x \in \vardom} \dec(c, x)
  \land \absevent \notin SCC(\absG(c) \setminus \dec(c, x))\\
  \locbound(\absevent, c) \triangleq \infty
  & o.w..
\end{array}
\]
}
$SCC(\absG(c))$ is the set of all the strong connected components of $\absG(c)$.
  \end{defn}
  %
  \todo{Example of ranking function estimated}
 \paragraph{Estimating the Upper Bound Invariant for Ranking Functions}
Then we estimate the upper bound invariant,  $\varinvar(\locbound(\absevent, c), c)$ for the ranking function of each abstract transition, $\locbound(\absevent, c)$. Meanwhile, we interactively compute an iteration upper bound,  $\absclr(\absevent, c)$  for each $\absevent$ path-insensitively when estimating the ranking function invariant.
\begin{defn}[Ranking Function Estimation]
  \label{def:ranking_bound}
For a program $c$ and an edge $\absevent \in \absE(c)$,
the \emph{ranking function bound}, 
$\varinvar(\locbound(\absevent, c), c)$ for the ranking function $x = \locbound(\absevent, c)$
of this edge
is computed as follows,
{\small
  \[ 
\begin{array}{lll}
  \varinvar(x, c) & \triangleq x & x \in \scvar(c) \\
  \varinvar(x, c) & \triangleq \incrs(x, c) + \max\left\{\varinvar(y, c) + v ~\mid~ (l, x' \leq y + v, l') \in \reset(c, x) \right\} & x \notin \scvar(c)
\end{array}
\]
}
%
where $\incrs(x, c) \triangleq \sum\limits_{\absevent \in \inc(c, x)}\{\absclr(\absevent, c) \times v ~\mid~ \absevent = (l, x' \leq x + v, l')\}$
The path-insensitive bound, $\absclr(\absevent, c) \in \scexpr(c)$  on the execution times of the transition $\absevent$, is interactively computed as well as below,
\footnote{We only give the sub-routine computation based on the variable reset set ($\reset$) for  easier understanding.
% instead of the reset chain ($\resetchain$), and 
And we implement the reset graph and the reset chain based approach for higher precision.
}
{\small
% \[ 
% \begin{array}{lll}
% \absclr(\absevent, c) 
% & \triangleq \varinvar(\locbound(\absevent, c), c)  &  \\
% & \quad \text{if} ~ \locbound(\absevent, c) \in \scvar(c) & \\
% \absclr(\absevent, c) 
% & \triangleq
%   \sum \left\{ \incrs(y, c) | ch \in \resetchain(x, c) \land y \in ch \right\} & \\
%   & \quad + 
% \sum\limits_{ch \in \resetchain(x, c)}
% \min \left\{\absclr(\absevent', c) ~\mid~ \absevent' \in ch\right\} \times 
% \big(\varinvar(in(ch), c) 
% + \sum\limits_{(\_, (\_, x' \leq y + v, \_), \_) \in ch} v \big) & \\
% &  \quad \text{if} ~\locbound(\absevent, c) = x \land x \notin \scvar(c) & ,
% \end{array}
% \]
\[ 
\begin{array}{lll}
  \absclr(\absevent, c) 
  & \triangleq \varinvar(\locbound(\absevent, c), c)   \qquad \qquad  \text{if} \quad  \locbound(\absevent, c) \in \constdom & \\
  \absclr(\absevent, c) 
  & \triangleq \incrs(x, c) 
   + 
  \sum\limits_{\absevent' \in \reset(x, c) \land \absevent' = (l, x \leq y + v, l') }
  \Big( \absclr(\absevent', c) \times \big( \varinvar(y, c) + v \big) \Big)
  & \\
  &  \text{if} \quad  \locbound(\absevent, c) = x \land x \notin \constdom &.
\end{array}
  \]
}
% where $in(ch)$ is the first vertex of the reset chain $ch$.
\end{defn}
\todo{Example of computed invariant for ranking function and the transition bound}
