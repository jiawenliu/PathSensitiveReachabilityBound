% The programs' execution complexity affects our daily life from many perspectives.
% For example,
% from the privacy and security perspective,
% how much secret information is leaked by a program depends on the number of times a certain operation that leaks the data,
% is executed~\cite{Malacaria07};
% the amount of perturbation in the output data values resulting
% from a small perturbation or uncertainty in the input,
% values depend on the number of times additive error propagation operators are applied; etc.
% Estimating such quantitative properties requires us to know
% how many times is a given control location inside the program that performs certain operations executed?
% % \\
% From the performance perspective, it is important to give a precise estimation
% on the program's resource cost bound w.r.t. the program's inputs.
% For example, in memory-constrained environments such as embedded systems,
% it is important to bound the amount of memory required to run certain applications.
% In real-time systems, it is important to bound the worst-case execution time of the program.
% Applications running on low-power devices or low-bandwidth environments must use up little power or bandwidth respectively. 
% With the advent of cloud computing, where users would be charged per program execution,
% predicting resource usage characteristics would be a crucial component of accurate bid placement by cloud providers. 
% One of the challenges in bounding this cost precisely is that resource consumption is location-sensitive.
% In other words, 
% Different location has different resource cost as well as different execution times. 
% To give accurate estimation results on these execution properties,
% the fundamental questions that need to be addressed 
% is estimating the bound on the execution times
% a given control location inside the program that consumes these resources.
% For these reasons, this paper focuses on analyzing the bound on the execution times of a program's given control location.
% This bound is referred to as the reachability-bound in the program analysis area,
% which is firstly proposed by the paper~\cite{GulwaniZ10}.
% In this paper, finding a symbolic worst-case bound on this quantitative reachability property
% in terms of the inputs to that procedure
% is referred to as the \emph{reachability-bound problem}.

Gulwani et. al first introduced \emph{reachability-bound} as the upper bound on the number of times a given control location 
inside a procedure is visited during the program execution in~\cite{GulwaniZ10}.
A tight reachability-bound has a lot of applications.
For example from the privacy and security perspective,
how much secret information is leaked by a program depends on the number of times a certain operation that leaks the data,
is executed~\cite{Malacaria07};
from the efficiency perspective, when different program location consumes different resources, it is important to give a precise estimation on reachability-bound on each location.
While most of existing works have different limitations in inferring the \emph{reachability-bound} for each location.
Gulwani et. al
gave a two-step solution by combining the abstract interpretation and proof-rules-based techniques but not solve this problem in a path-sensitive manner.
% However, their solution
% does not solve this problem in a path-sensitive manner.
It over-approximates the reachability-bounds on different paths inside a while loop with the overall while loop.
% \\
Techniques in program complexity analysis~\cite{GustafssonEL05,HumenbergerJK18} 
or worst-case resource cost analysis
~\cite{BrockschmidtEFFG16,AlbertAGP08,AliasDFG10,Flores-MontoyaH14} can be reused to estimate similar quantity such as the
bounds on loop iterations, execution time, etc.
While these quantities focus only on  
the overall complexity.
% There are also many works in analyzing the program complexity~\cite{GustafssonEL05,HumenbergerJK18},
% or estimating the upper bound on a program's worst-case resource cost
% ~\cite{BrockschmidtEFFG16,AlbertAGP08,AliasDFG10,Flores-MontoyaH14}.
% But their analysis
% focus only on estimating 
% the overall complexity 
% by inferring the bounds on the loop iteration numbers,
% or the worst-case running time and resource cost of the program's entire execution.
None of them computes the reachability-bound on a given program control location directly or path-sensitively.
This leads to the inaccuracy in the data leakage analysis, resource analysis, etc.
%  cannot be effectively used.
% conflation of paths/useless result/or whatever people 
% \todo{Combine the next two limitations with the general limitations above}
To overcome these limitations and solve 
the reachability-bounds problem efficiently and path-sensitively, 
we introduce a novel path-sensitive reachability-bound analysis algorithm that is built over abstract transition graph and effectively combines the amortized complexity analysis with loop summarization based multipath refinement algorithm.
The effective combination complements the limitations in both lines. Below are some related works and the limitations in these lines.

\begin{itemize}
\item \emph{Program Abstraction.}

Program abstraction are commonly used in program analysis area as a preprocess step to abstract the program feature and generate transition graph or system. For example, \cite{GulwaniZ10} summarizes the program into abstract domain such as the unified lattice~\cite{CousotH78}, polyhedra~\cite{CousotC77} or octagons~\cite{Mine06} domain and generates the transition system for counter variables.
% But none of the three abstraction models can represent the if guard in multipath loop, and solving the transition system using these abstraction models is low-efficient.
\cite{KincaidCBR18} abstracts program into the wedge domain and computes the non-linear loop invariant.
%  While it only works well for the specific targeting problem.
The trade-off between the accuracy and the low-efficient in generating and solving these constraints is the main bottleneck.
% , inaccuracy in summarizing the multipath loops
%  and solving the path-sensitive reachability-bound problem.
We choose to use the difference constrain based~\cite{SinnZV17,SinnZV14} program abstraction model combined with boolean expression abstraction to generate our abstract transition graph.
It is more accurate in the sense of representing the program loops path-sensitively and comparatively lightweight.
%  and is more accurate, it is also efficient to solve. 
% than the state-of-art program abstraction models mentioned above.
% While our program abstraction model is based on the difference constrain model in~\cite{SinnZV17} and the size change abstraction in~\cite{SinnZV14}, which is more efficient comparing to the models above. 
% The efficiency also benefit from our
% semantics model, which is inspired from~\cite{Cousot19a} and~\cite{Cousot19} and has similar intuition with the program model in~\cite{SinnZV17}.

% \paragraph{Type-Based Static Cost Analysis.}
\item \emph{Amortized Complexity Analysis.}

One line of complexity analysis follows the idea of the \emph{amortized complexity analysis} originated from Tarjan's influential paper~\cite{PotechinP17} combined with ranking function~\cite{BradleyMS05,CookSZ13,Zuleger18} or counter increment and developed in~\cite{ZulegerGSV11,SinnZV14,SinnZV17,LuCT21,AliasDFG10}.
They do well in nested loops by alternating the loop bound computation with the ranking or counter estimation. This alternation is efficient without recursively unrolling the nested loops when composing the bound of different paths.
  % \\
  But estimating the counter or ranking function invariant ignores the interleaving between multiple paths in the same loop.
Most of them (including some existing tools CofloCo~\cite{Montoya17,Flores-MontoyaH14,Flores-Montoya16}, KoAT~\cite{BrockschmidtEFFG16,BrockschmidtEFFG14,FalkeKS12,FalkeKS11}, the algorithm in~\cite{LuCT21}) over-approximate the loop bound when the path interleaving affects the loop execution. They give the entire loop bound path-insensitively as the reachability-bound on different points. Another kind of \emph{amortized complexity analysis} based on type refinement or annotation such as~\cite{CraryW00,JostHLH10,CicekBG0H17,RajaniG0021,CarbonneauxHS15} have the same weakness in considering the paths interleaving, and over-approximating the resource cost on different program points.
%   For the same reason, some 
% including some existing tools CofloCo~\cite{Montoya17,Flores-MontoyaH14,Flores-Montoya16}, KoAT~\cite{BrockschmidtEFFG16,BrockschmidtEFFG14,FalkeKS12,FalkeKS11}, and the amortized algorithm in~\cite{LuCT21} which we evaluated over our benchmarks give the entire loop bound path-insensitively.
  % Another kind of \emph{amortized complexity analysis} based on type refinement or annotation. For example \cite{CraryW00} presents a type system for the certification of resource bounds (once they are provided by the programmer).
  % %  In contrast, we infer bounds for different program location. 
  % \cite{JostHLH10} uses linear programming to infer bounds for functional programs, but they are restricted to computing only linear bounds.
  % Other techniques that are based on
  % type system~\cite{CicekBG0H17,RajaniG0021}, the cost analysis via effect systems~\cite{CicekBG0H17,RadicekBG0Z18,QuG019}, and Hoare logic~\cite{CarbonneauxHS15}
  % give the approximated upper bound of the program's total resource cost as well but still failed to consider the path sensitivity and the resource cost on different program points.
  % Another kind of \emph{amortized complexity analysis} based on type refinement or annotation such as~\cite{CraryW00,JostHLH10,CicekBG0H17,RajaniG0021,CarbonneauxHS15}
  % give the approximated upper bound of the program's total resource cost as well but still failed to consider the path sensitivity and the resource cost on different program points.

  To improve in the setting of multiple paths, our method combines this analysis with loop refinement techniques to complement its limitations.
\item
\emph{Loop Summarization and Path Refinement Based Complexity Analysis}

Another line of loop bound analysis through loop summarization and path refinement seeks for precise loop path representation~\cite{ManoliosV06,BalakrishnanSIG09,SharmaDDA11,Flores-MontoyaH14,HumenbergerJK18,CyphertBKR19}, and explicating the interleaving between paths~\cite{GulwaniJK09,ZulegerGSV11}.
\cite{KincaidBCR19} introduces a precise closed-form loop summarization techniques which can help to improve the accuracy of the path refinement, as well as the non-linear loop summarization techniques~\cite{KincaidCBR18} and the invariant generating algorithm considering recurrence in~\cite{BreckCKR20}. 
But the limitation occurs when composing the bound between nested loops in most works of this line, which recursively unrolls the nested loops. This is heavy and non-terminating in most cases.

We simplify the path refinement algorithm in~\cite{GulwaniJK09} by contextualization techniques in~\cite{ZulegerGSV11,SinnZV14}, which is originated from~\cite{ManoliosV06},
and limit the iterations of the refinement algorithm to a constant in our bound analysis algorithm.
\end{itemize}
%
We perform both the path refinement and the ranking estimation over an abstract transition graph through program abstraction presented in Section~\ref{sec:progabs}.
The combination utilizes the effectiveness of the \emph{amortized complexity analysis} by computing the ranking function
% $\locbound(\absevent, c)$ for each transition edge $\absevent$, 
and estimating its bound invariant in Section~\ref{sec:rank}.
In the meantime, it is benefited from the accuracy of the path refinement techniques through a light-weight path refinement algorithm adopted from~\cite{GulwaniJK09} in Section~\ref{sec:refine}.
Build over this combination, we introduce two novel quantities,
the \emph{path reachability-bound} and \emph{loop reachability-bound}.
The first one bounds the evaluation times of each loop free and interleaving free path in a refined program, and the second one bounds the iterations of an outer loop w.r.t. the innermost loop such that in these iterations of outer loop, the innermost loop is ``entered''. 
Then we present the algorithm for estimating the two quantities in Section~\ref{sec:looprb} and~\ref{sec:pathrb} and compute the \emph{reachability-bound} for each program point path-sensitively in Section~\ref{sec:psrb}.
Our evaluation on the prototype implementation in Section~\ref{sec:eval} shows that we can accurately estimate different bounds for different program points on multiple loop paths. The main contributions are as follows.

\begin{itemize}
  \item 
1. A path-sensitive reachability-bound algorithm, which computes sound bound on the evaluation times of each program point path-sensitively.
 \item 
2. The combination of the \emph{amortized bound analysis} through ranking function estimation and the path refinement approach in our algorithm.
\item 
3. Two novel quantities, the \emph{path reachability-bound} and \emph{loop reachability-bound} and the corresponding estimating algorithms.
\item 
4. A prototype implementation with evaluation over four different benchmarks.
  The evaluation shows that we can compute different bounds on the evaluation times of different program points in the same loop accurately.
\end{itemize}