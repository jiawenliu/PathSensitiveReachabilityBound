Similar to the \emph{loop bound} computation,
we first compute two abstract states for each loop w.r.t. a simple transition path nested inside,
$\lpinit(\rprog, \tpath, c)$, and $\lpnext(\rprog, \tpath, c)$ based on the refined program
as in Definition~\ref{def:alg-absstate}.
\begin{defn}[Loop Abstract States]
\label{def:alg-loopabsstate}
Given a program $c$ with its refined program $\rprog_c$, for a $\tpath$ and an outer loop program $\rprog$ where $\tpath$ is nested in $\rprog_c$,
$\lpinit(\rprog, \tpath, c), \lpnext(\rprog, \tpath, c) \in \scexpr(c)$
w.r.t. the ranking functions are computed as follows.
   \begin{itemize}%
   \item 
The loop initial state 
$\lpinit(\rprog, \tpath, c) \in \scexpr(c)$ computes a symbolic expression, which is an upper bound for the initial value of $\tpath$'s ranking function before
any visit of $\tpath$ and during the first execution of $\rprog$.
\[
  \begin{array}{l}
    \lpinit(\rprog, \tpath, c) \triangleq 
  \arg\max_{l_1}
  \\
  \left\{
       \varinvar(y, c) + v ~\middle\vert~ 
       \begin{array}{l} 
         (l_1, x' \leq y + v, l_2) \in \reset(x, c) 
         \\
         \land \absinit(\rprog) \leq l_1 \leq \absinit(\tpath)
         \land
         x \in \left\{ \locbound(\absevent, c) | \absevent \in \tpath \right\}
       \end{array}
     \right\}
    \end{array}
    \]
\item
The loop next state 
$\lpnext(\rprog, \tpath, c) \in \scexpr(c)$ 
estimates the amount for $\tpath$'s ranking function
that is modified before
the second visit of $\tpath$ but during the second execution of $\rprog$.
$ 
\lpnext(\rprog, \tpath, c) \triangleq 
\max\limits_{x \in \left\{ \locbound(\absevent, c) | \absevent \in \tpath \right\}}
$
%
{\small
\[
  \begin{array}{l}
  % \lpnext(\rprog, \tpath, c) \triangleq 
  % \max\limits_{x \in \left\{ \locbound(\absevent, c) | \absevent \in \tpath \right\}}
  % \\
  \left\{
    \begin{array}{l}
  \sum\limits_{\absevent \in \inc(x, c) }
  \left\{ 
      v ~\middle\vert~ \absevent = (l', x' \leq x + v, \_) \land  l' \in \rprog 
      \land l' \notin \tpath \right\}
      \\ \qquad 
      + \arg\max\limits_{l_2 }
         \left\{ \varinvar(y, c) + v ~\middle\vert~ 
         (l_1, x' \leq y + v, l_2) \in \reset(x, c) \land l_1 \in \rprog \land l_1 \notin \tpath\right\}
     \\ \qquad 
      - \sum\limits_{ \absevent \in \dec(x, c) }\left\{ 
      v 
      ~\middle\vert~ \absevent = (l', x' \leq x + v, \_) \land l' \in \rprog \land l' \notin \tpath \right\}
      \\ \qquad 
      + BD(\kw{enclosed}(\tpath), c) \times \rfnext(\tpath, c)
    \end{array}
    \right\}
  \end{array}
  \]
  }
    \end{itemize}
\end{defn}
%
Then we compute the
\emph{loop reachability-bound} as below.
% using the two states and the $\rffinal$.
\begin{defn}[Loop Reachability-bound Computation]
  \label{def:looprb}
  Given a refined program $\rprog$ and a simple transition path $\tpath$ in this program, 
  let $\rprog_l$ be a loop program in $\rprog$,
  then $\rprog_l$'s \emph{loop reachability-bound} w.r.t. $\tpath$, $\lpchB(\rprog, \tpath, c)$
  is computed interactively with the abstract loop states as follows. 
  \[
    \lpchB(\rprog, \tpath, c) \triangleq
    \max\limits_{x = a \in \rffinal(\tpath, c)}
    \frac{\lpinit(\rprog, \tpath, c) - a }{\lpnext(\rprog, \tpath, c)}
  \]
\end{defn}
%
Again in Example~\ref{ex:relatedNestedWhileOdd-overview}, $\tpath_3$ has an outer loop program $\rprog_1^1$.
We first compute $\lpinit(\rprog_1^1, \tpath_3, c) = n - m $ and $\lpnext(\rprog_1^1, \tpath_3, c) = n - m - 1$ and then derive $\lpchB(\rprog_1^1, \tpath_3, c) = 1$ as tight as expected.
%

We also guarantee the soundness of \emph{loop reachability-bound} in \highlight{Appendix~\ref{apdx:looprb-sound}}.
The $\lpchB(\rprog, \tpath)$ 
can also be over-approximated by
$I(l, l')$ through the progress invariant in paper\cite{GulwaniJK09}.
While $I(l, l')$ over-approximates this value largely
by estimating the bound on iteration numbers of $l'$ in one iteration of $l$.

Example~\ref{ex:relatedNestedWhileOdd-overview} has only two level nested loop, and
the only interesting \emph{loop reachability-bound} is $\lpchB(\rprog_1^1, \tpath_3)$.
We illustrate Example~\ref{ex:threeNestedWhile} with three nested loops, which can better show the improvement of the \emph{loop reachability-bound}.
\begin{example}[Three Nested Loop]
  \label{ex:threeNestedWhile}
\input{examples/threeNestedWhile-overview}
This example is similar to the loop $L_4$ nested in the second branch in example~\ref{ex:relatedNestedWhileOdd-overview}.
$w$ is reset by $j$ in command 5 and $i$ is then reset by $w$, so $L_6$ is only executed in the first iteration of loops $L_1$ and $L_3$.
% \\
Then the total iterations times are
$n + m^2 - m \times N$,
and the expected \emph{reachability-bound} for location $7$ inside the $L_6$ is $N$,
for locations $4, 5$ and $8$ between the $L_3$ and $L_6$ are $(n-N) \times (m - N)$,
and $n - N$ for locations $2$ and $9$.
% \\
The challenge here is that the locations inside the loop $L_6$ has the same
\emph{reachability-bound} as the local iteration times of $L_6$.
% , as well as our \emph{path reachability-bound}.
While for the locations between $L_3$ and $L_6$, their bounds are the product of the inner and outer loop iteration bounds.
In order to compute the precise bound, it is critical to know
the numbers of iterations of the outer loops $L_3$ and $L_1$ such that,
during these iterations, the loop $L_6$ is ``entered'', which is exactly our \emph{loop reachability-bound}.

Figure~\ref{fig:threeWhile-overview}(a) shows its abstract transition graph,
and we compute its refined program in the bottom of Figure~\ref{fig:threeWhile-overview}. 
We use $\rprog_1$, $\rprog_3$ and $\rprog_6$ to denote the body of the loop $L_1$, $L_3$ and $L_6$ respectively.
We first compute the $\outinB(\rprepeat(\tpath_3), \tpath_3, c) = N $ for $\tpath_3$ w.r.t. its innermost loop.
$\tpath_3$ has two outer loops, $L_1$ and $L_3$,
%  it is nested.
to compute $\lpchB(\rprog_1, \tpath_3)$,
we first compute $\lpinit( \rprog_1, \tpath_3, c) = 0$,
$\lpnext( \rprog_1, \tpath_3, c) =  N + 1 $, and
$\rffinal(\rprog_1, c) = \{ i = n, k = N \}$.
So we can know $\lpchB(\rprog_1, \tpath_3, c) = \max\{ \frac{n - 0}{n - N - 1}, \frac{N - 0}{N +  1}\} = 1$, as expected.
In the same way, we also compute $\lpchB(\rprog_3, \tpath_3, c) = 1$ as well.
\end{example}
