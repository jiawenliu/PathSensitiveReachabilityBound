Given a program $c$ with its \emph{Abstract Transition Graph}, $\absG(c)$ and refined program $\rprog$, our path-sensitive reachability-bound algorithm is presented as follows.
\begin{enumerate}
  \item We first compute the loop bound, $BD(\rprog', c) \in \scexpr(c)$ for every subprogram $\rprog'$ of $c$ in $\rprog$.
  \begin{defn}[Loop Bound]
    % \label{def:loopbound}
    For any program $c$ with it refined program $\rprog$,
    the loop bound $BD(\rprog', c) \in \scexpr(c)$ for a subprogram $\rprog'$ of $c$ in $\rprog$ is a upper bound on the iterating times of this program from its enter point to the exit point.
  \end{defn}

  \item Then we compute the \emph{path local reachability-bound}, $\outinB(\rprog_l, \tpath, c) \in \scexpr(c)$ for every sub loop program $\rprog_l$ of $c$ in $\rprog$.
      \begin{defn}[Path Local Reachability-bound]
        % \label{def:pathlocalrb}
        Given program $c$ with its refined program $\rprog$ and a simple transition path $\tpath$ in this program, 
        let $l: \rprog_l = \kw{enclosed}(\rprog, \tpath)$ be a sub loop program in $\rprog$,
        then $\tpath$'s \emph{path local reachability-bound} w.r.t. $l: \rprog_l$,  $\outinB(\rprog_l, \tpath, c) \in \scexpr(c)$
       is an upper bound on the execution times of $\tpath$ when executing program $\rprog$.
      %   is computed inductively as follows. 
      % \[
      %   \begin{array}{rcl}
      %     \outinB(\tpath, \tpath) & \triangleq & 1 \\
      %     \outinB(\tpath', \tpath) & \triangleq & \highlight{0} \qquad \text{if } \tpath' \neq \tpath\\
      %     \outinB(\rprog_1;\rprog_2, \tpath) & \triangleq & \outinB(\rprog_1, \tpath) + \outinB(\rprog_2, \tpath) \\
      %     \outinB(\rpchoose{\rprog_1, \ldots, \rprog_m }, \tpath) & \triangleq 
      %     & \max\left\{ \outinB(\rprog_1, \tpath), \ldots, \outinB(\rprog_m, \tpath) \right\} \\
      %     \outinB(\rprepeat(\rprog'), \tpath) & \triangleq 
      %     & BD(\rprepeat(\rprog'), c) \times \outinB(\rprog', \tpath)
      %      \\
      %      \outinB(l: \rprog_l, \tpath) & \triangleq & \outinB(\rprog_l, \tpath) \\
      %      \outinB(l': \rprog', \tpath) & \triangleq & 0  \qquad \text{if } l': \rprog' \neq \kw{enclosed}(\rprog, \tpath)
      %   \end{array}
      %   \]
    \end{defn}
    Intuitively, the local reachability-bound of a \emph{simple transition path},
    $\outinB(\rprog, \tpath, c)$ bounds the execution times of $\tpath$ when executing program $\rprog$,
    and $\rprog$ is the closest loop where $\tpath$ is nested.

  \item  Next, we compute the \emph{loop reachability-bound},
        $\lpchB(l: \rprog_l, \tpath, c) \in \scexpr(c)$ for every sub loop program $\rprog_l$ of $c$ in $\rprog$ w.r.t. a \emph{simple transition path} $\tpath$ located in this loop program.
      \begin{defn}[Loop Reachability-bound]
        % \label{def:looprb}
        For a program with its refined program $\rprog$ and a simple transition path $\tpath$ in this program, 
        let $l: \rprog_l$ be a loop program in $\rprog$,
        then $l: \rprog_l$'s \emph{loop reachability-bound} w.r.t. $\tpath$,  $\lpchB(l: \rprog_l, \tpath, c) \in \scexpr(c)$
        is the upper bound on iteration numbers of the outside loop $l$,
        such that,
        during these iterations, the nested loop $l' = \kw{enclosed(\tpath)}$ is executed, i.e., entered.
        % is computed recursively as follows. 
        % \[
        %   \lpchB(l: \rprog, \tpath, c) \triangleq
        %   \frac{\lpinit(\rprog, \tpath, c) - \rffinal(\tpath, c)}{\lpnext(\rprog, \tpath, c)}
        % \]
      \end{defn}
        Intuitively $\lpchB(l: \rprog_l, \tpath, c) \in \scexpr(c)$
        is the bound on iteration numbers of the outside loop $l$,
        such that,
        during these iterations, the nested loop $l' = \kw{enclosed(\tpath)}$ is executed, i.e., reached.
      \item 
      Then for each \emph{simple transition path} $\tpath$, we compute its \emph{path reachability-bound}, $\inoutB(\rprog, \tpath)$ as a reachability-bound of $\tpath$.
      %
      \begin{defn}[Path Reachability-bound]
        % \label{def:pathrb}
        For a program $c$ with its refined program $\rprog$ and a simple transition path $\tpath$ in this program, 
        $\tpath$'s reachability-bound, $\inoutB(\rprog, \tpath) \in \scexpr(c)$ is the upper bound on the
        execution times of $\tpath$ when executing the $\rprog$.
      %   is computed recursively as follows. 
      % \[
      %   \begin{array}{rcl}
      %     \inoutB(\tpath, \tpath) & \triangleq & 1  \\
      %     \inoutB(\tpath', \tpath) & \triangleq & \highlight{0} \qquad \text{if } \tpath' \neq \tpath\\
      %     \inoutB(\rprog_1;\rprog_2, \tpath) & \triangleq & \inoutB(\rprog_1, \tpath) + \inoutB(\rprog_2, \tpath) \\
      %     \inoutB(l: \rprog_l, \tpath) & \triangleq & 
      %     \highlight{\outinB(\rprog', \tpath), \qquad \text{if } l = \kw{enclosed}(\tpath)}
      %     \\
      %     &  & 
      %     \highlight{
      %       \lpchB(l:\rprog_l, \tpath ) }
      %     \highlight{\times \max\limits_{l:\rprog_l = \kw{enclosed}(l':\rprog')}
      %    \{\inoutB(l':\rprog', \tpath)\} } \footnotemark, o.w. \\
      %     \inoutB(\rpchoose{\rprog_1, \ldots, \rprog_m }, \tpath) & \triangleq 
      %     & \max\left\{ \inoutB(\rprog_1, \tpath), \ldots, \inoutB(\rprog_m, \tpath) \right\} 
      %     \\
      %     \inoutB(\rprepeat(\rprog'), \tpath) & \triangleq & \outinB(\rprepeat(\rprog'), \rprog) \times \inoutB(\rprog', \tpath)\\
      %     &  & \text{this case will never be matched}
      %     \end{array}
      %   \]
        \end{defn}
        Intuitively, $\inoutB(\rprog, \tpath)$ bounds the execution times of $\tpath$ globally during the execution of $c$.

  % \item The \emph{Reachability-bound} for program points is finally computed as follows.

%       The reachability-bound of each program point $l \in \lvar(c)$, $\psRB(c, l)$
%       \footnote{$l \in \tpath$: the $\in$ notation is abused to denote
%       the program point $l$ is a vertex on this path.}
%       \[ 
%       \psRB(c, l) = 
%         \sum\limits_{\tpath \in \rprog \land l \in \tpath} 
%         \inoutB(\rprog, \tpath)
%       \]
%       % 
% %
\end{enumerate}

\paragraph{Program Points Reachability-bound Computation}
\label{sec:point-psrb}
The \emph{Reachability-bound} for program points is finally computed as follows.
For each program point in a program $c$, $l \in \lvar(c)$,
%  in a program $c$,
its \emph{reachability-bound}, $\psRB(c, l)$ during the execution of $c$ is computed as follows.
%
\begin{defn}[Program Point Reachability-bound Computation]
  \label{def:point_psrb}
  Given a program $c$ with its \emph{Abstract Transition Graph}, $\absG(c)$ and refined program $\rprog$,
  the \emph{reachability bound} of each program point $l \in \lvar(c)$, $\psRB(c, l)$ 
  sums up all the path reachability bounds, $\inoutB(\rprog, \tpath)$ over all simple transition paths $\tpath$ that contains the program point $l$.
  \[ 
    \psRB(c, l) = 
    \sum
    \left\{ \inoutB(\rprog, \tpath) ~\vert~ \tpath \in \rprog \land 
    l \in \tpath \right\}\footnotemark
  \]
  $l \in \tpath$ denotes that the program point $l$ is a vertex on $\tpath$ 
  and $\tpath \in \rprog$ denotes $\tpath$ is a simple transition path in $\absG(c)$.
  \footnotetext{$l \in \tpath$ and $\tpath \in \rprog$, the $\in$ notation is abused to denote
  the program point $l$ is a vertex on this path and $\tpath$ is a simple transition path on $\absG(c)$ respectively.}
 \end{defn}
We prove that $\econfig{\psRB(c, l)}$ is a \emph{Reachability-bound} for every program point $l$ in a program $c$ with proof in \highlight{Appendix~\ref{apdx:psrb-sound}}.
\begin{thm}[Soundness of the Path-sensitive Reachability-bound Estimation]
  \label{thm:pathsensitive_rb_soundness}
  For every program ${c}$ and every label $l$ in this program,
  $\econfig{\psRB(c, l)}$ is a \emph{Reachability-bound} for $l$ in $c$.
  %
  \[
    \begin{array}{l}
      \forall c, c_r \in \cdom, \tpath \in \absG(c), \trace_0 \in \ftdom_0(c),  \trace_r \in \ftdom_0(c_r), \trace \in \tdom, l, l' \in \ldom, \rprog \st 
      \\ \qquad
      \rprog = REFINE(\algrewrite(c))
      \land 
      \rprog = \algrewrite(c_r)
      \land
      \\ \qquad
      \land
      \Big(
      \config{c_r, \trace_0} \rightarrow^* \config{\clabel{\eskip}^{l'}, \trace_0 \tracecat \trace}
      \lor \config{c_r, \trace_0} \uparrow^{\infty} \trace_0 \tracecat \trace 
      \Big)
      \\ \qquad
      \implies \econfig{\psRB(c, l)}(\trace_0) \geq \counter(\trace, l)
    \end{array}.
  \]
  \end{thm}