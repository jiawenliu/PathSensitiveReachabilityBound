
\subsubsection{Loop Bound}
There are two methods for computing the loop bound, $BD(\rprog', c)$ for every sub program $\rprog'$ in $c$'s refined program $\rprog$.
% , specifically loop program $\rprepeat(\rprog')$ in a program $c$'s refined program $\rprog$.
% \begin{enumerate}
%   \item Estimated by $BD(\rprepeat(\rprog'), c) = BOUND(\rprepeat(\rprog'))$ from paper~\cite{GulwaniJK09}, which is precise for simple loop without nested loops but not for nested loops. We are not giving the computation detail in this paper, which can be found in paper~\cite{GulwaniJK09}.
%   \item Estimated by Equation~\ref{eq:absBD} path-insensitively, which is based only on the estimated ranking function from Section~\ref{sec:rank}. 
%   This bound is precise when there is only one path in this loop but not for loops with multiple paths.
%   \item We provide a new computation approach using both the variable invariant estimation idea and the progress invariant idea from~\cite{GulwaniJK09} presented in Definition~\ref{def:loopbound}.
% \end{enumerate}
%
% \paragraph{Ranking Function Based Loop Bound Computation}
% \label{sec:loopbound-rankbased}

Based only on the estimated ranking function from Section~\ref{sec:rank}, we can compute a loose $BD(\rprog', c)$ for each $\rprog'$
using the $\absclr(\absevent, c)$ as follows.
%  and taking the
% minimum value over all $\absevent \in \rprog$.
% We use $\absevent \in \rprog$ to denote $\absevent$ is an edge on path $\rprog$.
\begin{equation}
  \label{eq:absBD}
  BD(\rprog, c) = \min\left\{ \absclr(\absevent, c) \middle\vert \absevent \in \rprog \right\}.\footnotemark
\end{equation}
\footnotetext{We use $\absevent \in \rprog$ to denote that $\absevent$ is an edge on a simple transition path in $\rprog$.}
%
It is accurate only for simple loop, but not for multipath loops and the nested loops.
% \paragraph{Walk through Example.}
% \todo{The walk through example}
For example in Example~\ref{ex:relatedNestedWhileOdd-overview},
% by using this ranking function-based approach, we 
% this equation only computes for each subprogram,
% $BD(\tpath_0) = 1$, $BD(\tpath_5) = 1$, $BD(\rprepeat(\tpath_3)) = n - m$, 
it computes $BD(\rprog_1^1) = n$ and $BD(\rprog_1^2) = n $ for the two interleaving pattern of loop $L_1$.
% The bounds for $\rprog_1^1$ and $\rprog_1^2$ are both $n$ while 
But both of their iteration bounds are expected to be $\lfloor\frac{m}{4}\rfloor$.
The inaccuracy is resulted by the nature of the path-insensitivity in the ranking function invariant estimation in Definition~\ref{def:ranking_bound}. 

\paragraph{New Approach} 
We provide a new computation approach over the refined program.
%  using
%  both the variable invariant estimation idea and the progress invariant idea from~\cite{GulwaniJK09} presented in Definition~\ref{def:loopbound}.
% This new approach uses 
It uses the estimated ranking function invariant and combines with the idea of progress invariant from~\cite{GulwaniJK09}.

We first compute three abstract states for each ranking function in different sub program of a refined program as below.
% Then we these precise abstract state, and estimate the loop bound path sensitively.
\begin{defn}[Rank Abstract States Computation]
  \label{def:alg-absstate}
  Given a program $c$ with its refined program $\rprog_c$ and a sub-program $\rprog$ in $\rprog_c$,
  % where $\rprog \subseteq REFINE(\kw{Rewrite(c)})$, 
  % let $c_r$ be the while program such that $\rprog = \algrewrite(c_r)$,
  we compute three abstract states, $\rfinit(\rprog, c)$, $\rffinal(\rprog, c)$ and $\rfnext(\rprog, c)$  for the ranking functions on this sub program as follows.
 \begin{itemize}
  \item 
  We first compute the initial execution point and continuation execution points of $\rprog$ denoted by
  $\absinit(\rprog)$
  and 
  $\absfinal(\rprog)$ using standard control flow method.
  \item The \emph{Initial State}, 
  $\rfinit(\rprog, c)$ is a set of equations $x = e$, where $e \in \scexpr(c)$ is a
  symbolic expression describing the initial value of $x$ before executing $\rprog$.
  Each $x$ is the ranking function of a simple transition path $\tpath$ in this program. 
  It contains the initial value for every ranking function of the simple transition path $\tpath$ in this program, 
  $\rfinit(\rprog, c) \triangleq $
  {\small
  \[
   \bigcup_{x \in \left\{ \locbound(\absevent, c) | \tpath \in \rprog \land \absevent \in \tpath \right\} }
   \left \{ 
   x = \arg\max_{l_1}\left\{
     \varinvar(y, c) + v ~\middle\vert~ 
     \begin{array}{l} 
       (l_1, x' \leq y + v, l_2) \in \reset(x, c) 
       \\
     \land l_1 \leq \absinit(\rprog, c)
   \end{array}
   \right\}
   \right\}
   \]
 }
 $\rfinit(\tpath, c)$ can also be estimated by $\kw{INIT(c, 0, \absinit(\rprog))}$ in \cite{GulwaniJK09}. 
 %
 \item  The \emph{Final State}, $\rffinal(\rprog, c)$ is a conjunction of boolean expressions, which is the set of minimum values for the ranking functions
 after executing $\rprog$.
  % $\rffinal(\rprog, c) \triangleq $
 % \\
 {\small
\[
  \begin{array}{l} 
   \bigcup\limits_{x \in \left\{ \locbound(\absevent, c) | \tpath \in \rprog \land \absevent \in \tpath \right\} }
   \left \{ 
   x = \min\limits_{ \left\{ l_1 ~|~ l_1 \geq \absfinal(\rprog, c) \right\} }
   \max\left\{
     v ~\middle\vert~ 
     \left( (x = v) \land \bigwedge\limits_{b \in \kw{B}(\rprog, c)} \neg b \right) \neq \efalse
   \right\}
   \right\}
  \end{array}
  \]
    }
    $\kw{B}(\rprog, c)$ is the set of all the boolean constraints in $\rprog$.
 \item The \emph{Next State}, $\rfnext(\rprog, c) \in \scexpr(c)$ 
 computes for the ranking functions on $\rprog$ the amount that each of them is changed after the first execution of $\rprog$ and before the second execution. This quantity is only required for $\tpath$.
 {\small
 \[
   \begin{array}{l}
   \rfnext(\tpath, c) \triangleq 
   \\
   \bigcup\limits_{x \in \left\{ \locbound(\absevent, c) | \absevent \in \tpath \right\}}
   \left\{ x = \begin{array}{l}
  \sum\limits_{\absevent \in \inc(x, c) }
   \left\{ v ~\middle\vert~ \absevent = (l, x' \leq x + v, \_) \land l \in \tpath\right\}
   \\ \qquad 
   + \arg\max\limits_{l' }
      \left\{ \varinvar(y, c) + v ~\middle\vert~ (l, x' \leq y + v, l') \in \reset(x, c) \land l \in \tpath\right\}
      \\ \qquad 
     - \sum\limits_{ \absevent \in \dec(x, c) }\left\{ 
       v ~\middle\vert~ \absevent = (l, x' \leq x - v, \_) \land l \in \tpath 
       \right\}
     \end{array}
   \right\} 
   \end{array}
 \]
  }
% Here we only need to compute the $\rfnext(\tpath)$ for simple 
% because that the recursion is exhausted into the base case, i.e. $\tpath$ when computing $\varGD(\rprog, c)$ as below.
%  \item  The \emph{Variable Gradient Decent}, 
%  $\varGD(\rprog, c)$
%  is a set of equations $x = e$ for the same variables in the $\rfinit(\rprog, c)$.
%  It computes the set of next states for every ranking function of the simple transition path $\tpath$ in $\rprog$,
%  and recursively computes the loop bound, $BD(\rprog, c)$ in the meantime.
%  \\
%  {$\varGD(\rprepeat(\rprog), c) =  BD(\rprog, c)  \times
% {\varGD(\rprog, c)}$}
%  \\
%  $\varGD(\rprog_1;\rprog_2, c) =  \varGD(\rprog_1, c) + \varGD(\rprog_2, c)$
%  \\
%  $\varGD(\tpath, c) =  \min\left\{v  ~|~ x = v \in \rfnext(\tpath, c) \right\}  $  
\end{itemize}
\end{defn}
Now we compute $BD(\rprog, c)$ recursively by interactively computing another quantity, $\varGD(\rprog, c)$ as follows.
\begin{defn}[Loop Bound Computation]
\label{def:loopbound}
Given a program $c$ with its refined program $\rprog$ and a subprogram $\rprog' \in \rprog$,
the \emph{Variable Gradient Decent}, 
 $\varGD(\rprog', c)$ is an invariant of the minimum amount decreased in one execution of $\rprog'$ for the ranking functions in $\rprog$ computed as follows.
%  and recursively computes the loop bound, $BD(\rprog, c)$ in the meantime.
 \\
 {$\varGD(\rprepeat(\rprog_l), c) =  BD(\rprog_l, c)  \times
{\varGD(\rprog_l, c)}$} if $\rprog' = \rprepeat(\rprog_l)$
 \\
 $\varGD(\rprog_1;\rprog_2, c) =  \varGD(\rprog_1, c) + \varGD(\rprog_2, c)$ if $\rprog' = \rprog_1;\rprog_2$
 \\
 $\varGD(\tpath, c) =  \min\left\{v  ~|~ x = v \in \rfnext(\tpath, c) \right\}  $  if $\rprog' = \tpath$

 Then the \emph{loop bound}, $BD(\rprog')$ for $\rprog'$ is computed inductively as follows.
{\small
  \[
    \begin{array}{rcl}
      BD(\tpath, c) & \triangleq & 1 \\
      BD(\rprog_1;\rprog_2, c) & \triangleq & \min \left\{BD(\rprog_1, c), BD(\rprog_2, c) \right\} \\
      BD(\rpchoose{\rprog_1, \ldots, \rprog_m }, c) & \triangleq 
      & \max\left\{ BD(\rprog_1, c), \ldots, BD(\rprog_m, c) \right\} \\
      BD(\rprepeat(\rprog_l), c) & \triangleq 
      &
      \max\limits_{x \in \left\{ \locbound(\absevent, c) | \tpath \in \rprog_l \land \absevent \in \tpath \right\}}
      \big\{ \highlight{\frac{a - b}{\varGD(\rprog_l, c)}}
      \\ & & \qquad
      ~\vert~ x = a \in \rfinit(\rprog_l, c)
      % \\ & & \qquad \qquad \qquad \qquad \qquad \qquad \qquad 
      \land x = b \in \rffinal(\rprog_l, c)
      \big\} 
    \end{array}
  \]
}
\end{defn}
This approach computes a sound loop bound for subprogram in a refined program.
%  below in Lemma~\ref{lem:loopbound_sound} with proof in \highlight{Appendix~\ref{apdx:loopbound-sound}}.
% \begin{lem}[Soundness of Loop Bound]
%   \label{lem:loopbound_sound}
%   For every program $c$ with it refined program $\rprog$,
%   % for every loop $\rprepeat(\rprog')$ inside $\rprog$, 
%   $BD(\rprog, c)$ is a sound upper bound on the iterating times of this program.
% \end{lem}
% \paragraph{Walk through Example.}
% \todo{The walk through example}
% \todo{How it is computed}
In Example~\ref{ex:relatedNestedWhileOdd-overview}, for subprogram $\rprepeat(tpath_3)$, we first compute $\rfinit = \{k = n - m\}$,
and $\rffinal = \{k = 0\}$ and $\rfnext = 1$. So we compute $BD(\rprepeat(\tpath_3)) = n - m$ tighter than $n$ by Eq.~\ref{eq:absBD}.

For the first iteration pattern $\rprog_1^1$ in Figure~\ref{fig:relatedNestedWhileOdd-overview}(b), we also compute 
$\rfinit = \{k = n - m, i = m\}$, $\rffinal = \{k = 0, i = 0\}$ and $\varGD(\rprog_1^1) = 4$. So we compute $BD(\rprog_1^1) = \lfloor \frac{m}{4} \rfloor $ as expected.
% In comparison to the purely ranking function-based approach in Equation~\ref{eq:absBD}, Definition~\ref{def:loopbound}
% also computes more accurate bound. For example, it computes $BD(\rprog_1^1) = \frac{m}{4}$ for $\rprog_1^1$ in Figure~\ref{fig:relatedNestedWhileOdd-overview}(b), 
% Specifically for $\rprog_1^1$ and $\rprog_1^2$, we compute $BD(\rprog_1^1) = \frac{m}{4}$ and $BD(\rprog_1^2) = \frac{m}{4}$ as expected,
% and compute the same bounds for the other sub-programs.
% $BD(\tpath_0) = 1$, $BD(\tpath_5) = 1$, $BD(\rprepeat(\tpath_3)) = n - m$, $BD(\rprog_1^1) = n$, and $BD(\rprog_1^2) = n $.
% The bounds for $\rprog_1^1$ and $\rprog_1^2$ are both $n$ while expected to be $\frac{m}{4}$.
% They are loose because of the nature of the path-insensitivity in the ranking function invariant computation in Definition~\ref{def:ranking_bound}. 

\subsubsection{Path Local Reachability-bound}
We first compute $\kw{enclosed}(\rprog, \tpath)$, which is \textbf{the innermost loop} inside $\rprog$ where $\tpath$ is located. Then by using the loop bound computed by our new approach, we compute the \emph{path local reachability-bound} of
the $\tpath$ in its closest nested loop as follows in Definition~\ref{def:pathlocalrb}.
\begin{defn}[Path Local Reachability-bound Computation]
    \label{def:pathlocalrb}
    Given program $c$ with its refined program $\rprog$ and a simple transition path $\tpath$ in this program, 
    let $l: \rprog_l = \kw{enclosed}(\rprog, \tpath)$ be a sub loop program in $\rprog$,
    then $\tpath$'s \emph{local reachability-bound} $\outinB(\rprog_l, \tpath, c)$ w.r.t. $l: \rprog_l$
    is computed inductively as follows.
    The input $c$ is omitted in the following equations for concise given the context is clear.
    {\small
    \[
    \begin{array}{rcl}
      \outinB(\tpath, \tpath) & \triangleq & 1 \\
      \outinB(\tpath', \tpath) & \triangleq & \highlight{0} \qquad \text{if } \tpath' \neq \tpath\\
      \outinB(\rprog_1;\rprog_2, \tpath) & \triangleq & \outinB(\rprog_1, \tpath) + \outinB(\rprog_2, \tpath) \\
      \outinB(\rpchoose{\rprog_1, \ldots, \rprog_m }, \tpath) & \triangleq 
      & \max\left\{ \outinB(\rprog_1, \tpath), \ldots, \outinB(\rprog_m, \tpath) \right\} \\
      \outinB(\rprepeat(\rprog'), \tpath) & \triangleq 
      & BD(\rprepeat(\rprog'), c) \times \outinB(\rprog', \tpath)
       \\
       \outinB(l: \rprog_l, \tpath) & \triangleq & \outinB(\rprog_l, \tpath) \\
       \outinB(l': \rprog', \tpath) & \triangleq & 0  \qquad \text{if } l': \rprog' \neq \kw{enclosed}(\rprog, \tpath)
    \end{array}
    \]
    }
  \end{defn}
  % \todo{How it is computed}
  The \emph{path local reachability-bound} of the simple transition path $\tpath$ in a refined program $\rprog$ is a sound upper bound of its execution times when executing its enclosed loop $\kw{enclosed}(\rprog, \tpath)$ as in Lemma~\ref{lem:pathlocalrb-sound}.
  For example in the first interleaving pattern $\rprog_1^1$ in Example~\ref{ex:relatedNestedWhileOdd-overview}, $\rprog_1^1$ is the innermost loop program of $\tpath_1$, $\tpath_2$ and $\tpath_4$.
  We compute $\outinB(\rprog_1^1, \tpath_1) = BD(\rprog_1^1, c) \times \outinB(\tpath_1; 4:\rprepeat(\tpath_3); \tpath_2; \tpath_4, \tpath_1)
  = BD(\rprog_1^1, c) \times (1 + 0) = \lfloor \frac{m}{4} \rfloor $ and the same for $\tpath_2$ and $\tpath_4$.
  % We compute the $\frac{m}{4}$ for all the three path $\tpath_1$, $\tpath_2$ and $\tpath_4$ w.r.t. $\rprog_1^1$, as their \emph{path local reachability-bound}.  
  % , with the proof in \highlight{Appendix~\ref{apdx:pathlocalrb-sound}}.
\begin{lem}[Soundness of the Path Local Reachability-bound]
  \label{lem:pathlocalrb-sound}
  For any program $c$ with its refined program $\rprog$ and a simple transition path $\tpath$ in $\rprog$,
  if $l: \rprog_l = \kw{enclosed}(\rprog, \tpath)$ is the closest loop where $\tpath$ is nested in this program,
  then the execution times of $\tpath$ when executing the $\rprog_l$ under initial trace $\trace_l \in \ftdom_0(c_l)$ is bounded by $\econfig{\outinB(\rprog_l, \tpath)}(\trace_0)$ with any initial trace $\trace_0 \in \ftdom_0(c)$.
  {\small
  \[
    \begin{array}{l}
    \forall c, c_l \in \cdom, \tpath \in \absG(c), 
    \trace_l \in \ftdom_0(c_l), \trace_0 \in \ftdom_0(c), \trace \in \tdom, l, l' \in \ldom, \rprog \st 
    \\ \qquad
    \rprog = REFINE(c)
    \land
    l: \rprog_l = \kw{enclosed}(\rprog, \tpath)
    \land 
    \rprog_l = \algrewrite(c_l)
    \\ \qquad
    \land
    \Big(
    \config{c_l, \trace_l} \rightarrow^* \config{\clabel{\eskip}^{l'}, \trace_l \tracecat \trace}
    \lor \config{c_l, \trace_l} \uparrow^{\infty} \trace_l \tracecat \trace 
    \Big)
    \\ \qquad
    \implies
    \econfig{\outinB(\rprog_l, \tpath)}(\trace_0) \geq \lcounter(\trace, \pathl(\tpath)).
    \end{array}
  \]  
  }
\end{lem}


% \paragraph{Example.}
% \todo{Walk through example}
% Now based on the tighter loop bound,
% %  we compute another loop bound for every subprogram in the Example~\ref{ex:relatedNestedWhileOdd-overview} as $BD(\tpath_0) = 1$, $BD(\tpath_5) = 1$, $BD(\rprepeat(\tpath_3)) = n - m $, $BD(\rprog_1^1) = \frac{m}{4} $, and $BD(\rprog_1^2) = \frac{m}{4} $.
% % They are more precise comparing to purely ranking function-based approach in Equation~\ref{eq:absBD}.
% % Using this precise loop bound, 
% we compute local reachability-bound for every transition path w.r.t. its innermost loop as
% $\outinB(\rprog, \tpath_0) = 1$,
% $\outinB(\rprog, \tpath_4) = 1$,
% $\outinB(1: \rprog_1^1, \tpath_1) = \frac{m}{4}$,
% $\outinB(1: \rprog_1^1, \tpath_2) = \frac{m}{4}$,
% $\outinB(1: \rprog_1^1, \tpath_4) = \frac{m}{4}$,
% $\outinB(1: \rprog_1^2, \tpath_1) = \frac{m}{4}$,
% $\outinB(1: \rprog_1^2, \tpath_2) = \frac{m}{4}$,
% $\outinB(1: \rprog_1^2, \tpath_4) = \frac{m}{4}$, and
% $\outinB(4: \rprepeat(\tpath_3), \tpath_3) = n - m$ 

% \todo{necessary?}
\highlight{
Notice here, we can compute a loose $\psRB$ using the $BD$ and $\outinB(\rprog, \tpath)$. By removing the restriction, $l: \rprog_l = \kw{enclosed}(\rprog, \tpath)$ in Definition~\ref{def:pathlocalrb} and using $\rprog$
as the input, $\outinB(\rprog, \tpath)$ computes global \emph{path reachability-bound} loosely.
%  over the global program, $\rprog$ and use $\outinB(\rprog, \tpath)$  as the path global reachability-bound.
% Given we have already computed the path reachability-bound,
Using this loose \emph{path reachability-bound},
we compute the \emph{Reachability-bound} for every program point $l \in \lvar(c)$ by replacing the equation in Definition~\ref{def:point_psrb} with the following one,
\begin{equation}
  \label{eq:psrb-sub}
  \psRB(c, l) = 
  \sum
  \left\{ \outinB(\rprog, \tpath) ~\vert~ \tpath \in \rprog \land 
  l \in \tpath \right\}.
\end{equation}
Using our running program in Example~\ref{ex:relatedNestedWhileOdd-overview},
we compute the path reachability-bound $\outinB(\rprog, \tpath_i)$ for $\tpath_0$ and $\tpath_5$ as $1$,
for paths $\tpath_1$, $\tpath_2$ and $\tpath_4$ as $\frac{m}{4}$ and $\outinB(\rprog, \tpath_3) = \frac{m}{4} \times (n - m)$.
% $\outinB(\rprog, \tpath_0) = 1$,
% $\outinB(\rprog, \tpath_1) = \frac{m}{4}$,
% $\outinB(\rprog, \tpath_2) = \frac{m}{4}$,
% $\outinB(\rprog, \tpath_3) = \frac{m}{4} \times (n - m)$,
% $\outinB(\rprog, \tpath_4) = \frac{m}{4}$, and
% $\outinB(\rprog, \tpath_5) = 1$.
It is loose for the $\tpath_3$ because the Eq.~\ref{eq:psrb-sub} assumes the loop $4$ is reached in every iteration of its outside loop $1$. Naturally, the program point reachability-bound computed using $\outinB(\rprog, \tpath)$ will be loose as well for location $4$ and $5$.
In this sense, we compute the \emph{loop reachability-bound} in the next section for a tighter \emph{reachability-bound}.
% \todo{Walk through example with a loose path and point reachability bound}
}