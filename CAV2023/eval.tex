\emph{Set up} We implemented a prototype {\THESYSTEM} that takes a labeled command as input 
and outputs the reachability-bound on each program point.
This implementation consists of the 
program abstraction in OCaml and the program refinement, ranking function estimation, and the path-sensitive reachability-bound algorithm in Python.
We evaluate it on 20 self-adopted programs from the literatures and 270 programs extracted from four benchmarks. 
Including 110{\tt .c} programs from 7 benchmarks~\cite{BenchmarkLoops}\footnote{ABC: 15, C4B: 15, KoAT: 3, Loopus: 10, Rank10: 3, SPEED: 27, WTC: 37} and 37 challenging{\tt .c} programs 
from the \hyperlink{https://forsyte.at/static/people/sinn/loopusJAR/index.html}{LoopusJAR}~\cite{BenchmarkLoops,SinnZV17},
37{\tt .java} programs from~\hyperlink{https://zenodo.org/record/5140586\#.Y5pBoC-B1QI}{Tianhan}\cite{BenchmarkTianhan,LuCT21}
and 118{\tt .c} programs from~\hyperlink{https://github.com/icra-team/icra}{Icra}~\cite{BenchmarkIcra,KincaidBCR19,CyphertBKR19}.
We translated these programs into our language model.
As the comparison, we also report the results of four bound analysis tools, 
\hyperlink{https://forsyte.at/software/loopus/}{LoopusJAR}~\cite{SinnZV17},
\hyperlink{https://github.com/aeflores/CoFloCo/tree/master/src}{CoFloCo}~\cite{ToolCofloco,Montoya17,Flores-Montoya16,Flores-MontoyaH14}
and \hyperlink{https://zenodo.org/record/5140586\#.Y5pBoC-B1QI}{Tianhan}~\cite{BenchmarkTianhan}
and self-implemented SPEED based on~\cite{GulwaniJK09}.
% \\

We aim to answer, is our prototype able to compute more precise reachability-bound for different program points when comparing with the worst-case program
complexity analysis tools? If so, can we also have better overall complexity estimation?
%  based on the precise reachability-bound?
Tab.~\ref{tb:accuracy-eval} shows our evaluation results.
%  including the theoretical bounds and empirical results.
\\
\emph{Effectiveness}
\newcommand{\pointnum}{\kw{\# l}}
The $2^{nd}$ and $3^{rd}$ columns are the theoretical worst-case bound on the overall complexity and the number of programs that have this complexity.
To show the effectiveness, 
we present in column $4^{th}$ our results for different locations in different loop paths. 
Though having the same overall complexity, the results shows that different point points have significantly different $\psRB$.
In each sub-column, we additionally show the number of points, $\pointnum$ that have the same $\psRB$ under the same worst complexity.
For almost all the multipath loops, our tool computes precise \emph{reachability-bound}s on locations in different paths.
%  that have significantly different \emph{reachability-bound}s.
Even for the unbounded loops, we can still compute finite \emph{reachability-bound}s on certain program points which are not involved with the unbounded loop paths.
While none of the existing tools can compute reasonable bounds for these programs.
\\
\emph{Accuracy} 
The column $5^{th}$ shows the empirical bounds computed by us and the other tools for comparison in terms of the overall complexity. Each sub-column shows the $\#$ of programs that is computed to have this worst complexity.
In terms of the worst complexity estimation, we do slightly worse but still comparable to existing tools. However, we are not aiming to compute the worst complexity.
The last column shows our overall complexity estimation based on precise {\THESYSTEM}.
It is the sum of each $\psRB \times \pointnum$.
By doing this summation, we identify a lot of loop patterns with large worst complexity but only $O(1)$ reachability-bound on points inside the loop.
For example in the Icra benchmark with $O(n)$ worst complexity,
there are almost $\frac{1}{3}$ of the program points inside the loop is visited only $O(1)$ times.
This gives us the significant improvement in estimating the overall complexity comparing to the worst case analysis, which simply multiplying the worst bound with $\sum\pointnum$.
% V.S. sum of the worst complexity $\times \pointnum$  by other tools.
This improvement can be applied to many places, such as saving the resources allocation,
precisely compute information leakage, e.t.c.
\\
\emph{Performance}
Our tool suffers the efficiency problem because of the implementation and the possible non-terminating in program refining and the ranking function estimating.
The performance detail is in Appendices~\ref{apdx:eval-performance}.
 \begin{table}[ht]
 \vspace{-1cm}
 \caption{The Accuracy Evaluation of {\THESYSTEM}}
 \label{tb:accuracy-eval}
 \centering
 {\scriptsize
 \begin{tabular}{ >{\scriptsize}c | >{\scriptsize}c | >{\scriptsize}c | >{\scriptsize}c | c | c | c | c | c | c }
 {Benchmark} & {Theory} & & {\THESYSTEM} for points ($\pointnum$) & \multicolumn{5}{c|}{ worst bound ($\# p$)} & Summed\\
 \cline{4-10}
 Suit & Worst & \# & $1$ | $n$ | $n^2$ | $n^3$ | $n^4$ | $\infty$ & {\tiny \THESYSTEM} & {\tiny \cite{BenchmarkLoops}} & {\tiny \cite{ToolCofloco}} & {\tiny \cite{GulwaniJK09}} & {\tiny \cite{BenchmarkTianhan}} & {\THESYSTEM} \\
 \hline
 \multirow{6}{*}{Loopus} 
 & $O(1)$ & 4 &  32 | 0 | 0 | 0 | 0 | 0 & 1 & 2 & 3 & 2 & 1 & 32 \\
 \cline{2-10}
 & $O(n)$ & 59 & 112 | 261 | 0 | 0 | 0 | 0 & 48 & 51 & 45 & 46 & 40 & $112 + 261n$ \\
 \cline{2-10}
 & $O(n^2)$ & 31 & 70 | 191 | 153 | 0 | 0 | 0  & 37 & 29 & 34 & 37 & 49 & $70 + 191n + 153n^2$ \\
 \cline{2-10}
 & $O(n\log(n))$ & 6 & 0 | 0 | 0 | 0 | 0 | 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
 \cline{2-10}
 & $O(n^3)$ & 2 & 6 | 16 | 13 | 13 | 0 | 0 & 4 & 1 & 2 & 5 & 7 & $6 + 16n + 13n^2 + 13n^3$\\
 \cline{2-10}
 & $O(n^{4})$ & 3 & 4 | 9 | 9 | 12 | 11 | 0 & 4 & 5 & 3 & 5 & 5 & $4 + 9n + 9n^2 + 12n^3 + 11n^4$\\
 \hline \hline
 \multirow{5}{*}{ Challenge } 
 & $O(1)$ & 1 & 0 | 0 | 0 | 0 | 0 | 0 & 0 & 1 & 0 & 0 & 0 & 0\\
 \cline{2-10}
& $O(n)$ & 13 & 49 | 105 | 0 | 0 | 0 | 0 & 12 & 13 & 14 & 14 & 11 & $49 + 105n$\\
 \cline{2-10}
 & $O(n^2)$ & 4 & 4 | 13 | 15 | 0 | 0 | 0 & 3 & 2 & 5 & 2 & 6 & $4 + 13n + 15n^2$\\
 \cline{2-10}
 & $O(n^3)$ & 4 & 2 | 7 | 10 | 4 | 0 | 0 & 2 & 1 & 2 & 2 & 3 & $2 + 7n + 10n^2 + 4n^3 $\\
 \cline{2-10}
 & $O(n^{4})$ & 1 & 1 | 3 | 6 | 8 | 2 | 0 & 1 & 1 & 1 & 1 & 0 & $1+3n+6n^2+8n^3+2n^4$\\
 \hline \hline
 \multirow{6}{*}{Icra} 
 & $O(1)$ & 4 & 93 | 0 | 0 | 0 | 0 | 0 & 1 & 3 & 2 & 2 & 0 & 93\\
 \cline{2-10}
 & $O(\log(n))$ & 2 & 0 | 0 | 0 | 0 | 0 | 0 & 0 & 0 & 0 & 0 & 0 & 0\\
 \cline{2-10}
 & $O(n)$ & 79 & 267 | 698 | 0 | 0 | 0 | 0 & 78 & 80 & 82 & 78 & 77 & $267 + 698n^2$\\
 \cline{2-10}
 & $O(n^2)$ & 12 & 26 | 110 | 26 | 0 | 0 | 0 & 18 & 14 & 11 & 16 & 17 & $26+110n+26n^2$\\
 \cline{2-10}
 & $O(n^3)$ & 1 & 1 | 3 | 3 | 2 | 0 | 0 & 1 & 1 & 4 & 2 & 4 & $1+3n+3n^2+2n^3$\\
 \cline{2-10}
 & unbounded & 20 &  50 | 0 | 0 | 0 | 0 | 245 & 9 & 0 & 0 & 0 & 0 & $50 + 245\infty$ \\
 \hline \hline
 \multirow{2}{*}{Tianhan} 
 & $O(n)$ & 34 & 68 | 120 | 0 | 0 | 0 | 0 & 34 & 35 & 35 & 35 & 35 & $68+120n$\\
 \cline{2-10}
 & $O(n^2)$ & 3 & 4 | 8 | 4 | 0 | 0 | 0 & 3 & 2 & 2 & 2 & 2 & $4+8n+4n^2$\\
 \hline
 \end{tabular}
 }
 \vspace{-1cm}
 \end{table}
