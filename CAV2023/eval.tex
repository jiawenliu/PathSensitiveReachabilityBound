\emph{Set up} We implemented a prototype {\THESYSTEM} that takes a labeled command as input 
and outputs the reachability-bound on each program point.
This implementation consists of the 
program abstraction in OCaml and the program refinement, ranking function estimation, and the path-sensitive reachability-bound algorithm in Python.
We evaluate it on 20 self-adopted programs from the literatures and 270 programs extracted from four benchmarks. 
Including 75{\tt .c} programs from 7 benchmarks~\cite{BenchmarkLoops}\footnote{ABC: 15, C4B: 15, KoAT: 3, Loopus: 10, Rank10: 3, SPEED: 27, WTC: 37} and 37 challenging{\tt .c} programs 
from the \hyperlink{https://forsyte.at/static/people/sinn/loopusJAR/index.html}{LoopusJAR}~\cite{BenchmarkLoops,SinnZV17},
37{\tt .java} programs from~\hyperlink{https://zenodo.org/record/5140586\#.Y5pBoC-B1QI}{Tianhan}\cite{BenchmarkTianhan,LuCT21}
and 118{\tt .c} programs from~\hyperlink{https://github.com/icra-team/icra}{Icra}~\cite{BenchmarkIcra,KincaidBCR19,CyphertBKR19}.
We translated these programs into our language model.
As the comparison, we also report the results of four bound analysis tools, 
\hyperlink{https://forsyte.at/software/loopus/}{LoopusJAR}~\cite{SinnZV17},
\hyperlink{https://github.com/aeflores/CoFloCo/tree/master/src}{CoFloCo}~\cite{ToolCofloco,Montoya17,Flores-Montoya16,Flores-MontoyaH14}
and \hyperlink{https://zenodo.org/record/5140586\#.Y5pBoC-B1QI}{Tianhan}~\cite{BenchmarkTianhan}
and self-implemented SPEED based on~\cite{GulwaniJK09}.
% \\

We aim to answer, is our prototype able to compute more precise reachability-bound for different program points when comparing with the worst-case program
complexity analysis tools? If so, can we also have better overall complexity estimation?
%  based on the precise reachability-bound?
Tab.~\ref{tb:accuracy-eval} shows our evaluation results.
%  including the theoretical bounds and empirical results.
\\
\emph{Effectiveness}
\newcommand{\pointnum}{\kw{\# l}}
The $2^{nd}$ and $3^{rd}$ columns are the theoretical worst-case bound on the overall complexity and the number of programs that have this complexity.
To show the effectiveness, 
we present in column $4^{th}$ our results for different locations in different loop paths. 
Though having the same overall complexity, the results shows that different point points have significantly different $\psRB$.
In each sub-column, we additionally show the number of points, $\pointnum$ that have the same $\psRB$ under the same worst complexity.
For almost all the multipath loops, our tool computes precise \emph{reachability-bound}s on locations in different paths.
%  that have significantly different \emph{reachability-bound}s.
Even for the unbounded loops, we can still compute finite \emph{reachability-bound}s on certain program points which are not involved with the unbounded loop paths.
While none of the existing tools can compute reasonable bounds for these programs.
\\
\emph{Accuracy} 
The column $5^{th}$ shows the empirical bounds computed by us and the other tools for comparison in terms of the overall complexity. Each sub-column shows the $\#$ of programs that is computed to have this worst complexity.
In terms of the worst complexity estimation, we do slightly worse but still comparable to existing tools. However, we are not aiming to compute the worst complexity.
The last column shows our overall complexity estimation based on precise {\THESYSTEM}.
It is the sum of each $\psRB \times \pointnum$, V.S. sum of the worst complexity $\times \pointnum$  by other tools.
The results show a significant improvement, which can be used to save resources allocation,
precisely compute information leakage, e.t.c.
\\
\emph{Performance}
Our tool suffers the efficiency problem because of the implementation and the possible non-terminating in program refining and the ranking function estimating.
The performance detail is in Appendices~\ref{apdx:eval-performance}.
 \begin{table}[ht]
 \vspace{-1cm}
 \caption{The Accuracy Evaluation of {\THESYSTEM}}
 \label{tb:accuracy-eval}
 \centering
 {\scriptsize
 \begin{tabular}{ >{\scriptsize}c | >{\scriptsize}c | >{\scriptsize}c | >{\tiny}c | c | c | c | c | c | c }
 {Benchmark} & {Theory} & & {\THESYSTEM} for points ($\pointnum$) & \multicolumn{5}{c|}{{\tiny worst bound computed for program}} & Summed\\
 \cline{5-10}
 Suit & Worst & \# & $1$ | $n$ | $n^2$ | $n^3$ | $n^4$ | $\infty$ & {\tiny \THESYSTEM} & {\tiny Loopus} & {\tiny CoFloCo} & {\tiny SPEED} & {\tiny Tianhan} & {\THESYSTEM} | worst\\
 % & {\tiny Icra} \\
 \hline
 \multirow{6}{*}{Loopus} 
 & $O(1)$ & 4 &  - | 0 | 0 | 0 | 0 | 0 & 4 & 2 & 3 & 2 & 1 \\
 \cline{2-10}
 & $O(n)$ & 59 & - | - | 0 | 0 | 0 | 0 & 48 & 51 & 45 & 46 & 40 \\
 \cline{2-10}
 & $O(n^2)$ & 31 & - | - | - | 0 | 0 | 0  & 37 & 29 & 34 & 37 & 49 \\
 \cline{2-10}
 & $O(n\log(n))$ & 6 & 0 | 0 | 0 | 0 | 0 | 0 & 0 & 0 & 0 & 0 & 0 \\
 \cline{2-10}
 & $O(n^3)$ & 2 & 0 | 0 | 0 | - | 0 | 0 & 4 & 1 & 2 & 5 & 7 \\
 \cline{2-10}
 & $O(n^{4})$ & 3 & 0 | 0 | 0 | 0 | - | 0 & 4 & 5 & 3 & 5 & 5 \\
 \hline \hline
 \multirow{5}{*}{ Challenge } 
 & $O(1)$ & 1 & 0 | 0 | 0 | 0 | 0 | 0 & 0 & 3 & 1 & 0 & 0 \\
 \cline{2-10}
& $O(n)$ & 13 & - | - | 0 | 0 | 0 | 0 & 14 & 17 & 17 & 15 & 11 \\
 \cline{2-10}
 & $O(n^2)$ & 4 & 0 | - | - | 0 | 0 | 0 & 3 & 14 & 15 & 16 & 21 \\
 \cline{2-10}
 & $O(n^3)$ & 4 & - | - | 0 | - | 0 | 0 & 2 & 1 & 0 & 2 & 2 \\
 \cline{2-10}
 & $O(n^{4})$ & 1 & 0 | 0 | 0 | - | - | 0 & 1 & 5 & 3 & 5 & 5 \\
 \hline \hline
 \multirow{6}{*}{Icra} 
 & $O(1)$ & 4 & - | 0 | 0 | 0 | 0 | 0 & 1 & 3 & 2 & 2 & 0 \\
 \cline{2-10}
 & $O(\log(n))$ & 2 & 0 | 0 | 0 | 0 | 0 | 0 & 0 & 0 & 0 & 0 & 0 \\
 \cline{2-10}
 & $O(n)$ & 79 & - | - | 0 | 0 | 0 | 0 & 78 & 80 & 82 & 78 & 77 & \\
 \cline{2-10}
 & $O(n^2)$ & 12 & - | - | - | 0 | 0 | 0 & 18 & 14 & 11 & 16 & 17 \\
 \cline{2-10}
 & $O(n^3)$ & 1 & 0 | 0 | 0 | - | 0 | 0 & 1 & 1 & 4 & 2 & 4 \\
 \cline{2-10}
 & unbounded & 20 &  - | - | - | 0 | 0 | - & 9 & 0 & 0 & 0 & 0 \\
 \hline \hline
 \multirow{2}{*}{Tianhan} 
 & $O(n)$ & 34 & 0 | - | 0 | 0 | 0 | 0 & 34 & 35 & 35 & 35 & 35 \\
 \cline{2-10}
 & $O(n^2)$ & 3 & 0 | 0 | - | 0 | 0 | 0 & 3 & 2 & 2 & 2 & 2 \\
 \hline
 \end{tabular}
 }
 \vspace{-1cm}
 \end{table}
