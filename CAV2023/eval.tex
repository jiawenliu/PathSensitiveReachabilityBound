\emph{Set up} We implemented a prototype {\THESYSTEM} that takes a labeled command as input 
and outputs the reachability-bound on each program point.
This implementation consists of the 
program abstraction in OCaml and the program refinement, ranking function estimation, and the path-sensitive reachability-bound algorithm in Python.
We evaluate it on 20 self-adopted programs from the literature and 270 programs extracted from different set of benchmarks. 
It includes 110 representative{\tt .c} programs from the example sets of 7 tools\footnote{ABC: 15, C4B: 15, KoAT: 3, Loopus: 10, Rank10: 3, SPEED: 27, WTC: 37}, 37 challenging{\tt .c} programs 
from the \hyperlink{https://forsyte.at/static/people/sinn/loopusJAR/index.html}{LoopusJAR}~\cite{BenchmarkLoops,SinnZV17},
37{\tt .java} programs from~\hyperlink{https://zenodo.org/record/5140586\#.Y5pBoC-B1QI}{Tianhan}\cite{BenchmarkTianhan,LuCT21}
and 118{\tt .c} programs from~\hyperlink{https://github.com/icra-team/icra}{Icra}~\cite{BenchmarkIcra,KincaidBCR19,CyphertBKR19}.
We translate these programs into our language model.
For comparison, we also report the results of four bound analysis tools, 
\hyperlink{https://forsyte.at/software/loopus/}{LoopusJAR}~\cite{SinnZV17},
\hyperlink{https://github.com/aeflores/CoFloCo/tree/master/src}{CoFloCo}~\cite{ToolCofloco,Montoya17,Flores-Montoya16,Flores-MontoyaH14},
% and \hyperlink{https://zenodo.org/record/5140586\#.Y5pBoC-B1QI}{Tianhan}
~\cite{BenchmarkTianhan}
and self-implemented SPEED~\cite{GulwaniJK09}.
% \\

When comparing with the worst-case program
complexity analysis tools, we aim to answer, is our prototype able to compute precise reachability-bound for different program points (\emph{Effectiveness})? If so, can we also have better overall complexity estimation (\emph{Accuracy})?
%  based on the precise reachability-bound?
Tab.~\ref{tb:accuracy-eval} shows our evaluation results.
%  including the theoretical bounds and empirical results.
\\
\emph{Effectiveness}
\newcommand{\pointnum}{\kw{\# l}}
The $2^{nd}$ and $3^{rd}$ columns are the theoretical worst-case complexity and the number of programs that have this complexity.
To show the effectiveness, 
we present in column $4^{th}$ our estimated ``{reachability-bound ($\pointnum$)}'' for different program points. 
Though having the same worst-case complexity, the results show that different points have significantly different reachability-bounds.
In each sub-column, we additionally show the number of points, $\pointnum$ with certain reachability-bound under the same worst complexity.
For almost all the multipath loops, our tool computes precise \emph{reachability-bound}s on locations in different paths.
%  that have significantly different \emph{reachability-bound}s.
Even for the unbounded loops, we can still compute finite \emph{reachability-bound}s on certain program points which are not involved with the unbounded loop paths.
While none of the existing tools can compute reasonable bounds for these programs.
We also identify a number of loop patterns with large worst-case complexity but only reachability-bounds of $O(1)$ on points inside the loop.
For example in the programs  with $O(n)$ worst complexity from Icra benchmark,
almost $\frac{1}{3}$ of the program points inside the loops are evaluated only $1$ time.
\\
\emph{Accuracy} Since the existing tools can only compute the worst-case bounds,
we show in column $5^{th}$ the ``worst bound ($\# p$)'' computed by us and the other tools for comparison. Each sub-column shows the $\#$ of programs that are computed to have this worst complexity.
Although we are not aiming to compute the worst complexity, our results are still comparable to existing tools.
The last column shows the ``overall complexity'' estimation.
The $1^{st}$ sub-column is the sum of product reachability-bound and $\pointnum$ by {\THESYSTEM}.
For comparison, we show the best worst bound by other tools $\times \sum\pointnum$ in the $2^{nd}$ sub-column. It shows that we can compute tighter overall complexity than the best.
% It can be applied to many places, such as saving the resources' allocation,
% computing precise information leakage, etc.
%
 \begin{table}[ht]
 \vspace{-1cm}
 \caption{The Effectiveness And Accuracy Evaluation of {\THESYSTEM}}
 \label{tb:accuracy-eval}
 \centering
 {\scriptsize
 \begin{tabular}{ >{\scriptsize}c | >{\scriptsize}c | >{\scriptsize}c | >{\scriptsize}c | c | c | c | c | c | c | c | c | c | c | c | c | c |}
 {Bench-} & {Theory} &  \# & \multicolumn{6}{c|}{reachability-bound ($\pointnum$)} & \multicolumn{5}{c|}{worst bound ($\# p$)} & \multicolumn{2}{c|}{overall complexity}\\
 \cline{4-16}
 -marks & Worst & p & $1$ & $n$ & $n^2$ & $n^3$ & $n^4$ & $\infty$ & {\tiny \THESYSTEM} & {\tiny \cite{BenchmarkLoops}} & {\tiny \cite{ToolCofloco}} & {\tiny \cite{GulwaniJK09}} & {\tiny \cite{BenchmarkTianhan}} & {\THESYSTEM} & worst \\
 \hline
 & $O(1)$ & 4 &  32 & 0 & 0 & 0 & 0 & 0 & 1 & 2 & 3 & 2 & 1 & 32 & -\\
 \cline{2-2}
 & $O(n)$ & 59 & 112 & 261 & 0 & 0 & 0 & 0 & 48 & 51 & 45 & 46 & 40 & $112 + 261n$  & $373n$\\
 \cline{2-2}
 Represe-
 & $O(n^2)$ & 31 & 70 & 191 & 153 & 0 & 0 & 0  & 37 & 29 & 34 & 37 & 49 & $70 + 191n + 153n^2$ & $ 414n^2 $ \\
 \cline{2-2}
 -ntatives
 & $n\log(n)$ & 6 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
 \cline{2-2}
 & $O(n^3)$ & 2 & 6 & 16 & 13 & 13 & 0 & 0 & 4 & 3 & 2 & 5 & 7 & $6 + 16n + 13n^2 + 13n^3$ & $48 n^3$\\
 \cline{2-2}
 & $O(n^{4})$ & 3 & 4 & 9 & 9 & 12 & 11 & 0 & 4 & 4 & 3 & 5 & 5 & $4 + 9n + 9n^2 + 12n^3 + 11n^4$ & $45n^4$\\
 \hline \hline
 \multirow{5}{*}{Challenge} 
 & $O(1)$ & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & - \\
 \cline{2-2}
& $O(n)$ & 13 & 49 & 105 & 0 & 0 & 0 & 0 & 12 & 13 & 14 & 14 & 11 & $49 + 105n$ & $162n$\\
 \cline{2-2}
 & $O(n^2)$ & 4 & 4 & 13 & 15 & 0 & 0 & 0 & 3 & 2 & 5 & 2 & 6 & $4 + 13n + 15n^2$ & $32n^2$ \\
 \cline{2-2}
 & $O(n^3)$ & 4 & 2 & 7 & 10 & 4 & 0 & 0 & 2 & 1 & 2 & 2 & 3 & $2 + 7n + 10n^2 + 4n^3 $ & $23n^3$\\
 \cline{2-2}
 & $O(n^{4})$ & 1 & 1 & 3 & 6 & 8 & 2 & 0 & 1 & 1 & 1 & 1 & 0 & $1+3n+6n^2+8n^3+2n^4$ & $20n^4$\\
 \hline \hline
 \multirow{6}{*}{Icra} 
 & $O(1)$ & 4 & 93 & 0 & 0 & 0 & 0 & 0 & 1 & 3 & 2 & 2 & 0 & 93 & - \\
 \cline{2-2}
 & $\log(n)$ & 2 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
 \cline{2-2}
 & $O(n)$ & 79 & 267 & 698 & 0 & 0 & 0 & 0 & 78 & 80 & 82 & 78 & 77 & $267 + 698n$ & $ 965n $\\
 \cline{2-2}
 & $O(n^2)$ & 12 & 26 & 110 & 26 & 0 & 0 & 0 & 18 & 14 & 11 & 16 & 17 & $26+110n+26n^2$ & $162n^2$\\
 \cline{2-2}
 & $O(n^3)$ & 1 & 1 & 3 & 3 & 2 & 0 & 0 & 1 & 1 & 4 & 2 & 4 & $1+3n+3n^2+2n^3$ & $9n^3$\\
 \cline{2-2}
 & $\infty$ & 20 &  50 & 0 & 0 & 0 & 0 & 245 & 9 & 0 & 0 & 0 & 0 & $50$ & $ \infty$\\
 \hline \hline
 \multirow{2}{*}{Tianhan} 
 & $O(n)$ & 34 & 68 & 120 & 0 & 0 & 0 & 0 & 34 & 35 & 35 & 35 & 35 & $68+120n$ & $188n$\\
 \cline{2-2}
 & $O(n^2)$ & 3 & 4 & 8 & 4 & 0 & 0 & 0 & 3 & 2 & 2 & 2 & 2 & $4+8n+4n^2$ & $16n^2$ \\
 \hline
 \end{tabular}
 }
 \vspace{-0.8cm}
 \end{table}
%
\\
\emph{Performance}
The performance evaluation is in Table~\ref{tb:performance-eval}.
The columns from $2$ to $5$ are $\# $ of the programs, with multipath loops, nested loops, and bounded loops respectively.
The $6$ to $8$ columns are our success rate, the \# of programs we failed, and time outs. The last column is the total runtime w.r.t. the programs that we successfully computed bounds.
We are not doing well in terms of efficiency because of the possible non-terminating in program refining and the ranking function estimating.
Our prototype consists of the implementations in OCaml and Python.
The inter-procedures calls also reduce the efficiency.
%
%
\begin{table}[H]
 \vspace{-1cm}
    \caption{The Performance Evaluation of {\THESYSTEM}}
    \label{tb:performance-eval}
    \centering
        {\footnotesize
        \begin{tabular}{ >{\small}c | c | c | c | c | c | c | c | c | c }
            \multirow{2}{*}{Benchmarks} & \multirow{2}{*}{\# P}  & {M.P.L} & Nested  & {Bounded} & {Success} & \multirow{2}{*}{Failed} & Time  & Total\\
             &  & \# & Loop \# & \# & Rate &  & Outs &   Runtime \\
            \hline
                {Representatives} & {110}  & 53  & 52  & 107 & 85.5\% & 4 & 12 & 7min42sec \\
                \hline
                Challenges & 23  & 20 & 20 & {20} & {78.2\%}  & 1 & 4 & {12min39sec} \\
                \hline
                {Icra} & 118 & 111 & 21 & 98 & 90.7\% & 1 & 10 & {4min48sec} \\
                \hline
                Tianhan & 37 & 2 & 3 & 37 & 100.0\% & 0 & 0 & 1min03sec \\
                \hline
            \end{tabular}    
        }
 \vspace{-0.5cm}
    \end{table}