\emph{Set up} We implemented a prototype {\THESYSTEM} that takes a labeled command as input 
and outputs the reachability-bound on each program point.
This implementation consists of the 
program abstraction in OCaml and the program refinement, ranking function estimation, and the path-sensitive reachability-bound algorithm in Python.
We evaluate it on 20 self-adopted programs from the literatures and 270 programs extracted from four benchmarks. 
Including 75{\tt .c} programs from 7 benchmarks~\cite{BenchmarkLoops}\footnote{ABC: 15, C4B: 15, KoAT: 3, Loopus: 10, Rank10: 3, SPEED: 27, WTC: 37} and 37 challenging{\tt .c} programs 
from the \hyperlink{https://forsyte.at/static/people/sinn/loopusJAR/index.html}{LoopusJAR}~\cite{BenchmarkLoops,SinnZV17},
37{\tt .java} programs from~\hyperlink{https://zenodo.org/record/5140586\#.Y5pBoC-B1QI}{Tianhan}\cite{BenchmarkTianhan,LuCT21}
and 118{\tt .c} programs from~\hyperlink{https://github.com/icra-team/icra}{Icra}~\cite{BenchmarkIcra,KincaidBCR19,CyphertBKR19}.
We translated these programs into our language model.
As the comparison, we also report the results of four bound analysis tools, 
\hyperlink{https://forsyte.at/software/loopus/}{LoopusJAR}~\cite{SinnZV17},
\hyperlink{https://github.com/aeflores/CoFloCo/tree/master/src}{CoFloCo}~\cite{ToolCofloco,Montoya17,Flores-Montoya16,Flores-MontoyaH14}
and \hyperlink{https://zenodo.org/record/5140586\#.Y5pBoC-B1QI}{Tianhan}~\cite{BenchmarkTianhan}
and self-implemented SPEED based on~\cite{GulwaniJK09}.
\\
\emph{Effectiveness} We aim to answer, is our prototype able to compute more precise reachability-bound for different program points when comparing with the worst-case program
complexity analysis tools?
Tab.~\ref{tb:accuracy-eval} shows the evaluation results including the theoretical bounds and empirical results.
% on different path locations.
The $2^{nd}$ and $3^{rd}$ columns are the theoretical worst-case bound on the overall complexity and the number of programs that have this complexity. The column $5^{th}-9^{th}$ shows the empirical bounds computed by us and the other tools for comparison in terms of the overall complexity.
To show the effectiveness, 
we present in column $4^{th}$ our results for different locations in different loop paths. for almost all the multipath loops, our tool computes precise bounds on different path locations that have significantly different \emph{reachability-bound}s.
Even for the unbounded loops, we can still compute finite \emph{reachability-bound}s on certain program points which are not involved with the unbounded loop paths.
While none of the existing tools can compute reasonable bounds for these programs.
For the challenging loops without multipath, we do slightly worse but still comparable to existing tools.
Our tool suffers the efficiency problem because of the prototype implementation and the possible non-terminating in program refining and the ranking function estimating.
The detail performance evaluation is in Appendices~\ref{apdx:eval-performance}.
% Tab.~\ref{tb:performance-eval}.
% \begin{table}[H]
% \caption{The Performance Evaluation of {\THESYSTEM}}
% \label{tb:performance-eval}
% \centering
% {\footnotesize
% \begin{tabular}{ >{\small}c | c | c | c | c | c | c | c | c | c }
% \multirow{2}{*}{Benchmark} & \multirow{2}{*}{\# P} & \multirow{2}{*}{M.P.L \#} & Nested & \multirow{2}{*}{Bounded} & {Success} & \multirow{2}{*}{Failed} & Time & Total\\
% & & & Loop \# & & Rate & & Outs & Runtime \\
% \hline
% {Loopus} & {110} & 53 & 52 & 98 & 89.1\% & 11 & 7 & 7min42sec \\
% \hline
% Loopus-C & 23 & 20 & 20 & {20} & {86\%} & 2 & 3 & {12min39sec} \\
% \hline
% \todo{Icra} & 72 & 72 & 6 & {55} + \todo{-} & + \todo{-} & 0 & 0 & \todo{1min58sec} \\
% \hline
% Tianhan & 37 & 2 & 3 & 37 & 100.0\% & 1 & 0 & 1min03sec \\
% \hline
% \end{tabular}
% }
% \end{table}
 \begin{table}[ht]
 \vspace{-1cm}
 \caption{The Accuracy Evaluation of {\THESYSTEM}}
 \label{tb:accuracy-eval}
 \centering
 {\footnotesize
 \begin{tabular}{ >{\scriptsize}c | >{\scriptsize}c | >{\footnotesize}c | >{\scriptsize}c | c | c | c | c | c | c }
 {Benchmark} & {Theory} & & {\THESYSTEM} & \multicolumn{5}{c}{Computed} & \\
 \cline{5-10}
 Suit & Worst & \# & on Loop Paths & {\tiny \THESYSTEM} & {\tiny Loopus} & {\tiny CoFloCo} & {\tiny SPEED} & {\tiny Tianhan} & \\
 % & {\tiny Icra} \\
 \hline
 \multirow{6}{*}{Loopus} 
 & $O(1)$ & 4 & $O(1)$ & 4 & 2 & 3 & 2 & 1 \\
 \cline{2-9}
 & $O(n)$ & 59 & $O(1), O(n)$ & 48 & 51 & 45 & 46 & 40 \\
 \cline{2-9}
 & $O(n^2)$ & 31 & $O(1), O(n), O(n^2)$ & 37 & 29 & 34 & 37 & 49 \\
 \cline{2-9}
 & $O(n\log(n))$ & 6 & $-$ & 0 & 0 & 0 & 0 & 0 \\
 \cline{2-9}
 & $O(n^3)$ & 2 & $O(n^3)$ & 4 & 1 & 2 & 5 & 7 \\
 \cline{2-9}
 & $O(n^{4})$ & 3 & $O(n^4)$ & 4 & 5 & 3 & 5 & 5 \\
 \hline \hline
 \multirow{5}{*}{ Challenge } 
 & $O(1)$ & 1 & $-$ & 0 & 3 & 1 & 0 & 0 \\
 \cline{2-9}
& $O(n)$ & 13 & $O(1), O(n)$ & 14 & 17 & 17 & 15 & 11 \\
 \cline{2-9}
 & $O(n^2)$ & 4 &$O(n), O(n^2)$ & 3 & 14 & 15 & 16 & 21 \\
 \cline{2-9}
 & $O(n^3)$ & 4 & $O(1), O(n), O(n^3)$ & 2 & 1 & 0 & 2 & 2 \\
 \cline{2-9}
 & $O(n^{4})$ & 1 & $O(n^4), O(n^3)$ & 1 & 5 & 3 & 5 & 5 \\
 \hline \hline
 \multirow{6}{*}{Icra} 
 & $O(1)$ & 4 & $O(1)$ & 1 & 3 & 2 & 2 & 0 \\
 \cline{2-9}
 & $O(\log(n))$ & 2 & $-$ & 0 & 0 & 0 & 0 & 0 \\
 \cline{2-9}
 & $O(n)$ & 79 & $ O(1), O(n)$ & 78 & 80 & 82 & 78 & 77 & \\
 \cline{2-9}
 & $O(n^2)$ & 12 & $O(1), O(n), O(n^2)$ & 18 & 14 & 11 & 16 & 17 \\
 \cline{2-9}
 & $O(n^3)$ & 1 & $O(n^3)$ & 1 & 1 & 4 & 2 & 4 \\
 \cline{2-9}
 & unbounded & 20 & $O(1), O(n), O(n^2), \infty$ & 9 & 0 & 0 & 0 & 0 \\
 \hline \hline
 \multirow{2}{*}{Tianhan} 
 & $O(n)$ & 34 & $O(n) $ & 34 & 35 & 35 & 35 & 35 \\
 \cline{2-9}
 & $O(n^2)$ & 3 & $O(n^2)$ & 3 & 2 & 2 & 2 & 2 \\
 \hline
 \end{tabular}
 }
 \vspace{-1cm}
 \end{table}
 
 