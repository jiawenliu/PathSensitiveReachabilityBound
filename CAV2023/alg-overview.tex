
\textbf{Step 1: }
The Section~\ref{sec:progabs} first 
computes the \emph{Abstract Transition Graph} as in Figure~\ref{fig:relatedNestedWhileOdd-overview}(b).
Each edge $l \xrightarrow{dc} l'$ is an abstract transition $\absevent = (l, dc, l')$ annotated with a constraint $dc$ corresponding to the command of label $l$.

% \textbf{Step 2: Program Refinement}
\textbf{Step 2: }
The second step in Section~\ref{sec:refine}
computes the \emph{Refined Program}, $\rprog$ for a program $c$ based on 
its abstraction transition graph and transforms the multiple-paths loops
into multiple loops where
the interleaving of paths is explicit as in bottom part of Figure~\ref{fig:relatedNestedWhileOdd-overview}(c).
It has two interleaving patterns in the loop $L_1$.
%  denoted as $\rprog_1^1$ and $\rprog_1^2$.

% \textbf{Step 3: Ranking Function Estimation}
\textbf{Step 3: }
In the meanwhile, Section~\ref{sec:rank} computes the \emph{Ranking Function}, $\locbound(\absevent, c)$ 
for every edge $\absevent$ 
and estimates an upper bound invariant for each.

% \textbf{Step 4: Path-sensitive Reachability-bound Computation.}
\textbf{Step 4: }
% The \emph{path-sensitive reachability-bound} 
The algorithm computes the \emph{Reachability-bound}, $\psRB(l, c)$ for every program point $l$ using the $\rprog$ and the upper bound invariant of the $\locbound(\absevent, c)$ where $\absevent = (l,dc,l')$.
It requires to compute our two novel quantities, the \emph{Path Reachability-bound}, $\inoutB(\rprog, \tpath, c)$ and the \emph{Loop Reachability-bound}, $\lpchB(l: \rprog, \tpath, c)$.
Section~\ref{sec:psrb} introduces this algorithm and the following sections describe the computations. 
The soundness of each algorithm is in the Appendices and the input $c$ will be omitted if the context is clear.

In the first interleaving pattern, $\rprog_1^1 = 1: \rprepeat(\tpath_1; 4:\rprepeat(\tpath_3); \tpath_2; \tpath_4)$ in Figure~\ref{fig:relatedNestedWhileOdd-overview},
we first compute $\outinB(4:\rprepeat(\tpath_3), \tpath_3) = n - m$
 for $\tpath_3$ in its innermost loop $L_4$ as a local \emph{path reachability-bound} by Section~\ref{sec:pathlocalrb}.
Then we compute $\lpchB(\rprog_1^1, \tpath_3) = 1$ w.r.t. its outer loop $L_1$ in Section~\ref{sec:looprb}. In the second interleaving pattern, we compute $\outinB(4:\rprepeat(\tpath_3), \tpath) = n - m - 3$ and the same for $\lpchB$.
So Section~\ref{sec:pathrb} computes $\inoutB(\rprog, \tpath_3) = \max\{ 1 \times (n - m), 1 \times (n - m - 3) \} = n - m$ globally.

Then for every program point $l$, we sum up all the $\inoutB(\rprog, \tpath)$ over $\tpath$ that contains $l$ and get $\psRB(l, c)$.
Since point $5$ only shows up on $\tpath_3$, we compute \highlight{$\psRB(5, c) = n - m$}.
The points $0$ and $\lex$ are not in any loop, so $\psRB(0) = \psRB(\lex) = 1$,
The points $3, 6, 7$ and $8$ which only show up once on $\tpath_2$ and $\tpath_4$ are all equal to $\lfloor\frac{m}{4}\rfloor$, which are same as their $\inoutB$.
For the loop headers $1$ and $4$, we only sum up the $\inoutB(\rprog, \tpath)$ where they show up as start-point of the $\tpath$.
So $\psRB(4) =  \lfloor\frac{m}{4}\rfloor + n - m + 1$ and $\psRB(1) = 2 \times \lfloor\frac{m}{4}\rfloor + 1$ all as expected.
% For the other points in different branches and loop, we compute
% $\psRB(1) =2 \times \lfloor\frac{m}{4}\rfloor + 1$,
% $\psRB(2) =2 \times \lfloor\frac{m}{4}\rfloor $, 
% $\psRB(3) = \psRB(6) = \psRB(7)  = \psRB(8) = \lfloor\frac{m}{4}\rfloor $,
% \highlight{$\psRB(5) = \lfloor\frac{m}{4}\rfloor \times 1$},
% and $\psRB(4) =  \lfloor\frac{m}{4}\rfloor + n - m + 1$ as expected.


%     % Our static program analysis algorithm computes 
% % a \emph{reachability-bound} for every program point $l$ in a program $c$ in a path sensitive manner.
% % The main steps of this algorithm and the organization the following sections are summarized as follows.
% \begin{enumerate}
%     \item  The Section~\ref{sec:progabs} first 
%     computes the \emph{Abstract Transition Graph}, $\absG(\kw{nestedOdd})$ as in Figure~\ref{fig:relatedNestedWhileOdd-overview}(b).
%     Each edge $l \xrightarrow{dc} l'$ is an abstract transition with annotated with a constraint corresponding to the command of label $l$.
%     \item The second step in Section~\ref{sec:refine}
%     computes the \emph{Refined Program}, $\rprog$ for a program $c$ based on 
%     its abstraction transition graph and transforms the multiple-paths loops
%     into multiple loops where
%     the interleaving of paths is explicit as in bottom part of Figure~\ref{fig:relatedNestedWhileOdd-overview}(c).
%     \item In the same time of refining the program, we also compute the \emph{Ranking Function} in Section~\ref{sec:rank}
%     for every edge 
%     and estimate the upper bound invariant w.r.t, the input variables on every ranking function's maximum value.
%     \item The \emph{path-sensitive reachability-bound} algorithm computes the \emph{reachability-bound}, $\psRB(l, c)$ for every program point.
%     It relies on the \emph{Refined Program} and the upper bound invariant of the \emph{Ranking Function} computed previously.
%     It requires to compute our two novel quantities, the \emph{Path Reachability-bound}, $\outinB(\rprog, \tpath)$ and the \emph{Loop Reachability-bound}, $\lpchB(l: \rprog, \tpath)$.

%     For the transition path $\tpath_3 = 4 \to 5 \to 4$ in the first interleaving pattern where $\rprog_1^1 = 1: \rprepeat(\tpath_1; 4:\rprepeat(\tpath_3); \tpath_2; \tpath_4)$,
%     we compute $\outinB(4:\rprepeat(\tpath_3), \tpath) = m$ w.r.t its innermost loop $L_4$ as a local \emph{Path Reachability-bound} in Section~\ref{sec:pathlocalrb}
%     We also compute $\lpchB(\rprog_1^1, \tpath) = 1$ w.r.t. its outer loop $L_1$ in Section~\ref{def:looprb},
%     and Section~\ref{sec:pathrb} computes $\tpath_3$'s global \emph{Path Reachability-bound} $\inoutB(\rprog, \tpath) = m$.

%     By summing up all the \emph{path reachability-bounds}, $\inoutB(\rprog, \tpath)$ over the $\tpath$ which contains the program point $l$, we compute the \emph{Reachability-bound}, $\psRB(l, c)$ for every program point $l \in \lvar(c)$.
%     For the points $0$ and $\lex$ which aren't in any loop, we compute $\psRB(0) = \psRB(\lex) = 1$,
%     For the other points in different branches and loop, we compute $\psRB(1) =2 \times \lfloor\frac{m}{4}\rfloor + 1$,
%     $\psRB(2) =2 \times \lfloor\frac{m}{4}\rfloor $, 
%     $\psRB(3) = \psRB(6) = \psRB(7)  = \psRB(8) = \lfloor\frac{m}{4}\rfloor $,
%     \highlight{$\psRB(5) = \lfloor\frac{m}{4}\rfloor \times 1$},
%     and $\psRB(4) =  \lfloor\frac{m}{4}\rfloor + n - m + 1$ as expected.

%     Section~\ref{sec:psrb} introduces this algorithm and the following sections describe the computations. 
%     % To compute the \emph{reachability-bound}  compute the path reachability-bound for 
%     % We compute the $\lpchB(l: \rprog, \tpath)$ for 
%     % \begin{enumerate}
%         % \item Based on the ranking function and its upper bound invariant, we first compute the \emph{Path Local Reachability-bound}, $\outinB(\rprog, \tpath)$ for every \emph{simple transition path} $\tpath$ in Section~\ref{sec:pathlocalrb}. 
%         % This bounds the reaching / visiting times of $\tpath$ when executing program $\rprog$, and $\rprog$ is the closest loop where $\tpath$ is nested.
%         % The local reachability-bound  considers only the execution of $\tpath$'s closest enclosing loop, i.e., $\kw{enclosed}(\tpath)$.
%         % \item Then in Section~\ref{sec:looprb}, we compute the \emph{Loop Reachability-bound}, $\lpchB(l: \rprog, \tpath)$ for every \emph{simple transition path} $\tpath$
%         % w.r.t its nested loop. 
%         % This is the bound on iteration numbers of the outside loop $l$,
%         % such that during these iterations, the nested loop $l' = \kw{enclosed(\tpath)}$ is executed, i.e., reached.
%         % \item The \emph{Path Reachability-bound}, $\inoutB(\rprog, \tpath)$  is a global upper bound on the execution times of a \emph{simple transition path} $\tpath$ computed in Section~\ref{sec:pathrb}.
%         % With the global reachability-bound of every simple transition path, now we can sum up all the \emph{path reachability-bounds}, $\inoutB(\rprog, \tpath)$ over the $\tpath$ which contains the program point $l$, and compute the \emph{Reachability-bound}, $\psRB(l, c)$ for every program point $l \in \lvar(c)$ as in Definition~\ref{def:point_psrb}.
%     % \end{enumerate}
%     \end{enumerate}
