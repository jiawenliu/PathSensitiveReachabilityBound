Plan:
\textbf{Two Examples + Algorithm Overview}
\begin{itemize}
\item {Multiple-Path While Loop}
\\
\textbf{The First Challenge/Problem from The Example, 
and the Overview of the New Techniques Targeting This Problem}
\item {Nested While Loop}
\\
\textbf{The Second Challenge/Problem from The Example,
and the Overview of the New Techniques Targeting This Problem}
\end{itemize}
In this section, we discuss two representative examples with
challenges of analyzing the symbolic
\emph{reachability-bound} on
%  bounds for the \emph{reachability-bound} problem
every control location.
We also give the technique overview of our algorithm.
%
\subsection{Multiple-Path Loop}
\label{sec:overview-multiplepath}
\input{examples/whileOdd}
Figure~\ref{fig:whileOdd}(a) shows an example of a two paths loops
with different \emph{reachability-bounds} on the control locations in different paths.
This example is adopted from the example in~\cite{Sumit2010rechability}, which
is a skeleton code from the .Net base-class library.
\\
In this example,
the precise \emph{reachability-bounds} for control locations $3$ and $4$ are both $\frac{k}{4}$,
for location $2$ is $\frac{k}{2}$, and for location $1$ is $\frac{k}{2} + 1$.
\\
In order to know that the locations $3$ and $4$ are reached at most $\frac{k}{4}$ times during program execution,
we need to know that the commands at line $3$ and $4$ are executed alternatively after each other
during the iterations of the enclosed loop.
In the other words, neither of them is executed twice in two consecutive iterations.
\\
However, the method in~\cite{Sumit2010rechability}
%  where the \emph{reachability-bound} problem is defined,
% it 
can only derive the bound $k$ for locations $3$ and $4$ because of the path-insensitivity in the method.
To best of my knowledge, there isn't any other work on solving the \emph{reachability-bound} problem.
\\
Among the works on loop bound analysis, \cite{GulwaniJK09} can compute the precise global
loop bound (i.e., $\frac{k}{2}$) for this example path-sensitively.
Using this global bound, we can compute the precise reachability-bound for location $1$ and $2$.
However, the  \emph{reachability-bounds} for control locations $3$ and $4$ are still unclear.
% In order to know location $3$ and $4$ are executed $\frac{k}{4}$,
% we need to know location $3$ and $4$ is executed alternatively after each other.
% In other words, neither of them is executed twice in 2 consecutive iterations.
% \\
% We need to generate the repeat patterns containing the two execution paths reflecting this property.
% % However, this execution path corresponds to two iterations of the while loop.
% \\
% Then, we recover the \emph{reachability-bound} of location $3$ and $4$ globally from the
% repeat pattern through the \emph{Inside-Out} Algorithm introduced next.
% we need to 
\paragraph{Outside-In Algorithm}
The first key idea of this path-sensitive \emph{reachability-bound} analysis algorithm is the \emph{outside-in} algorithm.
\\
This algorithm combines the idea of \emph{difference constraint} based program complexity analysis method from \cite{sinn2017complexity}
and the control-flow refinement technique from~\cite{GulwaniJK09} efficiently.
It first
%  abstracts 
transforms the program into a constraint program using the difference constraints as in Figure~\ref{fig:whileOdd}(b).
%  based program abstracting technique from \cite{sinn2017complexity}.
Then it transforms every while loop in the constraint program by adopting the control-flow refinement technique.
% 
\\
% and the while loop refinement~\cite{GulwaniJK09}.
For this $\kw{whileOdd}$ example, the \emph{Outside-In} algorithm generates 
the transformed program as in Figure~\ref{fig:whileOdd}(c).
% $0 \to 1; 
% \rpchoose\{
%     \eskip,
%     \rprepeat(\rprepeat(2 \to 3 \to 1); 2 \to 4 \to 1),
%     \rprepeat(\rprepeat(2 \to 4 \to 1); 2 \to 3 \to 1)
%     % 2 \to 3 \to 1,
%     % 2 \to 4 \to 1
%     \}; 1 \to \lex$.
% \\
% The repeat patterns containing the two execution paths reflecting this property.
% There are 4 possible repeat patterns for this example.
% Each refined while loop in the program is composed of all possible repeat patterns.
% The repeat pattern can be one single execution path,
% or is composed of one or more execution paths, or nested repeat pattern.
Then
%  for every repeat pattern
%  execution path, 
the \emph{outside-in} algorithm
computes the bound on the iteration numbers
for each of the subprogram in a recursive fashion,
%  w.r.t to every repeat pattern
%  of the execution paths for 
in the direction
of the outermost $\rprepeat$ notation to the innermost one.
%  repeat pattern.
For this example, the \emph{Outside-In} algorithm computes the bounds
%  for every repeat pattern
on the iteration numbers for the subprogram
$\rprepeat(2 \to 3 \to 1)$, 
$\rprepeat(2 \to 4 \to 1)$, 
$\rprepeat(\rprepeat(2 \to 3 \to 1); 2 \to 4 \to 1)$, and 
$\rprepeat(\rprepeat(2 \to 4 \to 1); 2 \to 3 \to 1)$
as $1$, $1$, $\frac{k}{4}$, and $\frac{k}{4}$ respectively.
\\
Then in the next step, the \emph{Inside-Out} algorithm uses these bounds 
to compute the \emph{reachability-bound} for each location.
%  $3$ and $4$ globally from the
% repeat pattern and the enclosed loops through the \emph{Inside-Out} Algorithm.
\subsection{Nested Loops with Related Iterator}
\label{sec:overview-nestedwhile}
% Even though with the local bound computed for every repeat pattern,
Computing the \emph{reachability-bound} for each location is the other challenge, even though with
the
%  local 
iteration bound computed for every subprogram.
Figure~\ref{fig:threeWhile}(a) shows an example of the nested loops with related 
iterators.
This example is adopted from the example in~\cite{GulwaniJK09}, which is common in product code.
\\
% We first compute the local bound for the only one execution path $6 \to 7$ in $L_6$ as $N$ by the \emph{Outside-In} algorithm.
% %
% Then i
In line 8, $i$ is reset by $w$ and $w$ is reset by $j$ at line 5. So the
while $L_6$ is only executed in the first iteration of while loop $L_1$ and $L_3$.
% \\
The while loop $L_3$ at line 3 is executed only in 
the first $m - N$ iterations of the 
$L_1$ because $j$ is reset by $i$ in line 2.
% \\
So the total combined iterations of all the three loops is bounded above by 
$n + m^2 - m \times N$.
And the precise global reachability-bound for location $7$ inside the $L_6$ is $N$,
for locations $4, 5$ and $8$ between the $L_3$ and $L_6$ are $(n-N) \times (m - N)$,
and locations $2$ and $9$ are $n - N$.
\\
\highlight{Notice here the global \emph{reachability-bounds} for the locations inside the loop $L_6$ is 
the same as its loop iteration bound computed by the \emph{Outside-In} algorithm.
However, for the locations between $L_3$ and $L_6$,
the \emph{reachability-bounds} are the multiplication of the inner and outer loop iteration bounds.}
\\
So far, the loop bound analysis method in \cite{GulwaniJK09} is able to give
an approximation for the $n + (m \times n) + N$. 
The DC-based algorithm in \cite{sinn2017complexity} is able to
compute the precise combined loop bound of $n + m^2 - m \times N$.
\\
But knowing the global loop bound isn't enough to solve the \emph{reachability-bound problem} for locations in nested loops,
especially the locations which are similar to $7$ in $\kw{threeNestedWhile}$ example.
\\
% However, i
% In order to solve the \emph{reachability-bound problem} for locations inside
\highlight{
    In order to precisely compute how many times the locations inside
$L_6$ is reached globally, we need to know
the numbers of iterations of the outside loop $L_3$ and $L_1$, 
during which the $L_6$ is entered. 
Then we multiply the iteration bounds of the $L_6$ with the number of iterations where it is entered to get the precise
\emph{reachability-bounds} on the control locations inside $L_6$.
This quantity isn't considered or computed in any of the previous works.
}
\\
The \emph{Progress Invariant} method in \cite{GulwaniJK09} is only able to compute
the
%  bound for
%  $L_6$ inside $L_3$ and $L_1$.
bound on iteration numbers
of the inner loop $L_6$ in each iteration of $L_3$ and $L_1$, which are both $N$.
%  the outside loop where it is nested.
% The bound for the iteration numbers $L_6$ in each iteration of $L_3$  and $L_1$ are both $N$, which isn't precise
So we have to over-approximate the reachability-bound for locations inside $L_6$ with the
overall program complexity, i.e., $n + m^2 - m \times N$.
\\
For the same reason, the DC-based algorithm in \cite{sinn2017complexity}
is only able to
compute the precise combined loop bound and the local bound of each loop
separately as well.
We are still unable to know the precise \emph{reachability-bound} for the locations in the innermost loop.
% \\
\paragraph*{Inside-Out Algorithm}
The second key idea of this path-sensitive reachability analysis algorithm is the
\emph{inside-out} algorithm.
\highlight{This algorithm computes an $InOut$ bound on number of the iterations for
every outside loops w.r.t. an inner loop.
%  of every control location.
Such that during these iterations of each outside loop, the inner loop is entered. 
% the for every program control location,
% how many times the innermost loop of this control location will be touched w.r.t. every
% outside loop it is nested in.
This is distinguished from the traditional methods, which only compute the bound on the iteration number
for the inner loop w.r.t each iteration of the outside loop where it is nested.
}
%
\\
For this $\kw{threeNestedWhile}$ example, 
% we compute 
the \emph{Inside-Out} algorithm computes the $InOut$ bounds for the loops $L_1$ and $L_3$
w.r.t. the $L_6$ as
$InOut(L_1, L_6) = 1$ and
$InOut(L_3, L_6) = 1$.
$InOut(L_1, L_6) = 1$ means that during all the loop $L_1$'s iterations, there is only 1 iteration where the loop $L_6$ is executed.
Among all the other $n - 1$ iterations of $L_1$, the loop $L_6$ isn't executed at all.
Then, we combine this result with the loop iteration bounds
computed from the \emph{Outside-In} algorithm and compute
% For the only one path $6 \to 7$ in $L_6$, 
% we compute 
the 
accurate reachability bound $N$ for locations inside loop $L_6$.
% \\
% The derivation of the reachability bound for location $6$ and $7$
% on this path is straightforward in the last step.
\input{examples/threeNestedWhile}
