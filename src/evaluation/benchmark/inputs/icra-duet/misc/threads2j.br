i = BtId;

	while( i-- )
		dest[i] = (unsigned char)id, id >>= 8;


(BtLatch *latch, int private)
{
ushort decr = 0;
uint prev;

  if( private )
	private = FUTEX_PRIVATE_FLAG;

  while( 1 ) {
	//	obtain latch mutex
	while( __sync_lock_test_and_set(latch->mutex, 1) )
		sched_yield();

	if( decr )
		latch->rcnt--, decr = 0;

	//  wait for writers to clear
	//	increment read waiters and wait

	if( latch->write || latch->writewait ) {
		latch->readwait = 1;
		latch->rcnt++;
		prev = *(uint *)latch & ~1;
		__sync_lock_release (latch->mutex);
		sys_futex( (uint *)latch, FUTEX_WAIT_BITSET | private, prev, NULL, NULL, QueRd );
		decr = 1;
		continue;
	}
	
	// increment reader lock count
	// and release latch mutex

	latch->readwait = 0;
	latch->share++;
	__sync_lock_release (latch->mutex);
	return;
  }
}


(BtLatch *latch, int private)
{
ushort decr = 0;
uint prev;

  if( private )
	private = FUTEX_PRIVATE_FLAG;

  while( 1 ) {
	//	obtain latch mutex
	while( __sync_lock_test_and_set(latch->mutex, 1) )
		sched_yield();

	if( decr )
		latch->wcnt--, decr = 0;

	//	wait for write and reader count to clear

	if( latch->write || latch->share ) {
		latch->writewait = 1;
		latch->wcnt++;
		prev = *(uint *)latch & ~1;
		__sync_lock_release (latch->mutex);
		sys_futex( (uint *)latch, FUTEX_WAIT_BITSET | private, prev, NULL, NULL, QueWr );
		decr = 1;
		continue;
	}
	
	//	take write mutex
	//	release latch mutex

	if( !latch->wcnt )
		latch->writewait = 0;

	latch->write = 1;
	__sync_lock_release (latch->mutex);
	return;
  }
}

	while( __sync_lock_test_and_set(latch->mutex, 1) )
		sched_yield();

	while( __sync_lock_test_and_set(latch->mutex, 1) )
		sched_yield();

ushort hashidx = page_no % bt->mgr->latchmgr->latchhash;
ushort slot, avail = 0, victim, idx;
BtLatchSet *set;

	//  obtain read lock on hash table entry

	bt_spinreadlock(bt->mgr->latchmgr->table[hashidx].latch, 0);

	if( slot = bt->mgr->latchmgr->table[hashidx].slot ) do
	{
		set = bt->mgr->latchsets + slot;
		if( page_no == set->page_no )
			break;
	} while( slot = set->next );

  if( slot = bt->mgr->latchmgr->table[hashidx].slot ) do
  {
	set = bt->mgr->latchsets + slot;
	if( page_no == set->page_no )
		break;
	if( !set->pin && !avail )
		avail = slot;
  } while( slot = set->next );


  while( 1 ) {
#ifdef unix
	victim = __sync_fetch_and_add(&bt->mgr->latchmgr->latchvictim, 1);
#else
	victim = _InterlockedIncrement16 (&bt->mgr->latchmgr->latchvictim) - 1;
#endif
	//	we don't use slot zero

	if( victim %= bt->mgr->latchmgr->latchtotal )
		set = bt->mgr->latchsets + victim;
	else
		continue;

	//	take control of our slot
	//	from other threads

	if( set->pin || !bt_spinwritetry (set->busy) )
		continue;

	idx = set->hash;

	// try to get write lock on hash chain
	//	skip entry if not obtained
	//	or has outstanding locks

	if( !bt_spinwritetry (bt->mgr->latchmgr->table[idx].latch) ) {
		bt_spinreleasewrite (set->busy, 0);
		continue;
	}

	if( set->pin ) {
		bt_spinreleasewrite (set->busy, 0);
		bt_spinreleasewrite (bt->mgr->latchmgr->table[idx].latch, 0);
		continue;
	}

	//  unlink our available victim from its hash chain

	if( set->prev )
		bt->mgr->latchsets[set->prev].next = set->next;
	else
		bt->mgr->latchmgr->table[idx].slot = set->next;

	if( set->next )
		bt->mgr->latchsets[set->next].prev = set->prev;

	bt_spinreleasewrite (bt->mgr->latchmgr->table[idx].latch, 0);
#ifdef unix
	__sync_fetch_and_add(&set->pin, 1);
#else
	_InterlockedIncrement16 (&set->pin);
#endif
	bt_latchlink (bt, hashidx, victim, page_no);
	bt_spinreleasewrite (bt->mgr->latchmgr->table[hashidx].latch, 0);
	bt_spinreleasewrite (set->busy, 0);
	return set;
  }



	mgr->seg_bits = 0;

	while( (1 << mgr->seg_bits) <= mgr->poolmask )
		mgr->seg_bits++;

	memset(latchmgr, 0, mgr->page_size);
	last = MIN_lvl + 1;

	while( last <= ((MIN_lvl + 1 + nlatchpage) | mgr->poolmask) ) {
#ifdef unix
		pwrite(mgr->idx, latchmgr, mgr->page_size, last << mgr->page_bits);
#else
		SetFilePointer (mgr->idx, last << mgr->page_bits, NULL, FILE_BEGIN);
		if( !WriteFile (mgr->idx, (char *)latchmgr, mgr->page_size, amt, NULL) )
			return bt_mgrclose (mgr), NULL;
		if( *amt < mgr->page_size )
			return bt_mgrclose (mgr), NULL;
#endif
		last++;
	}


	page_no &= ~bt->mgr->poolmask;

	while( pool->basepage != page_no )
	  if( pool = pool->hashnext )
		continue;
	  else
		return NULL;

	while( 1 ) {
#ifdef unix
		victim = __sync_fetch_and_add(&bt->mgr->evicted, 1);
#else
		victim = _InterlockedIncrement16 (&bt->mgr->evicted) - 1;
#endif
		victim %= bt->mgr->poolmax;
		pool = bt->mgr->pool + victim;
		idx = (uint)(pool->basepage >> bt->mgr->seg_bits) % bt->mgr->hashsize;

		if( !victim )
			continue;

		// try to get write lock
		//	skip entry if not obtained

		if( !bt_spinwritetry (&bt->mgr->latch[idx]) )
			continue;

		//	skip this entry if
		//	page is pinned
		//  or clock bit is set

		if( pool->pin ) {
#ifdef unix
			__sync_fetch_and_and(&pool->pin, ~CLOCK_bit);
#else
			_InterlockedAnd16 (&pool->pin, ~CLOCK_bit);
#endif
			bt_spinreleasewrite (&bt->mgr->latch[idx], 1);
			continue;
		}

		// unlink victim pool node from hash table

		if( node = pool->hashprev )
			node->hashnext = pool->hashnext;
		else if( node = pool->hashnext )
			bt->mgr->hash[idx] = node->slot;
		else
			bt->mgr->hash[idx] = 0;

		if( node = pool->hashnext )
			node->hashprev = pool->hashprev;

		bt_spinreleasewrite (&bt->mgr->latch[idx], 1);

		//	remove old file mapping
#ifdef unix
		munmap (pool->map, (bt->mgr->poolmask+1) << bt->mgr->page_bits);
#else
		FlushViewOfFile(pool->map, 0);
		UnmapViewOfFile(pool->map);
		CloseHandle(pool->hmap);
#endif
		pool->map = NULL;

		//  create new pool mapping
		//  and link into hash table

		if( bt_mapsegment(bt, pool, page_no) )
			return NULL;

		bt_linkhash(bt, pool, page_no, hashidx);
		bt_spinreleasewrite (&bt->mgr->latch[hashidx], 1);
		return pool;
	}

(BtPageSet *set, unsigned char *key, uint len)
uint diff, higher = set->page->cnt, low = 1, slot;
uint good = 0;

	//	  make stopper key an infinite fence value

	if( bt_getid (set->page->right) )
		higher++;
	else
		good++;

	//	low is the lowest candidate.
	//  loop ends when they meet

	//  higher is already
	//	tested as .ge. the passed key.

	while( diff = higher - low ) {
		slot = low + ( diff >> 1 );
		if( keycmp (keyptr(set->page, slot), key, len) < 0 )
			low = slot + 1;
		else
			higher = slot, good++;
	}




  do {
	// determine lock mode of drill level
	mode = (drill == lvl) ? lock : BtLockRead; 

	set->latch = bt_pinlatch (bt, page_no);
	set->page_no = page_no;

	// pin page contents

	if( set->pool = bt_pinpool (bt, page_no) )
		set->page = bt_page (bt, set->pool, page_no);
	else
		return 0;

 	// obtain access lock using lock chaining with Access mode

	if( page_no > ROOT_page )
	  bt_lockpage(BtLockAccess, set->latch);

	//	release & unpin parent page

	if( prevpage ) {
	  bt_unlockpage(prevmode, prevlatch);
	  bt_unpinlatch (prevlatch);
	  bt_unpinpool (prevpool);
	  prevpage = 0;
	}

 	// obtain read lock using lock chaining

	bt_lockpage(mode, set->latch);

	if( set->page->free )
		return bt->err = BTERR_struct, 0;

	if( page_no > ROOT_page )
	  bt_unlockpage(BtLockAccess, set->latch);

	// re-read and re-lock root after determining actual level of root

	if( set->page->lvl != drill) {
		if( set->page_no != ROOT_page )
			return bt->err = BTERR_struct, 0;
			
		drill = set->page->lvl;

		if( lock != BtLockRead && drill == lvl ) {
		  bt_unlockpage(mode, set->latch);
		  bt_unpinlatch (set->latch);
		  bt_unpinpool (set->pool);
		  continue;
		}
	}

	prevpage = set->page_no;
	prevlatch = set->latch;
	prevpool = set->pool;
	prevmode = mode;

	//  find key on page at this level
	//  and descend to requested level

	if( !set->page->kill )
	 if( slot = bt_findslot (set, key, len) ) {
	  if( drill == lvl )
		return slot;

	  while( slotptr(set->page, slot)->dead )
		if( slot++ < set->page->cnt )
			continue;
		else
			goto slideright;

	  page_no = bt_getid(slotptr(set->page, slot)->id);
	  drill--;
	  continue;
	 }

	//  or slide right into next page

slideright:
	page_no = bt_getid(set->page->right);

  
  } while( page_no );



  do {
	for( idx = 0; idx++ < root->page->cnt; )
	  if( !slotptr(root->page, idx)->dead )
		break;

	child->page_no = bt_getid (slotptr(root->page, idx)->id);

	child->latch = bt_pinlatch (bt, child->page_no);
	bt_lockpage (BtLockDelete, child->latch);
	bt_lockpage (BtLockWrite, child->latch);

	if( child->pool = bt_pinpool (bt, child->page_no) )
		child->page = bt_page (bt, child->pool, child->page_no);
	else
		return bt->err;

	memcpy (root->page, child->page, bt->mgr->page_size);
	bt_freepage (bt, child);

  } while( root->page->lvl > 1 && root->page->act == 1 );


	  if( found = slotptr(set->page, slot)->dead == 0 ) {
		dirty = slotptr(set->page, slot)->dead = 1;
 		set->page->dirty = 1;
 		set->page->act--;

		// collapse empty slots

		while( idx = set->page->cnt - 1 )
		  if( slotptr(set->page, idx)->dead ) {
			*slotptr(set->page, idx) = *slotptr(set->page, idx + 1);
			memset (slotptr(set->page, set->page->cnt--), 0, sizeof(BtSlot));
		  } else
			break;
	  }

	memset (page+1, 0, bt->mgr->page_size - sizeof(*page));
	page->dirty = 0;
	page->act = 0;

	// try cleaning up page first
	// by removing deleted keys

	while( cnt++ < max ) {
		if( cnt == slot )
			newslot = idx + 1;
		if( cnt < max && slotptr(bt->frame,cnt)->dead )
			continue;

		// copy the key across

		key = keyptr(bt->frame, cnt);
		nxt -= key->len + 1;
		memcpy ((unsigned char *)page + nxt, key, key->len + 1);

		// copy slot

		memcpy(slotptr(page, ++idx)->id, slotptr(bt->frame, cnt)->id, BtId);
		if( !(slotptr(page, idx)->dead = slotptr(bt->frame, cnt)->dead) )
			page->act++;
		slotptr(page, idx)->tod = slotptr(bt->frame, cnt)->tod;
		slotptr(page, idx)->off = nxt;
	}

	max = set->page->cnt;
	cnt = max / 2;
	idx = 0;

	while( cnt++ < max ) {
		key = keyptr(set->page, cnt);
		nxt -= key->len + 1;
		memcpy ((unsigned char *)bt->frame + nxt, key, key->len + 1);

		memcpy(slotptr(bt->frame,++idx)->id, slotptr(set->page,cnt)->id, BtId);
		if( !(slotptr(bt->frame, idx)->dead = slotptr(set->page, cnt)->dead) )
			bt->frame->act++;
		slotptr(bt->frame, idx)->tod = slotptr(set->page, cnt)->tod;
		slotptr(bt->frame, idx)->off = nxt;
	}


	cnt = 0;
	idx = 0;

	//  assemble page of smaller keys

	while( cnt++ < max / 2 ) {
		key = keyptr(bt->frame, cnt);
		nxt -= key->len + 1;
		memcpy ((unsigned char *)set->page + nxt, key, key->len + 1);
		memcpy(slotptr(set->page,++idx)->id, slotptr(bt->frame,cnt)->id, BtId);
		slotptr(set->page, idx)->tod = slotptr(bt->frame, cnt)->tod;
		slotptr(set->page, idx)->off = nxt;
		set->page->act++;
	}


	while( 1 ) {
		if( slot = bt_loadpage (bt, set, key, len, lvl, BtLockWrite) )
			ptr = keyptr(set->page, slot);
		else
		{
			if( !bt->err )
				bt->err = BTERR_ovflw;
			return bt->err;
		}

		// if key already exists, update id and return

		if( !keycmp (ptr, key, len) ) {
			if( slotptr(set->page, slot)->dead )
				set->page->act++;
			slotptr(set->page, slot)->dead = 0;
			slotptr(set->page, slot)->tod = tod;
			bt_putid(slotptr(set->page,slot)->id, id);
			bt_unlockpage(BtLockWrite, set->latch);
			bt_unpinlatch (set->latch);
			bt_unpinpool (set->pool);
			return 0;
		}

		// check if page has enough space

 		if( slot = bt_cleanpage (bt, set->page, len, slot) )
			break;

		if( bt_splitpage (bt, set) )
			return bt->err;
	}

	if( idx == set->page->cnt )
		idx++, set->page->cnt++;

	set->page->act++;

	while( idx > slot )
		*slotptr(set->page, idx) = *slotptr(set->page, idx -1), idx--;


BtPageSet set[1];
uid right;

  do {
	right = bt_getid(bt->cursor->right);

	while( slot++ < bt->cursor->cnt )
	  if( slotptr(bt->cursor,slot)->dead )
		continue;
	  else if( right || (slot < bt->cursor->cnt) ) // skip infinite stopper
		return slot;
	  else
		break;

	if( !right )
		break;

	bt->cursor_page = right;

	if( set->pool = bt_pinpool (bt, right) )
		set->page = bt_page (bt, set->pool, right);
	else
		return 0;

	set->latch = bt_pinlatch (bt, right);
    bt_lockpage(BtLockRead, set->latch);

	memcpy (bt->cursor, set->page, bt->mgr->page_size);

	bt_unlockpage(BtLockRead, set->latch);
	bt_unpinlatch (set->latch);
	bt_unpinpool (set->pool);
	slot = 0;

  } while( 1 );

	  *(uint *)(bt->mgr->latchmgr->table[hashidx].latch) = 0;

	  if( idx = bt->mgr->latchmgr->table[hashidx].slot ) do {
		latch = bt->mgr->latchsets + idx;
		if( *(uint *)latch->busy )
			fprintf(stderr, "latchset %d busylocked for page %.8x\n", idx, latch->page_no);
		*(uint *)latch->busy = 0;
		if( latch->hash != hashidx )
			fprintf(stderr, "latchset %d wrong hashidx\n", idx);
		if( latch->pin )
			fprintf(stderr, "latchset %d pinned for page %.8x\n", idx, latch->page_no);
	  } while( idx = latch->next );


	next = bt->mgr->latchmgr->nlatchpage + LATCH_page;
	page_no = LEAF_page;

	while( page_no < bt_getid(bt->mgr->latchmgr->alloc->right) ) {
		pread (bt->mgr->idx, bt->frame, bt->mgr->page_size, page_no << bt->mgr->page_bits);
		if( !bt->frame->free )
		 for( idx = 0; idx++ < bt->frame->cnt - 1; ) {
		  ptr = keyptr(bt->frame, idx+1);
		  if( keycmp (keyptr(bt->frame, idx), ptr->key, ptr->len) >= 0 )
			fprintf(stderr, "page %.8x idx %.2x out of order\n", page_no, idx);
		 }

		if( page_no > LEAF_page )
			next = page_no + 1;
		page_no = next;
	}


		  while( ch = getc(in), ch != EOF )
			if( ch == '\n' )
			{
			  line++;

			  if( args->num == 1 )
		  		sprintf((char *)key+len, "%.9d", 1000000000 - line), len += 9;

			  else if( args->num )
		  		sprintf((char *)key+len, "%.9d", line + args->idx * args->num), len += 9;

			  if( bt_insertkey (bt, key, len, 0, line, *tod) )
				fprintf(stderr, "Error %d Line: %d\n", bt->err, line), exit(0);
			  len = 0;
			}
			else if( len < 255 )
				key[len++] = ch;
		break;

	case 'd':
		if( in = fopen (args->infile, "rb") )
		  while( ch = getc(in), ch != EOF )
			if( ch == '\n' )
			{
			  line++;
			  if( args->num == 1 )
		  		sprintf((char *)key+len, "%.9d", 1000000000 - line), len += 9;

			  else if( args->num )
		  		sprintf((char *)key+len, "%.9d", line + args->idx * args->num), len += 9;

			  if( bt_deletekey (bt, key, len, 0) )
				fprintf(stderr, "Error %d Line: %d\n", bt->err, line), exit(0);
			  len = 0;
			}
			else if( len < 255 )
				key[len++] = ch;
		break;

	case 'f':
		if( in = fopen (args->infile, "rb") )
		  while( ch = getc(in), ch != EOF )
			if( ch == '\n' )
			{
			  line++;
			  if( args->num == 1 )
		  		sprintf((char *)key+len, "%.9d", 1000000000 - line), len += 9;

			  else if( args->num )
		  		sprintf((char *)key+len, "%.9d", line + args->idx * args->num), len += 9;

			  if( bt_findkey (bt, key, len) )
				found++;
			  else if( bt->err )
				fprintf(stderr, "Error %d Syserr %d Line: %d\n", bt->err, errno, line), exit(0);
			  len = 0;
			}
			else if( len < 255 )
				key[len++] = ch;


	case 's':
		fprintf(stderr, "started scanning\n");
	  	do {
			if( set->pool = bt_pinpool (bt, page_no) )
				set->page = bt_page (bt, set->pool, page_no);
			else
				break;
			set->latch = bt_pinlatch (bt, page_no);
			bt_lockpage (BtLockRead, set->latch);
			next = bt_getid (set->page->right);
			cnt += set->page->act;

			for( slot = 0; slot++ < set->page->cnt; )
			 if( next || slot < set->page->cnt )
			  if( !slotptr(set->page, slot)->dead ) {
				ptr = keyptr(set->page, slot);
				fwrite (ptr->key, ptr->len, 1, stdout);
				fputc ('\n', stdout);
			  }

			bt_unlockpage (BtLockRead, set->latch);
			bt_unpinlatch (set->latch);
			bt_unpinpool (set->pool);
	  	} while( page_no = next );

	  	cnt--;	// remove stopper key
		fprintf(stderr, " Total keys read %d\n", cnt);
		break;

	case 'c':
		fprintf(stderr, "started counting\n");
		next = bt->mgr->latchmgr->nlatchpage + LATCH_page;
		page_no = LEAF_page;

		while( page_no < bt_getid(bt->mgr->latchmgr->alloc->right) ) {
		uid off = page_no << bt->mgr->page_bits;
#ifdef unix
		  pread (bt->mgr->idx, bt->frame, bt->mgr->page_size, off);
#else
		DWORD amt[1];

		  SetFilePointer (bt->mgr->idx, (long)off, (long*)(&off)+1, FILE_BEGIN);

		  if( !ReadFile(bt->mgr->idx, bt->frame, bt->mgr->page_size, amt, NULL))
			return bt->err = BTERR_map;

		  if( *amt <  bt->mgr->page_size )
			return bt->err = BTERR_map;
#endif
			if( !bt->frame->free && !bt->frame->lvl )
				cnt += bt->frame->act;
			if( page_no > LEAF_page )
				next = page_no + 1;
			page_no = next;
		}
		