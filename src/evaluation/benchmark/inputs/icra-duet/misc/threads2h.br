int i;

	for( i = 0; i < BtId; i++ )
		id <<= 8, id |= *src++; 

uint slot;

	// release mapped pages
	//	note that slot zero is never used

	for( slot = 1; slot < mgr->poolmax; slot++ ) {
		pool = mgr->pool + slot;
		if( pool->slot )
#ifdef unix
			munmap (pool->map, (mgr->poolmask+1) << mgr->page_bits);
#else
		{
			FlushViewOfFile(pool->map, 0);
			UnmapViewOfFile(pool->map);
			CloseHandle(pool->hmap);
		}
#endif
	}



	memset (latchmgr, 0, 1 << bits);
	latchmgr->alloc->bits = mgr->page_bits;

	for( lvl=MIN_lvl; lvl--; ) {
		slotptr(latchmgr->alloc, 1)->off = mgr->page_size - 3;
		bt_putid(slotptr(latchmgr->alloc, 1)->id, lvl ? MIN_lvl - lvl + 1 : 0);		// next(lower) page number
		key = keyptr(latchmgr->alloc, 1);
		key->len = 2;		// create stopper key
		key->key[0] = 0xff;
		key->key[1] = 0xff;
		latchmgr->alloc->min = mgr->page_size - 3;
		latchmgr->alloc->lvl = lvl;
		latchmgr->alloc->cnt = 1;
		latchmgr->alloc->act = 1;
#ifdef unix
		if( write (mgr->idx, latchmgr, mgr->page_size) < mgr->page_size )
			return bt_mgrclose (mgr), NULL;
#else
		if( !WriteFile (mgr->idx, (char *)latchmgr, mgr->page_size, amt, NULL) )
			return bt_mgrclose (mgr), NULL;

		if( *amt < mgr->page_size )
			return bt_mgrclose (mgr), NULL;
#endif
	}


  do {
	for( idx = 0; idx++ < root->page->cnt; )
	  if( !slotptr(root->page, idx)->dead )
		break;

	child->page_no = bt_getid (slotptr(root->page, idx)->id);

	child->latch = bt_pinlatch (bt, child->page_no);
	bt_lockpage (BtLockDelete, child->latch);
	bt_lockpage (BtLockWrite, child->latch);

	if( child->pool = bt_pinpool (bt, child->page_no) )
		child->page = bt_page (bt, child->pool, child->page_no);
	else
		return bt->err;

	memcpy (root->page, child->page, bt->mgr->page_size);
	bt_freepage (bt, child);

  } while( root->page->lvl > 1 && root->page->act == 1 );


	set->page->min -= len + 1; // reset lowest used offset
	((unsigned char *)set->page)[set->page->min] = len;
	memcpy ((unsigned char *)set->page + set->page->min +1, key, len );

	for( idx = slot; idx < set->page->cnt; idx++ )
	  if( slotptr(set->page, idx)->dead )
		break;

#ifdef unix
	for( idx = 1; idx <= bt->mgr->latchmgr->latchdeployed; idx++ ) {
		set->latch = bt->mgr->latchsets + idx;
		if( set->latch->pin ) {
			fprintf(stderr, "latchset %d pinned for page %.6x\n", idx, set->latch->page_no);
			set->latch->pin = 0;
		}
	}

	for( hashidx = 0; hashidx < bt->mgr->latchmgr->latchhash; hashidx++ ) {
	  if( idx = bt->mgr->latchmgr->table[hashidx].slot ) do {
		set->latch = bt->mgr->latchsets + idx;
		if( set->latch->hash != hashidx )
			fprintf(stderr, "latchset %d wrong hashidx\n", idx);
		if( set->latch->pin )
			fprintf(stderr, "latchset %d pinned for page %.8x\n", idx, set->latch->page_no);
	  } while( idx = set->latch->next );
	}

	next = bt->mgr->latchmgr->nlatchpage + LATCH_page;
	page_no = LEAF_page;

	while( page_no < bt_getid(bt->mgr->latchmgr->alloc->right) ) {
		pread (bt->mgr->idx, bt->frame, bt->mgr->page_size, page_no << bt->mgr->page_bits);
		if( !bt->frame->free )
		 for( idx = 0; idx++ < bt->frame->cnt - 1; ) {
		  ptr = keyptr(bt->frame, idx+1);
		  if( keycmp (keyptr(bt->frame, idx), ptr->key, ptr->len) >= 0 )
			fprintf(stderr, "page %.8x idx %.2x out of order\n", page_no, idx);
		 }

		if( page_no > LEAF_page )
			next = page_no + 1;
		page_no = next;
	}

	  	do {
			if( set->pool = bt_pinpool (bt, page_no) )
				set->page = bt_page (bt, set->pool, page_no);
			else
				break;
			set->latch = bt_pinlatch (bt, page_no);
			bt_lockpage (BtLockRead, set->latch);
			next = bt_getid (set->page->right);
			cnt += set->page->act;

			for( slot = 0; slot++ < set->page->cnt; )
			 if( next || slot < set->page->cnt )
			  if( !slotptr(set->page, slot)->dead ) {
				ptr = keyptr(set->page, slot);
				fwrite (ptr->key, ptr->len, 1, stdout);
				fputc ('\n', stdout);
			  }

			bt_unlockpage (BtLockRead, set->latch);
			bt_unpinlatch (set->latch);
			bt_unpinpool (set->pool);
	  	} while( page_no = next );

	for( idx = 0; idx < cnt; idx++ ) {
		args[idx].infile = argv[idx + 7];
		args[idx].type = argv[2][0];
		args[idx].mgr = mgr;
		args[idx].num = num;
		args[idx].idx = idx;
#ifdef unix
		if( err = pthread_create (threads + idx, NULL, index_file, args + idx) )
			fprintf(stderr, "Error creating thread %d\n", err);
#else
		threads[idx] = (HANDLE)_beginthreadex(NULL, 65536, index_file, args + idx, 0, NULL);
#endif
	}

	// 	wait for termination

#ifdef unix
	for( idx = 0; idx < cnt; idx++ )
		pthread_join (threads[idx], NULL);
#else
	WaitForMultipleObjects (cnt, threads, TRUE, INFINITE);

	for( idx = 0; idx < cnt; idx++ )
		CloseHandle(threads[idx]);


  do {
	//	obtain latch mutex
#ifdef unix
	if( __sync_lock_test_and_set(latch->mutex, 1) )
		continue;
#else
	if( _InterlockedExchange8(latch->mutex, 1) )
		continue;
#endif
	//  see if exclusive request is granted or pending

	if( prev = !(latch->exclusive | latch->pending) )
		latch->share++;

#ifdef unix
	__sync_lock_release (latch->mutex);
#else
	_InterlockedExchange8(latch->mutex, 0);
#endif

	if( prev )
		return;

#ifdef  unix
  } while( sched_yield(), 1 );
#else
  } while( SwitchToThread(), 1 );
#endif

  do {
#ifdef  unix
	if( __sync_lock_test_and_set(latch->mutex, 1) )
		continue;
#else
	if( _InterlockedExchange8(latch->mutex, 1) )
		continue;
#endif
	if( prev = !(latch->share | latch->exclusive) )
		latch->exclusive = 1, latch->pending = 0;
	else
		latch->pending = 1;
#ifdef unix
	__sync_lock_release (latch->mutex);
#else
	_InterlockedExchange8(latch->mutex, 0);
#endif
	if( prev )
		return;
#ifdef  unix
  } while( sched_yield(), 1 );
#else
  } while( SwitchToThread(), 1 );
#endif


#ifdef unix
	while( __sync_lock_test_and_set(latch->mutex, 1) )
		sched_yield();
#else
	while( _InterlockedExchange8(latch->mutex, 1) )
		SwitchToThread();


#ifdef unix
	while( __sync_lock_test_and_set(latch->mutex, 1) )
		sched_yield();
#else
	while( _InterlockedExchange8(latch->mutex, 1) )
		SwitchToThread();


ushort slot, avail = 0, victim, idx;
BtLatchSet *set;

  //  try to find existing latch table entry for this page

	//  obtain read lock on hash table entry

	bt_spinreadlock(bt->mgr->latchmgr->table[hashidx].latch);

	if( slot = bt->mgr->latchmgr->table[hashidx].slot ) do
	{
		set = bt->mgr->latchsets + slot;
		if( page_no == set->page_no )
			break;
	} while( slot = set->next );


  bt_spinwritelock(bt->mgr->latchmgr->table[hashidx].latch);

  if( slot = bt->mgr->latchmgr->table[hashidx].slot ) do
  {
	set = bt->mgr->latchsets + slot;
	if( page_no == set->page_no )
		break;
	if( !set->pin && !avail )
		avail = slot;
  } while( slot = set->next );

#ifdef unix
	victim = __sync_fetch_and_add (&bt->mgr->latchmgr->latchdeployed, -1);
#else
	victim = _InterlockedDecrement16 (&bt->mgr->latchmgr->latchdeployed);
#endif
  //  find and reuse previous lock entry

  while( 1 ) {
#ifdef unix
	victim = __sync_fetch_and_add(&bt->mgr->latchmgr->latchvictim, 1);
#else
	victim = _InterlockedIncrement16 (&bt->mgr->latchmgr->latchvictim) - 1;
#endif
	//	we don't use slot zero

	if( victim %= bt->mgr->latchmgr->latchtotal )
		set = bt->mgr->latchsets + victim;
	else
		continue;

	//	take control of our slot
	//	from other threads

	if( set->pin || !bt_spinwritetry (set->busy) )
		continue;

	idx = set->hash;

	// try to get write lock on hash chain
	//	skip entry if not obtained
	//	or has outstanding locks

	if( !bt_spinwritetry (bt->mgr->latchmgr->table[idx].latch) ) {
		bt_spinreleasewrite (set->busy);
		continue;
	}

	if( set->pin ) {
		bt_spinreleasewrite (set->busy);
		bt_spinreleasewrite (bt->mgr->latchmgr->table[idx].latch);
		continue;
	}

	//  unlink our available victim from its hash chain

	if( set->prev )
		bt->mgr->latchsets[set->prev].next = set->next;
	else
		bt->mgr->latchmgr->table[idx].slot = set->next;

	if( set->next )
		bt->mgr->latchsets[set->next].prev = set->prev;

	bt_spinreleasewrite (bt->mgr->latchmgr->table[idx].latch);
#ifdef unix
	__sync_fetch_and_add(&set->pin, 1);
#else
	_InterlockedIncrement16 (&set->pin);
#endif
	bt_latchlink (bt, hashidx, victim, page_no);
	bt_spinreleasewrite (bt->mgr->latchmgr->table[hashidx].latch);
	bt_spinreleasewrite (set->busy);
	return set;
  }


	mgr->seg_bits = 0;

	while( (1 << mgr->seg_bits) <= mgr->poolmask )
		mgr->seg_bits++;


	memset(latchmgr, 0, mgr->page_size);
	last = MIN_lvl + 1;

	while( last <= ((MIN_lvl + 1 + nlatchpage) | mgr->poolmask) ) {
#ifdef unix
		pwrite(mgr->idx, latchmgr, mgr->page_size, last << mgr->page_bits);
#else
		SetFilePointer (mgr->idx, last << mgr->page_bits, NULL, FILE_BEGIN);
		if( !WriteFile (mgr->idx, (char *)latchmgr, mgr->page_size, amt, NULL) )
			return bt_mgrclose (mgr), NULL;
		if( *amt < mgr->page_size )
			return bt_mgrclose (mgr), NULL;
#endif
		last++;
	}


	page_no &= ~bt->mgr->poolmask;

	while( pool->basepage != page_no )
	  if( pool = pool->hashnext )
		continue;
	  else
		return NULL;

#ifdef unix
	__sync_fetch_and_add(&bt->mgr->poolcnt, -1);
#else
	_InterlockedDecrement16 (&bt->mgr->poolcnt);
#endif

	while( 1 ) {
#ifdef unix
		victim = __sync_fetch_and_add(&bt->mgr->evicted, 1);
#else
		victim = _InterlockedIncrement (&bt->mgr->evicted) - 1;
#endif
		victim %= bt->mgr->poolmax;
		pool = bt->mgr->pool + victim;
		idx = (uint)(pool->basepage >> bt->mgr->seg_bits) % bt->mgr->hashsize;

		if( !victim )
			continue;

		// try to get write lock
		//	skip entry if not obtained

		if( !bt_spinwritetry (&bt->mgr->latch[idx]) )
			continue;

		//	skip this entry if
		//	page is pinned
		//  or clock bit is set

		if( pool->pin ) {
#ifdef unix
			__sync_fetch_and_and(&pool->pin, ~CLOCK_bit);
#else
			_InterlockedAnd16 (&pool->pin, ~CLOCK_bit);
#endif
			bt_spinreleasewrite (&bt->mgr->latch[idx]);
			continue;
		}

		// unlink victim pool node from hash table

		if( node = pool->hashprev )
			node->hashnext = pool->hashnext;
		else if( node = pool->hashnext )
			bt->mgr->hash[idx] = node->slot;
		else
			bt->mgr->hash[idx] = 0;

		if( node = pool->hashnext )
			node->hashprev = pool->hashprev;

		bt_spinreleasewrite (&bt->mgr->latch[idx]);

		//	remove old file mapping
#ifdef unix
		munmap (pool->map, (bt->mgr->poolmask+1) << bt->mgr->page_bits);
#else
		FlushViewOfFile(pool->map, 0);
		UnmapViewOfFile(pool->map);
		CloseHandle(pool->hmap);
#endif
		pool->map = NULL;

		//  create new pool mapping
		//  and link into hash table

		if( bt_mapsegment(bt, pool, page_no) )
			return NULL;

		bt_linkhash(bt, pool, page_no, hashidx);
		bt_spinreleasewrite (&bt->mgr->latch[hashidx]);
		return pool;
	}


uint diff, higher = set->page->cnt, low = 1, slot;
uint good = 0;

	//	  make stopper key an infinite fence value

	if( bt_getid (set->page->right) )
		higher++;
	else
		good++;

	//	low is the lowest candidate.
	//  loop ends when they meet

	//  higher is already
	//	tested as .ge. the passed key.

	while( diff = higher - low ) {
		slot = low + ( diff >> 1 );
		if( keycmp (keyptr(set->page, slot), key, len) < 0 )
			low = slot + 1;
		else
			higher = slot, good++;
	}


  do {
	// determine lock mode of drill level
	mode = (drill == lvl) ? lock : BtLockRead; 

	set->latch = bt_pinlatch (bt, page_no);
	set->page_no = page_no;

	// pin page contents

	if( set->pool = bt_pinpool (bt, page_no) )
		set->page = bt_page (bt, set->pool, page_no);
	else
		return 0;

 	// obtain access lock using lock chaining with Access mode

	if( page_no > ROOT_page )
	  bt_lockpage(BtLockAccess, set->latch);

	//	release & unpin parent page

	if( prevpage ) {
	  bt_unlockpage(prevmode, prevlatch);
	  bt_unpinlatch (prevlatch);
	  bt_unpinpool (prevpool);
	  prevpage = 0;
	}

 	// obtain read lock using lock chaining

	bt_lockpage(mode, set->latch);

	if( set->page->free )
		return bt->err = BTERR_struct, 0;

	if( page_no > ROOT_page )
	  bt_unlockpage(BtLockAccess, set->latch);

	// re-read and re-lock root after determining actual level of root

	if( set->page->lvl != drill) {
		if( set->page_no != ROOT_page )
			return bt->err = BTERR_struct, 0;
			
		drill = set->page->lvl;

		if( lock != BtLockRead && drill == lvl ) {
		  bt_unlockpage(mode, set->latch);
		  bt_unpinlatch (set->latch);
		  bt_unpinpool (set->pool);
		  continue;
		}
	}

	prevpage = set->page_no;
	prevlatch = set->latch;
	prevpool = set->pool;
	prevmode = mode;

	//  find key on page at this level
	//  and descend to requested level

	if( !set->page->kill )
	 if( slot = bt_findslot (set, key, len) ) {
	  if( drill == lvl )
		return slot;

	  while( slotptr(set->page, slot)->dead )
		if( slot++ < set->page->cnt )
			continue;
		else
			goto slideright;

	  page_no = bt_getid(slotptr(set->page, slot)->id);
	  drill--;
	  continue;
	 }

	//  or slide right into next page

slideright:
	page_no = bt_getid(set->page->right);

  } while( page_no );

		while( idx = set->page->cnt - 1 )
		  if( slotptr(set->page, idx)->dead ) {
			*slotptr(set->page, idx) = *slotptr(set->page, idx + 1);
			memset (slotptr(set->page, set->page->cnt--), 0, sizeof(BtSlot));
		  } else
			break;
	memset (page+1, 0, bt->mgr->page_size - sizeof(*page));
	page->dirty = 0;
	page->act = 0;

	// try cleaning up page first
	// by removing deleted keys

	while( cnt++ < max ) {
		if( cnt == slot )
			newslot = idx + 1;
		if( cnt < max && slotptr(bt->frame,cnt)->dead )
			continue;

		// copy the key across

		key = keyptr(bt->frame, cnt);
		nxt -= key->len + 1;
		memcpy ((unsigned char *)page + nxt, key, key->len + 1);

		// copy slot

		memcpy(slotptr(page, ++idx)->id, slotptr(bt->frame, cnt)->id, BtId);
		if( !(slotptr(page, idx)->dead = slotptr(bt->frame, cnt)->dead) )
			page->act++;
		slotptr(page, idx)->tod = slotptr(bt->frame, cnt)->tod;
		slotptr(page, idx)->off = nxt;
	}

	memset (bt->frame, 0, bt->mgr->page_size);
	max = set->page->cnt;
	cnt = max / 2;
	idx = 0;

	while( cnt++ < max ) {
		key = keyptr(set->page, cnt);
		nxt -= key->len + 1;
		memcpy ((unsigned char *)bt->frame + nxt, key, key->len + 1);

		memcpy(slotptr(bt->frame,++idx)->id, slotptr(set->page,cnt)->id, BtId);
		if( !(slotptr(bt->frame, idx)->dead = slotptr(set->page, cnt)->dead) )
			bt->frame->act++;
		slotptr(bt->frame, idx)->tod = slotptr(set->page, cnt)->tod;
		slotptr(bt->frame, idx)->off = nxt;
	}


	memcpy (bt->frame, set->page, bt->mgr->page_size);
	memset (set->page+1, 0, bt->mgr->page_size - sizeof(*set->page));
	nxt = bt->mgr->page_size;
	set->page->dirty = 0;
	set->page->act = 0;
	cnt = 0;
	idx = 0;

	//  assemble page of smaller keys

	while( cnt++ < max / 2 ) {
		key = keyptr(bt->frame, cnt);
		nxt -= key->len + 1;
		memcpy ((unsigned char *)set->page + nxt, key, key->len + 1);
		memcpy(slotptr(set->page,++idx)->id, slotptr(bt->frame,cnt)->id, BtId);
		slotptr(set->page, idx)->tod = slotptr(bt->frame, cnt)->tod;
		slotptr(set->page, idx)->off = nxt;
		set->page->act++;
	}


uint slot, idx;
BtKey ptr;

	while( 1 ) {
		if( slot = bt_loadpage (bt, set, key, len, lvl, BtLockWrite) )
			ptr = keyptr(set->page, slot);
		else
		{
			if( !bt->err )
				bt->err = BTERR_ovflw;
			return bt->err;
		}

		// if key already exists, update id and return

		if( !keycmp (ptr, key, len) ) {
			if( slotptr(set->page, slot)->dead )
				set->page->act++;
			slotptr(set->page, slot)->dead = 0;
			slotptr(set->page, slot)->tod = tod;
			bt_putid(slotptr(set->page,slot)->id, id);
			bt_unlockpage(BtLockWrite, set->latch);
			bt_unpinlatch (set->latch);
			bt_unpinpool (set->pool);
			return 0;
		}

		// check if page has enough space

 		if( slot = bt_cleanpage (bt, set->page, len, slot) )
			break;

		if( bt_splitpage (bt, set) )
			return bt->err;
	}

	set->page->act++;

	while( idx > slot )
		*slotptr(set->page, idx) = *slotptr(set->page, idx -1), idx--;


  do {
	right = bt_getid(bt->cursor->right);

	while( slot++ < bt->cursor->cnt )
	  if( slotptr(bt->cursor,slot)->dead )
		continue;
	  else if( right || (slot < bt->cursor->cnt) ) // skip infinite stopper
		return slot;
	  else
		break;

	if( !right )
		break;

	bt->cursor_page = right;

	if( set->pool = bt_pinpool (bt, right) )
		set->page = bt_page (bt, set->pool, right);
	else
		return 0;

	set->latch = bt_pinlatch (bt, right);
    bt_lockpage(BtLockRead, set->latch);

	memcpy (bt->cursor, set->page, bt->mgr->page_size);

	bt_unlockpage(BtLockRead, set->latch);
	bt_unpinlatch (set->latch);
	bt_unpinpool (set->pool);
	slot = 0;

  } while( 1 );

	while( page_no < bt_getid(bt->mgr->latchmgr->alloc->right) ) {
		pread (bt->mgr->idx, bt->frame, bt->mgr->page_size, page_no << bt->mgr->page_bits);
		if( !bt->frame->free )
		 for( idx = 0; idx++ < bt->frame->cnt - 1; ) {
		  ptr = keyptr(bt->frame, idx+1);
		  if( keycmp (keyptr(bt->frame, idx), ptr->key, ptr->len) >= 0 )
			fprintf(stderr, "page %.8x idx %.2x out of order\n", page_no, idx);
		 }

		if( page_no > LEAF_page )
			next = page_no + 1;
		page_no = next;
	}

		  while( ch = getc(in), ch != EOF )
			if( ch == '\n' )
			{
			  line++;

			  if( args->num == 1 )
		  		sprintf((char *)key+len, "%.9d", 1000000000 - line), len += 9;

			  else if( args->num )
		  		sprintf((char *)key+len, "%.9d", line + args->idx * args->num), len += 9;

			  if( bt_insertkey (bt, key, len, 0, line, *tod) )
				fprintf(stderr, "Error %d Line: %d\n", bt->err, line), exit(0);
			  len = 0;
			}
			else if( len < 255 )
				key[len++] = ch;

		  while( ch = getc(in), ch != EOF )
			if( ch == '\n' )
			{
			  line++;
			  if( args->num == 1 )
		  		sprintf((char *)key+len, "%.9d", 1000000000 - line), len += 9;

			  else if( args->num )
		  		sprintf((char *)key+len, "%.9d", line + args->idx * args->num), len += 9;

			  if( bt_deletekey (bt, key, len, 0) )
				fprintf(stderr, "Error %d Line: %d\n", bt->err, line), exit(0);
			  len = 0;
			}
			else if( len < 255 )
				key[len++] = ch;
		fprintf(stderr, "finished %s for keys, %d \n", args->infile, line);

		  while( ch = getc(in), ch != EOF )
			if( ch == '\n' )
			{
			  line++;
			  if( args->num == 1 )
		  		sprintf((char *)key+len, "%.9d", 1000000000 - line), len += 9;

			  else if( args->num )
		  		sprintf((char *)key+len, "%.9d", line + args->idx * args->num), len += 9;

			  if( bt_findkey (bt, key, len) )
				found++;
			  else if( bt->err )
				fprintf(stderr, "Error %d Syserr %d Line: %d\n", bt->err, errno, line), exit(0);
			  len = 0;
			}
			else if( len < 255 )
				key[len++] = ch;

		next = bt->mgr->latchmgr->nlatchpage + LATCH_page;
		page_no = LEAF_page;

		while( page_no < bt_getid(bt->mgr->latchmgr->alloc->right) ) {
		uid off = page_no << bt->mgr->page_bits;
#ifdef unix
		  pread (bt->mgr->idx, bt->frame, bt->mgr->page_size, off);
#else
		DWORD amt[1];

		  SetFilePointer (bt->mgr->idx, (long)off, (long*)(&off)+1, FILE_BEGIN);

		  if( !ReadFile(bt->mgr->idx, bt->frame, bt->mgr->page_size, amt, NULL))
			return bt->err = BTERR_map;

		  if( *amt <  bt->mgr->page_size )
			return bt->err = BTERR_map;
#endif
			if( !bt->frame->free && !bt->frame->lvl )
				cnt += bt->frame->act;
			if( page_no > LEAF_page )
				next = page_no + 1;
			page_no = next;
		}
