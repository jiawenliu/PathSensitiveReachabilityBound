
#line 34
  i = 0;
#line 34
  while (i < linecount) {
#line 35
    tmp___5 = strncmp((char const   *)*(lines + i), "Set-Cookie: ", (size_t )12);
#line 35
    if (tmp___5 == 0) {
#line 37
      tmp___1 = strlen((char const   *)*(lines + i));
#line 37
      tmp___2 = substr(*(lines + i), 12, tmp___1 - 13UL);
#line 37
      cookiedata = tmp___2;
#line 39
      split((char *)"; ", cookiedata, & cookie);
#line 40
      free((void *)cookiedata);
#line 41
      tmp___3 = strncmp((char const   *)*(cookie + 0), "Y=", (size_t )2);
#line 41
      if (tmp___3 == 0) {
#line 42
        part1 = *(cookie + 0);
      }
#line 43
      tmp___4 = strncmp((char const   *)*(cookie + 0), "T=", (size_t )2);
#line 43
      if (tmp___4 == 0) {
#line 44
        part2 = *(cookie + 0);
      }
#line 45
      free((void *)cookie);
    }
#line 34
    i ++;
  }
#line 59
  while (1) {
#line 61
    tmp = malloc(16UL * sizeof(char ));
#line 61
    header = (char *)tmp;
#line 65
    tmp___0 = (int )read(socket___0, header, 16);
#line 65
    if (tmp___0 == 0) {
#line 67
      break;
    }
#line 68
    tmp___1 = substr(header, 14, (size_t )2);
#line 68
    tmp___2 = strint(tmp___1, 2);
#line 68
    len = tmp___2;
#line 69
    tmp___3 = malloc((unsigned long )(len + 1) * sizeof(char ));
#line 69
    content = (char *)tmp___3;
#line 70
    bzero((void *)content, (size_t )(len + 1));
#line 71
    tmp___4 = malloc((unsigned long )(len + 1) * sizeof(char ));
#line 71
    part = (char *)tmp___4;
#line 75
    c___0 = (int )read(socket___0, content, len);
#line 77
    while (c___0 < len) {
#line 79
      bzero((void *)part, (size_t )(len + 1));
#line 83
      tmp___5 = (int )read(socket___0, part, len - c___0);
#line 83
      c___0 += tmp___5;
#line 85
      tmp___6 = strlen((char const   *)part);
#line 85
      strncat((char * __restrict  )content, (char const   * __restrict  )part, tmp___6);
    }
#line 87
    free((void *)part);
#line 88
    tmp___7 = substr(header, 10, (size_t )2);
#line 88
    tmp___8 = strint(tmp___7, 2);
#line 88
    yrecvd(tmp___8, content, len);
#line 89
    free((void *)header);
#line 90
    free((void *)content);
  }


#line 1048
  __result = (size_t )0;
#line 1050
  while ((int const   )*(__s + __result) == (int const   )__accept) {
#line 1051
    __result ++;
  }


#line 1060
  __result = (size_t )0;
#line 1062
  while (1) {
#line 1062
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1062
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1062
        break;
      }
    }
#line 1063
    __result ++;
  }

#line 1072
  __result = (size_t )0;
#line 1074
  while (1) {
#line 1074
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1074
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1074
        if (! ((int const   )*(__s + __result) == (int const   )__accept3)) {
#line 1074
          break;
        }
      }
    }
#line 1076
    __result ++;
  }


#line 1126
  while (1) {
#line 1126
    if ((int const   )*__s != 0) {
#line 1126
      if ((int const   )*__s != (int const   )__accept1) {
#line 1126
        if (! ((int const   )*__s != (int const   )__accept2)) {
#line 1126
          break;
        }
      } else {
#line 1126
        break;
      }
    } else {
#line 1126
      break;
    }
#line 1127
    __s ++;
  }

#line 1137
  while (1) {
#line 1137
    if ((int const   )*__s != 0) {
#line 1137
      if ((int const   )*__s != (int const   )__accept1) {
#line 1137
        if ((int const   )*__s != (int const   )__accept2) {
#line 1137
          if (! ((int const   )*__s != (int const   )__accept3)) {
#line 1137
            break;
          }
        } else {
#line 1137
          break;
        }
      } else {
#line 1137
        break;
      }
    } else {
#line 1137
      break;
    }
#line 1139
    __s ++;
  }

  {
#line 1175
  if ((unsigned long )__s == (unsigned long )((void *)0)) {
#line 1176
    __s = *__nextp;
  }
#line 1177
  while ((int )*__s == (int )__sep) {
#line 1178
    __s ++;
  }
#line 1179
  __result = (char *)((void *)0);
#line 1180
  if ((int )*__s != 0) {
#line 1182
    tmp___0 = __s;
#line 1182
    __s ++;
#line 1182
    __result = tmp___0;
#line 1183
    while ((int )*__s != 0) {
#line 1184
      tmp___1 = __s;
#line 1184
      __s ++;
#line 1184
      if ((int )*tmp___1 == (int )__sep) {
#line 1186
        *(__s + -1) = (char )'\000';
#line 1187
        break;
      }
    }
#line 1238
    while (1) {
#line 1240
      if ((int )*__cp == 0) {
#line 1242
        __cp = (char *)((void *)0);
#line 1243
        break;
      }
#line 1245
      if ((int )*__cp == (int )__reject1) {
#line 1247
        tmp___0 = __cp;
#line 1247
        __cp ++;
#line 1247
        *tmp___0 = (char )'\000';
#line 1248
        break;
      } else
#line 1245
      if ((int )*__cp == (int )__reject2) {
#line 1247
        tmp___0 = __cp;
#line 1247
        __cp ++;
#line 1247
        *tmp___0 = (char )'\000';
#line 1248
        break;
      }
#line 1250
      __cp ++;
    }


#line 1265
    __cp = __retval;
#line 1266
    while (1) {
#line 1268
      if ((int )*__cp == 0) {
#line 1270
        __cp = (char *)((void *)0);
#line 1271
        break;
      }
#line 1273
      if ((int )*__cp == (int )__reject1) {
#line 1275
        tmp___0 = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp___0 = (char )'\000';
#line 1276
        break;
      } else
#line 1273
      if ((int )*__cp == (int )__reject2) {
#line 1275
        tmp___0 = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp___0 = (char )'\000';
#line 1276
        break;
      } else
#line 1273
      if ((int )*__cp == (int )__reject3) {
#line 1275
        tmp___0 = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp___0 = (char )'\000';
#line 1276
        break;
      }
#line 1278
      __cp ++;
    }


#line 102
  while (tries < 10) {
#line 103
    state = ustomp_get_state(conn);
#line 104
    if (state != 128) {
#line 106
      tmp___0 = ustomp_state_desc(state);
#line 106
      printf((char const   * __restrict  )"test does stuff! woohoo! (state = %s)\n",
             tmp___0);
#line 107
      sleep(1U);
    } else {
#line 109
      printf((char const   * __restrict  )"okay, we\'re set!\n");
#line 110
      return (0);
    }
#line 102
    tries ++;
  }


#line 139
  i = 0;
#line 139
  while (i < 5000) {
#line 140
    tmp___1 = ustomp_send_time(conn, message, size);
#line 140
    consumed_time_send += tmp___1;
#line 141
    usleep((__useconds_t )100);
#line 139
    i ++;
  }



#line 165
  i = 0;
#line 165
  while (i < 1000) {
#line 166
    tmp___1 = ustomp_send_time(conn, message, size);
#line 166
    consumed_time_send += tmp___1;
#line 167
    usleep((__useconds_t )100);
#line 165
    i ++;
  }



#line 218
    i = 1;
#line 218
    while (i <= 51200) {
#line 219
      ustomp_message_test(conn, 2023 * i);
#line 218
      i *= 4;
    }
#line 221
    puts("sending messages");
#line 222
    i = 0;
#line 222
    while (i <= 530) {
#line 223
      ustomp_message_test(conn, 512 + i);
#line 222
      i ++;
    }


#line 248
  while (1) {
#line 248
    if (*t_readerPos == buf->writer) {
#line 248
      if (! (! g_stopthread)) {
#line 248
        break;
      }
    } else {
#line 248
      break;
    }
#line 249
    pthread_cond_wait((pthread_cond_t * __restrict  )(& buf->buf_con), (pthread_mutex_t * __restrict  )(& buf->buf_mutex));
#line 250
    *t_writerPos = buf->writer;
  }


#line 268
  pthread_mutex_lock(& buf->buf_mutex);
#line 269
  while (1) {
#line 269
    if ((unsigned long )*p == (unsigned long )(buf->buffer + buf->writer)) {
#line 269
      if (! (! g_stopthread)) {
#line 269
        break;
      }
    } else {
#line 269
      break;
    }
#line 270
    pthread_cond_wait((pthread_cond_t * __restrict  )(& buf->buf_con), (pthread_mutex_t * __restrict  )(& buf->buf_mutex));
#line 271
    *t_writerPos = buf->writer;
  }


#line 320
  flags = 0;
#line 328
  while (1) {
#line 328
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.__fds_bits[0]): "memory");
#line 328
    break;
  }


#line 360
  while (1) {
#line 360
    tmp___5 = bufferUsage(writer, reader, buffer->size);
#line 360
    if (! (tmp___5 < 90)) {
#line 360
      break;
    }
#line 361
    if (writer < reader) {
#line 361
      maxlen = (int )((reader - writer) - 1U);
    } else {
#line 361
      maxlen = (int )(buffer->size - writer);
    }
#line 362
    if (maxlen == 0) {
#line 364
      return (-3);
    }
#line 367
    tmp___3 = recv(sockfd, (void *)(buffer->buffer + writer), (size_t )maxlen, flags);
#line 367
    result = (int )tmp___3;
#line 368
    if (result > 0) {
#line 369
      flags = 64;
#line 370
      writer = (writer + (uint32 )result) % buffer->size;
#line 371
      *(buffer->buffer + writer) = (char )'\000';
#line 372
      pthread_mutex_lock(& buffer->buf_mutex);
#line 373
      buffer->writer = writer;
#line 375
      reader = buffer->reader;
#line 376
      pthread_cond_signal(& buffer->buf_con);
#line 377
      pthread_mutex_unlock(& buffer->buf_mutex);
    } else
#line 378
    if (result == -1) {
#line 378
      tmp___4 = __errno_location();
#line 378
      if (*tmp___4 == 11) {
#line 381
        return (-2);
      } else {
#line 378
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 382
    if (result == 0) {
#line 384
      return (0);
    } else {
#line 387
      return (-1);
    }
  }


#line 414
  *headerEnd = (char )'\000';
#line 415
  while (1) {
#line 415
    if ((int )*readH_key != 10) {
#line 415
      if (! ((int )*readH_key != 0)) {
#line 415
        break;
      }
    } else {
#line 415
      break;
    }
#line 416
    if ((int )*readH_key == 58) {
#line 417
      *readH_key = (char )'\000';
#line 418
      end_of_key = readH_key;
#line 419
      incBufferPointer(& readH_key, & writer, buffer);
#line 420
      readH_value = readH_key;
#line 420
      while (1) {
#line 421
        if ((int )*readH_value == 0) {
#line 422
          if ((unsigned long )start < (unsigned long )headerEnd) {
#line 422
            if ((unsigned long )readH_key < (unsigned long )headerEnd) {
#line 423
              treeDictInsertString(headers, (char const   *)start, (char const   *)readH_key);
            } else {
#line 422
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 426
            key_length = (uint32 )(((readH_key - start) + (long )buffer->size) % (long )buffer->size + 1L);
#line 427
            value_length = (uint32 )(((headerEnd - readH_key) + (long )buffer->size) % (long )buffer->size + 1L);
#line 428
            tmp___0 = malloc((size_t )(key_length + 1U));
#line 428
            key = (char *)tmp___0;
#line 429
            tmp___1 = malloc((size_t )(value_length + 1U));
#line 429
            value = (char *)tmp___1;
#line 430
            copyFromBuffer(key, start, key_length, buffer);
#line 431
            copyFromBuffer(value, readH_key, value_length, buffer);
#line 432
            treeDictInsertString(headers, (char const   *)key, (char const   *)value);
#line 433
            free((void *)key);
#line 434
            free((void *)value);
          }
#line 440
          *end_of_key = (char )':';
#line 441
          *headerEnd = (char )'\n';
#line 442
          return (1);
        }
#line 420
        incBufferPointer(& readH_value, & writer, buffer);
      }
    }
#line 415
    incBufferPointer(& readH_key, & writer, buffer);
  }



#line 462
  if (m) {
#line 466
    pthread_mutex_lock(& buffer->buf_mutex);
#line 467
    writerPos = buffer->writer;
#line 468
    readerPos = buffer->reader;
#line 469
    while (1) {
#line 469
      if (writerPos == readerPos) {
#line 469
        if (! (! g_stopthread)) {
#line 469
          break;
        }
      } else {
#line 469
        break;
      }
#line 471
      pthread_cond_wait((pthread_cond_t * __restrict  )(& buffer->buf_con), (pthread_mutex_t * __restrict  )(& buffer->buf_mutex));
#line 472
      writerPos = buffer->writer;
    }



#line 476
    start = p;
#line 484
    while ((int )*p != 10) {
#line 485
      if ((int )*p == 0) {
#line 488
        return ((ustomp_message *)((void *)0));
      }
#line 484
      p = stepThroughBuffer(& readerPos, & writerPos, buffer);
    }



while(1){

#line 501
      if ((int )*p == 0) {
#line 504
        return ((ustomp_message *)((void *)0));
      } else
#line 505
      if ((int )*p == 10) {
#line 508
        tmp___0 = __parse_header(start, p, m->headers, buffer);
#line 508
        if (! tmp___0) {
#line 511
          return ((ustomp_message *)((void *)0));
        }
#line 513
        p = stepThroughBuffer(& readerPos, & writerPos, buffer);
#line 514
        if ((int )*p == 10) {
#line 516
          tmp___1 = (char *)((void *)0);
#line 517
          p = stepThroughBuffer(& readerPos, & writerPos, buffer);
#line 517
          start = p;
#line 520
          tmp___2 = treeDictGet(m->headers, "content-length");
#line 520
          tmp___1 = (char *)tmp___2;
#line 521
          if (tmp___1) {
#line 522
            i = (uint32 )0;
#line 523
            tmp___3 = atoi((char const   *)tmp___1);
#line 523
            mlen = (int )tmp___3;
#line 525
            t = 0;
#line 526
            tmp___4 = realloc((void *)m->body, (size_t )((mlen - mlen % 16) + 32));
#line 526
            m->body = (char *)tmp___4;
#line 527
            while (i <= (uint32 )mlen) {
#line 530
              p = stepThroughBuffer(& readerPos, & writerPos, buffer);
#line 531
              if (i % 512U == 511U) {
#line 532
                copyFromBuffer(m->body + t, start, (uint32 )512, buffer);
#line 533
                t += 512;
#line 534
                start = p;
              }
#line 527
              i ++;
            }
#line 537
            m->body_length = (size_t )mlen;
#line 538
            restOfB = mlen - t;
#line 539
            if (restOfB > 0) {
#line 540
              copyFromBuffer(m->body + t, start, (uint32 )restOfB, buffer);
            }
          } else {
#line 545
            while ((int )*p != 0) {
#line 545
              p = stepThroughBuffer(& readerPos, & writerPos, buffer);
            }
#line 546
            m->body_length = ((uintp )p - (uintp )start) % (unsigned long )buffer->size;
#line 547
            tmp___5 = realloc((void *)m->body, (m->body_length - m->body_length % 16UL) + 32UL);
#line 547
            m->body = (char *)tmp___5;
#line 548
            copyFromBuffer(m->body, start, (uint32 )m->body_length, buffer);
          }
#line 552
          readerPos = (readerPos + 1U) % buffer->size;
#line 553
          p = buffer->buffer + readerPos;
#line 560
          if ((int )*p == 10) {
#line 561
            readerPos = (readerPos + 1U) % buffer->size;
          }
#line 564
          pthread_mutex_lock(& buffer->buf_mutex);
#line 566
          buffer->reader = readerPos;
#line 567
          pthread_mutex_unlock(& buffer->buf_mutex);
#line 575
          return (m);
        }
#line 577
        start = p;
      }
#line 499
      p = stepThroughBuffer(& readerPos, & writerPos, buffer);
    }














#line 595
  while (! g_stopthread) {
#line 596
    pthread_mutex_lock(& c->_mutex);
#line 597
    switch (c->state) {
    case 4096: 
#line 600
    g_stopthread = (int volatile   )-1;
#line 601
    break;
    case 2: 
#line 608
    if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 609
      addr = c->servinfo;
    } else {
#line 611
      addr = addr->ai_next;
    }
#line 613
    if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 614
      c->state = 1;
#line 615
      ustomp_notify(c, 32768, (void *)"no valid address found", (void *)0, (void *)0);
#line 616
      ustomp_error("no valid address found");
#line 617
      break;
    }
#line 621
    tmp___0 = socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);
#line 621
    c->sockfd = tmp___0;
#line 621
    if (tmp___0 == -1) {
#line 622
      ustomp_notify(c, 32768, (void *)"failed to create socket", (void *)0, (void *)0);
#line 623
      ustomp_error("socket");
#line 624
      break;
    }
#line 627
    c->state = 4;
#line 628
    tmp___1 = get_in_addr(addr->ai_addr);
#line 628
    inet_ntop(addr->ai_family, (void const   * __restrict  )tmp___1, (char * __restrict  )(s),
              (socklen_t )sizeof(s));
#line 629
    ustomp_notify(c, 1, (void *)(s), (void *)0, (void *)0);
#line 630
    tmp___2 = connect(c->sockfd, (struct sockaddr  const  *)addr->ai_addr, addr->ai_addrlen);
#line 630
    if (tmp___2 == -1) {
#line 631
      close(c->sockfd);
#line 632
      ustomp_notify(c, 32768, (void *)"failed to connect", (void *)0, (void *)0);
#line 633
      ustomp_error("connect");
#line 635
      c->state = 2;
#line 636
      break;
    }
#line 638
    c->state = 8;
#line 639
    break;
    case 8: 
#line 644
    headers = (RBtree *)((void *)0);
#line 646
    tmp___3 = get_in_addr(addr->ai_addr);
#line 646
    inet_ntop(addr->ai_family, (void const   * __restrict  )tmp___3, (char * __restrict  )(s___0),
              (socklen_t )sizeof(s___0));
#line 647
    ustomp_notify(c, 2, (void *)(s___0), (void *)0, (void *)0);
#line 650
    headers = treeCreate();
#line 652
    ustomp_send_frame_connect(c, headers);
#line 653
    treeDestroy(& headers, 1);
#line 655
    c->state = 64;
#line 656
    c->wait_state = 16;
#line 658
    break;
    case 16: 
#line 662
    if (c->do_subscribe) {
#line 662
      if (c->topic) {
#line 663
        c->state = 32;
      } else {
#line 665
        c->state = 128;
      }
    } else {
#line 665
      c->state = 128;
    }
#line 667
    break;
    case 32: 
#line 672
    c->state = 128;
#line 673
    if (c->do_subscribe) {
#line 673
      if (c->topic) {
#line 674
        headers___0 = treeCreate();
#line 675
        treeDictInsertString(headers___0, "destination", (char const   *)c->topic);
#line 677
        ustomp_send_frame_subscribe(c, headers___0);
#line 678
        treeDestroy(& headers___0, 1);
      }
    }
#line 680
    ustomp_notify(c, 8, (void *)c->topic, (void *)0, (void *)0);
#line 682
    break;
    case 256: 
#line 685
    headers___1 = (RBtree *)((void *)0);
#line 689
    if (c->topic) {
#line 690
      headers___1 = treeCreate();
#line 691
      treeDictInsertString(headers___1, "destination", (char const   *)c->topic);
#line 693
      ustomp_send_frame_unsubscribe(c, headers___1);
#line 694
      treeDestroy(& headers___1, 1);
    }
#line 697
    headers___1 = treeCreate();
#line 698
    ustomp_send_frame_disconnect(c, headers___1);
#line 699
    treeDestroy(& headers___1, 1);
#line 701
    close(c->sockfd);
#line 702
    c->sockfd = -1;
#line 703
    c->state = 1;
#line 704
    ustomp_notify(c, 4096, (void *)"disconnected", (void *)0, (void *)0);
#line 705
    break;
    }
#line 711
    if (c->sockfd != -1) {
#line 712
      pthread_mutex_unlock(& c->_mutex);
#line 713
      result = ustomp_recv(c, 3, 100);
#line 716
      if (result == -3) {
#line 718
        usleep((__useconds_t )300);
      } else
#line 721
      if (result == -1) {
#line 722
        if (g_stopthread) {
#line 723
          break;
        }
#line 725
        pthread_mutex_lock(& c->_mutex);
#line 726
        ustomp_notify(c, 32768, (void *)"error while receiving data", (void *)0, (void *)0);
#line 727
        pthread_mutex_unlock(& c->_mutex);
#line 728
        errorcount ++;
#line 730
        if (errorcount > 10) {
#line 732
          pthread_mutex_lock(& c->_mutex);
#line 733
          c->state = 1;
#line 734
          close(c->sockfd);
#line 735
          c->sockfd = -1;
#line 736
          ustomp_notify(c, 4096, (void *)"repeated read error - reset connection",
                        (void *)0, (void *)0);
#line 737
          pthread_mutex_unlock(& c->_mutex);
        }
#line 740
        usleep((__useconds_t )500);
      } else
#line 741
      if (result == 0) {
#line 742
        pthread_mutex_lock(& c->_mutex);
#line 743
        c->state = 1;
#line 744
        c->sockfd = -1;
#line 745
        ustomp_notify(c, 4096, (void *)"connection reset by peer", (void *)0, (void *)0);
#line 746
        pthread_mutex_unlock(& c->_mutex);
      } else
#line 747
      if (result > 0) {
#line 750
        errorcount = 0;
      } else {
#line 767
        usleep((__useconds_t )100);
      }
    } else {
#line 771
      pthread_mutex_unlock(& c->_mutex);
    }
  }



#line 848
    _port[0] = (char)0;
#line 848
    tmp___1 = 1U;
#line 848
    while (! (tmp___1 >= 8U)) {
#line 848
      _port[tmp___1] = (char)0;
#line 848
      tmp___1 ++;
    }


#line 1094
  result = 0;
#line 1096
  while (sent < *len) {
#line 1097
    tmp___0 = send(sockfd, (void const   *)(buf + sent), (size_t )left, 0);
#line 1097
    result = (int )tmp___0;
#line 1098
    if (result == -1) {
#line 1099
      break;
    } else
#line 1100
    if (! (result == 0)) {
#line 1103
      sent += result;
#line 1104
      left -= result;
    }
  }


#line 1198
  buffer[0] = (char)0;
#line 1198
  tmp___0 = 1U;
#line 1198
  while (! (tmp___0 >= 65536U)) {
#line 1198
    buffer[tmp___0] = (char)0;
#line 1198
    tmp___0 ++;
  }


#line 1288
  while (1) {
#line 1289
    tmp___0 = __builtin_va_arg(args, char *);
#line 1289
    key = tmp___0;
#line 1290
    if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 1291
      break;
    }
#line 1292
    tmp___1 = __builtin_va_arg(args, char *);
#line 1292
    val = tmp___1;
#line 1293
    if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 1294
      if ((unsigned long )*headers != (unsigned long )((void *)0)) {
#line 1295
        dictDestroy(headers, 1);
#line 1296
        result = -1;
      }
#line 1298
      break;
    }
#line 1301
    if ((unsigned long )*headers == (unsigned long )((void *)0)) {
#line 1302
      *headers = treeCreate();
    }
#line 1303
    treeDictInsertString(*headers, (char const   *)key, (char const   *)val);
  }


#line 1327
  m.command[0] = (char )'C';
#line 1327
  m.command[1] = (char )'O';
#line 1327
  m.command[2] = (char )'N';
#line 1327
  m.command[3] = (char )'N';
#line 1327
  m.command[4] = (char )'E';
#line 1327
  m.command[5] = (char )'C';
#line 1327
  m.command[6] = (char )'T';
#line 1327
  m.command[7] = (char )'\000';
#line 1327
  tmp___0 = 8U;
#line 1327
  while (! (tmp___0 >= 16U)) {
#line 1327
    m.command[tmp___0] = (char)0;
#line 1327
    tmp___0 ++;
  }
#line 1327
  m.headers = (RBtree *)((void *)0);
#line 1327
  m.body = (char *)"";
#line 1327
  m.body_length = (size_t )0;



#line 1342
  m.command[0] = (char )'D';
#line 1342
  m.command[1] = (char )'I';
#line 1342
  m.command[2] = (char )'S';
#line 1342
  m.command[3] = (char )'C';
#line 1342
  m.command[4] = (char )'O';
#line 1342
  m.command[5] = (char )'N';
#line 1342
  m.command[6] = (char )'N';
#line 1342
  m.command[7] = (char )'E';
#line 1342
  m.command[8] = (char )'C';
#line 1342
  m.command[9] = (char )'T';
#line 1342
  m.command[10] = (char )'\000';
#line 1342
  tmp___0 = 11U;
#line 1342
  while (! (tmp___0 >= 16U)) {
#line 1342
    m.command[tmp___0] = (char)0;
#line 1342
    tmp___0 ++;
  }
#line 1342
  m.headers = (RBtree *)((void *)0);
#line 1342
  m.body = (char *)"";
#line 1342
  m.body_length = (size_t )0;


#line 1357
  tmp___0 = 10U;
#line 1357
  while (! (tmp___0 >= 16U)) {
#line 1357
    m.command[tmp___0] = (char)0;
#line 1357
    tmp___0 ++;
  }

#line 1376
  tmp___0 = 12U;
#line 1376
  while (! (tmp___0 >= 16U)) {
#line 1376
    m.command[tmp___0] = (char)0;
#line 1376
    tmp___0 ++;
  }

#line 1395
  tmp___0 = 4U;
#line 1395
  while (! (tmp___0 >= 16U)) {
#line 1395
    m.command[tmp___0] = (char)0;
#line 1395
    tmp___0 ++;
  }

#line 223
  node = tree->root;
#line 225
  while (node) {
#line 227
    if (node->key == key) {
#line 228
      return (node->data);
    }
#line 230
    node = node->link[node->key < key];
  }

#line 403
    fmt[0] = (char)0;
#line 403
    tmp___0 = 1U;
#line 403
    while (! (tmp___0 >= 64U)) {
#line 403
      fmt[tmp___0] = (char)0;
#line 403
      tmp___0 ++;
    }
#line 404
    snprintf((char * __restrict  )(fmt), (size_t )64, (char const   * __restrict  )"[%s] ",
             "0x%016lx");
#line 405
    fprintf((FILE * __restrict  )fd, (char const   * __restrict  )(fmt), (uintp )node);
#line 410
    while (i < level) {
#line 411
      fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"  ");
#line 410
      i ++;
    }

#line 513
    while (1) {
#line 515
      if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 518
        q = MakeNode(key, data);
#line 519
        p->link[dir] = q;
#line 521
        if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 522
          free((void *)head);
#line 523
          return (0);
        }
      } else {
#line 528
        t1___0 = q->link[0];
#line 529
        t2 = q->link[1];
#line 530
        tmp___2 = is_red(t1___0);
#line 530
        if (tmp___2) {
#line 530
          tmp___3 = is_red(t2);
#line 530
          if (tmp___3) {
#line 532
            q->red = 1;
#line 533
            t1___0->red = 0;
#line 534
            t2->red = 0;
          }
        }
      }
#line 539
      tmp___6 = is_red(q);
#line 539
      if (tmp___6) {
#line 539
        tmp___7 = is_red(p);
#line 539
        if (tmp___7) {
#line 541
          dir2 = (unsigned long )t->link[1] == (unsigned long )g;
#line 543
          if ((unsigned long )q == (unsigned long )p->link[last]) {
#line 547
            tmp___4 = treeRotate(g, ! last);
#line 547
            t1___1 = tmp___4;
#line 548
            t->link[dir2] = t1___1;
          } else {
#line 554
            tmp___5 = treeDoubleRotate(g, ! last);
#line 554
            t1___2 = tmp___5;
#line 555
            t->link[dir2] = t1___2;
          }
        }
      }
#line 560
      if (q->key == key) {
#line 561
        break;
      }
#line 563
      last = dir;
#line 564
      dir = q->key < key;
#line 567
      if ((unsigned long )g != (unsigned long )((void *)0)) {
#line 568
        t = g;
      }
#line 570
      g = p;
#line 570
      p = q;
#line 571
      q = q->link[dir];
    }


#line 603
    t1 = tree->root;
#line 604
    q->link[1] = t1;
#line 607
    while (1) {
#line 609
      t1___0 = q->link[dir];
#line 612
      if (! t1___0) {
#line 613
        break;
      }
#line 615
      last = dir;
#line 618
      g = p;
#line 618
      p = q;
#line 619
      q = t1___0;
#line 620
      dir = q->key < key;
#line 623
      if (q->key == key) {
#line 624
        found = q;
      }
#line 627
      tmp___10 = is_red(q);
#line 627
      if (! tmp___10) {
#line 627
        tmp___11 = is_red(q->link[dir]);
#line 627
        if (! tmp___11) {
#line 629
          tmp___9 = is_red(q->link[! dir]);
#line 629
          if (tmp___9) {
#line 633
            tmp___1 = treeRotate(q, dir);
#line 633
            t2 = tmp___1;
#line 634
            p->link[last] = t2;
#line 635
            p = t2;
          } else {
#line 637
            tmp___8 = is_red(q->link[! dir]);
#line 637
            if (! tmp___8) {
#line 638
              s = p->link[! last];
#line 640
              if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 642
                tmp___6 = is_red(s->link[! last]);
#line 642
                if (tmp___6) {
                  _L: /* CIL Label */ 
#line 652
                  dir2 = (unsigned long )g->link[1] == (unsigned long )p;
#line 654
                  tmp___5 = is_red(s->link[last]);
#line 654
                  if (tmp___5) {
#line 658
                    tmp___2 = treeDoubleRotate(p, last);
#line 658
                    t3 = tmp___2;
#line 659
                    g->link[dir2] = t3;
                  } else {
#line 661
                    tmp___4 = is_red(s->link[! last]);
#line 661
                    if (tmp___4) {
#line 665
                      tmp___3 = treeRotate(p, last);
#line 665
                      t3___0 = tmp___3;
#line 666
                      g->link[dir2] = t3___0;
                    }
                  }
#line 670
                  q->red = 1;
#line 671
                  (g->link[dir2])->red = 1;
#line 672
                  v1 = g->link[dir2];
#line 674
                  (v1->link[0])->red = 0;
#line 675
                  (v1->link[1])->red = 0;
                } else {
#line 642
                  tmp___7 = is_red(s->link[last]);
#line 642
                  if (tmp___7) {
#line 642
                    goto _L;
                  } else {
#line 645
                    p->red = 0;
#line 646
                    s->red = 1;
#line 647
                    q->red = 1;
                  }
                }
              }
            }
          }
        }
      }
    }


#line 184
  while (length > 3UL) {
#line 186
    a += (uint32_t )*(k + 0);
#line 187
    b += (uint32_t )*(k + 1);
#line 188
    c += (uint32_t )*(k + 2);
#line 189
    a -= c;
#line 189
    a ^= (c << 4) | (c >> 28);
#line 189
    c += b;
#line 189
    b -= a;
#line 189
    b ^= (a << 6) | (a >> 26);
#line 189
    a += c;
#line 189
    c -= b;
#line 189
    c ^= (b << 8) | (b >> 24);
#line 189
    b += a;
#line 189
    a -= c;
#line 189
    a ^= (c << 16) | (c >> 16);
#line 189
    c += b;
#line 189
    b -= a;
#line 189
    b ^= (a << 19) | (a >> 13);
#line 189
    a += c;
#line 189
    c -= b;
#line 189
    c ^= (b << 4) | (b >> 28);
#line 189
    b += a;
#line 190
    length -= 3UL;
#line 191
    k += 3;
  }


#line 226
  c = (3735928559U + (uint32_t )(length << 2)) + *pc;
#line 226
  b = c;
#line 226
  a = b;
#line 227
  c += *pb;
#line 230
  while (length > 3UL) {
#line 232
    a += (uint32_t )*(k + 0);
#line 233
    b += (uint32_t )*(k + 1);
#line 234
    c += (uint32_t )*(k + 2);
#line 235
    a -= c;
#line 235
    a ^= (c << 4) | (c >> 28);
#line 235
    c += b;
#line 235
    b -= a;
#line 235
    b ^= (a << 6) | (a >> 26);
#line 235
    a += c;
#line 235
    c -= b;
#line 235
    c ^= (b << 8) | (b >> 24);
#line 235
    b += a;
#line 235
    a -= c;
#line 235
    a ^= (c << 16) | (c >> 16);
#line 235
    c += b;
#line 235
    b -= a;
#line 235
    b ^= (a << 19) | (a >> 13);
#line 235
    a += c;
#line 235
    c -= b;
#line 235
    c ^= (b << 4) | (b >> 28);
#line 235
    b += a;
#line 236
    length -= 3UL;
#line 237
    k += 3;
  }


#line 99
  i = 0;
#line 99
  while ((unsigned int )i < len) {
#line 101
    fprintf((FILE * __restrict  )f, (char const   * __restrict  )"0x%08lx   ", (unsigned long )ptr - base);
#line 102
    j = 0;
#line 102
    while ((unsigned int )j < width) {
#line 103
      setColor(f, ptr, j, base);
#line 105
      if ((unsigned int )(i + j) < len) {
#line 106
        if ((unsigned int )j % columnwidth == columnwidth - 1U) {
#line 106
          tmp___0 = " ";
        } else {
#line 106
          tmp___0 = "";
        }
#line 106
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%02X %s", (int )*(ptr + j),
                tmp___0);
      } else {
#line 108
        if ((unsigned int )j % columnwidth == columnwidth - 1U) {
#line 108
          tmp___1 = " ";
        } else {
#line 108
          tmp___1 = "";
        }
#line 108
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"   %s", tmp___1);
      }
#line 110
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\033[0m");
#line 102
      j ++;
    }
#line 112
    fprintf((FILE * __restrict  )f, (char const   * __restrict  )" ");
#line 113
    j = 0;
#line 113
    while ((unsigned int )j < width) {
#line 114
      setColor(f, ptr, j, base);
#line 116
      if ((unsigned int )(i + j) < len) {
#line 117
        if ((unsigned int )j % columnwidth == columnwidth - 1U) {
#line 117
          tmp___2 = " ";
        } else {
#line 117
          tmp___2 = "";
        }
#line 117
        tmp___3 = printableHex(*(ptr + j));
#line 117
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%c%s", (int )tmp___3,
                tmp___2);
      } else {
#line 119
        if ((unsigned int )j % columnwidth == columnwidth - 1U) {
#line 119
          tmp___4 = " ";
        } else {
#line 119
          tmp___4 = "";
        }
#line 119
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )" %s", tmp___4);
      }
#line 121
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\033[0m");
#line 113
      j ++;
    }
#line 124
    if (twice != 0) {
#line 126
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"    0x%08lx   ",
              ((unsigned long )ptr - base) + (unsigned long )len);
#line 127
      j = 0;
#line 127
      while ((unsigned int )j < width) {
#line 128
        setColor(f, ptr, (int )((unsigned int )j + len), base);
#line 130
        if ((unsigned int )(i + j) + len < (unsigned int )frontier) {
#line 131
          if (((unsigned int )j + len) % columnwidth == columnwidth - 1U) {
#line 131
            tmp___5 = " ";
          } else {
#line 131
            tmp___5 = "";
          }
#line 131
          fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%02X %s",
                  (int )*(ptr + ((unsigned int )j + len)), tmp___5);
        } else {
#line 133
          if (((unsigned int )j + len) % columnwidth == columnwidth - 1U) {
#line 133
            tmp___6 = " ";
          } else {
#line 133
            tmp___6 = "";
          }
#line 133
          fprintf((FILE * __restrict  )f, (char const   * __restrict  )"   %s", tmp___6);
        }
#line 135
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\033[0m");
#line 127
        j ++;
      }
#line 137
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )" ");
#line 138
      j = 0;
#line 138
      while ((unsigned int )j < width) {
#line 139
        setColor(f, ptr, (int )((unsigned int )j + len), base);
#line 141
        if ((unsigned int )(i + j) + len < (unsigned int )frontier) {
#line 142
          if (((unsigned int )j + len) % columnwidth == columnwidth - 1U) {
#line 142
            tmp___7 = " ";
          } else {
#line 142
            tmp___7 = "";
          }
#line 142
          tmp___8 = printableHex(*(ptr + ((unsigned int )j + len)));
#line 142
          fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%c%s", (int )tmp___8,
                  tmp___7);
        }
#line 144
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\033[0m");
#line 138
        j ++;
      }
    }
#line 147
    fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 99
    i = (int )((unsigned int )i + width);
#line 99
    ptr += width;
  }
