#line 972
  __result = (size_t )0;
#line 973
  while (1) {
#line 973
    if ((int const   )*(__s + __result) != 0) {
#line 973
      if (! ((int const   )*(__s + __result) != (int const   )__reject)) {
#line 973
        break;
      }
    } else {
#line 973
      break;
    }
#line 974
    __result ++;
  }
  __result = (size_t )0;
#line 997
  while (1) {
#line 997
    if ((int const   )*(__s + __result) != 0) {
#line 997
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 997
        if ((int const   )*(__s + __result) != (int const   )__reject2) {
#line 997
          if (! ((int const   )*(__s + __result) != (int const   )__reject3)) {
#line 997
            break;
          }
        } else {
#line 997
          break;
        }
      } else {
#line 997
        break;
      }
    } else {
#line 997
      break;
    }
#line 999
    __result ++;
  }


#line 1048
  __result = (size_t )0;
#line 1050
  while ((int const   )*(__s + __result) == (int const   )__accept) {
#line 1051
    __result ++;
  }


#line 1060
  __result = (size_t )0;
#line 1062
  while (1) {
#line 1062
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1062
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1062
        break;
      }
    }
#line 1063
    __result ++;
  }




#line 1072
  __result = (size_t )0;
#line 1074
  while (1) {
#line 1074
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1074
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1074
        if (! ((int const   )*(__s + __result) == (int const   )__accept3)) {
#line 1074
          break;
        }
      }
    }
#line 1076
    __result ++;
  }


#line 1126
  while (1) {
#line 1126
    if ((int const   )*__s != 0) {
#line 1126
      if ((int const   )*__s != (int const   )__accept1) {
#line 1126
        if (! ((int const   )*__s != (int const   )__accept2)) {
#line 1126
          break;
        }
      } else {
#line 1126
        break;
      }
    } else {
#line 1126
      break;
    }
#line 1127
    __s ++;
  }


    __s = *__nextp;
  }
#line 1177
  while ((int )*__s == (int )__sep) {
#line 1178
    __s ++;
  }




    __result = tmp;
#line 1183
    while ((int )*__s != 0) {
#line 1184
      tmp___0 = __s;
#line 1184
      __s ++;
#line 1184
      if ((int )*tmp___0 == (int )__sep) {
#line 1186
        *(__s + -1) = (char )'\000';
#line 1187
        break;
      }
    }





#line 1238
    while (1) {
#line 1240
      if ((int )*__cp == 0) {
#line 1242
        __cp = (char *)((void *)0);
#line 1243
        break;
      }
#line 1245
      if ((int )*__cp == (int )__reject1) {
#line 1247
        tmp = __cp;
#line 1247
        __cp ++;
#line 1247
        *tmp = (char )'\000';
#line 1248
        break;
      } else
#line 1245
      if ((int )*__cp == (int )__reject2) {
#line 1247
        tmp = __cp;
#line 1247
        __cp ++;
#line 1247
        *tmp = (char )'\000';
#line 1248
        break;
      }
#line 1250
      __cp ++;
    }



#line 1265
    __cp = __retval;
#line 1266
    while (1) {
#line 1268
      if ((int )*__cp == 0) {
#line 1270
        __cp = (char *)((void *)0);
#line 1271
        break;
      }
#line 1273
      if ((int )*__cp == (int )__reject1) {
#line 1275
        tmp = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp = (char )'\000';
#line 1276
        break;
      } else
#line 1273
      if ((int )*__cp == (int )__reject2) {
#line 1275
        tmp = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp = (char )'\000';
#line 1276
        break;
      } else
#line 1273
      if ((int )*__cp == (int )__reject3) {
#line 1275
        tmp = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp = (char )'\000';
#line 1276
        break;
      }
#line 1278
      __cp ++;
    }


#line 27
  while (1) {
#line 27
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rfds.__fds_bits[0]): "memory");
#line 27
    break;
  }


#line 371
  while (1) {
#line 372
    tmp___0 = realloc((void *)*str, 11UL * sizeof(char ) + i * sizeof(char ));
#line 372
    str_tmp = (char *)tmp___0;
#line 374
    if ((unsigned long )str_tmp == (unsigned long )((void *)0)) {
#line 375
      return (-2);
    } else {
#line 377
      *str = str_tmp;
    }
#line 379
    chunk_use = 0U;
#line 381
    while (1) {
#line 381
      if (done == 0) {
#line 381
        if (chunk_use < 10U) {
#line 381
          if (! (rev != -1)) {
#line 381
            break;
          }
        } else {
#line 381
          break;
        }
      } else {
#line 381
        break;
      }
#line 382
      if (oz_readmax > 0U) {
#line 382
        if (readbytes >= oz_readmax) {
#line 383
          done = 1;
        }
      }
#line 385
      tmp___1 = read(*sockfd, (void *)(& buf), sizeof(char ));
#line 385
      rev = (int )tmp___1;
#line 385
      readbytes += (unsigned int )rev;
#line 387
      switch (rev) {
      case 0: 
#line 389
      rev = -1;
#line 390
      break;
      }
#line 393
      if ((int )buf == (int )endchr) {
#line 393
        if (rev != -1) {
#line 394
          done = 1;
        } else {
#line 393
          goto _L;
        }
      } else
      _L: 
#line 396
      if (rev != -1) {
#line 397
        strncat((char * __restrict  )*str, (char const   * __restrict  )(& buf), (size_t )1);
      }
#line 399
      i ++;
#line 400
      chunk_use ++;
    }
#line 371
    if (done == 0) {
#line 371
      if (! (rev != -1)) {
#line 371
        break;
      }
    } else {
#line 371
      break;
    }
  }





#line 504
    tmp_hostinfo = hostinfo;
#line 506
    while (1) {
#line 507
      *sockfd = socket(tmp_hostinfo->ai_family, tmp_hostinfo->ai_socktype, 0);
#line 509
      if (*sockfd == -1) {
#line 510
        goto __Cont;
      }
#line 512
      rev = connect(*sockfd, (struct sockaddr  const  *)tmp_hostinfo->ai_addr, tmp_hostinfo->ai_addrlen);
#line 514
      if (rev == -1) {
#line 514
        if (safe_errno == 0) {
#line 515
          tmp = __errno_location();
#line 515
          safe_errno = *tmp;
        }
      }
#line 517
      if (rev == -1) {
#line 518
        close(*sockfd);
#line 520
        if ((unsigned long )tmp_hostinfo->ai_next == (unsigned long )((void *)0)) {
#line 521
          break;
        } else {
#line 524
          tmp_hostinfo = tmp_hostinfo->ai_next;
        }
      }
      __Cont: 
#line 506
      if (! (rev == -1)) {
#line 506
        break;
      }
    }



#line 637
  tmp_hostinfo = hostinfo;
#line 639
  while (1) {
#line 640
    tmp = sendto(*sockfd, (void const   *)buf, buf_size, 0, (struct sockaddr  const  *)tmp_hostinfo->ai_addr,
                 tmp_hostinfo->ai_addrlen);
#line 640
    rev = (int )tmp;
#line 642
    if (rev > 0) {
#line 643
      rev = 0;
    }
#line 639
    if (rev != 0) {
#line 639
      tmp_hostinfo = tmp_hostinfo->ai_next;
#line 639
      if (! ((unsigned long )tmp_hostinfo != (unsigned long )((void *)0))) {
#line 639
        break;
      }
    } else {
#line 639
      break;
    }
  }



#line 148
  while (*txt) {
#line 149
    txt ++;
  }




#line 151
  i = (size_t )0;
#line 151
  while (i < 5UL) {
#line 152
    if ((int )*txt == 10) {
#line 153
      *txt = (char )'\000';
    } else
#line 154
    if ((int )*txt == 13) {
#line 155
      *txt = (char )'\000';
    }
#line 157
    txt --;
#line 151
    i ++;
  }



#line 175
  while (*str) {
#line 176
    if ((int const   )*str >= 48) {
#line 176
      if (! ((int const   )*str <= 57)) {
#line 177
        return (-1);
      }
    } else {
#line 177
      return (-1);
    }
#line 179
    str ++;
  }



#line 200
  i = (size_t )0;
#line 203
  while (1) {
#line 203
    chr = fgetc(f);
#line 203
    if (! (chr != -1)) {
#line 203
      break;
    }
#line 204
    if (chr == 10) {
#line 205
      i ++;
    }
  }



  i = (size_t )0;
#line 247
  while (i < txt_len) {
#line 248
    if ((int const   )*(txt + i) == 32) {
#line 249
      spaces ++;
    }
#line 247
    i ++;
  }


#line 270
  i = (size_t )0;
#line 270
  while (i < txt_len) {
#line 271
    if ((int const   )*(txt + i) == 32) {
#line 272
      msg_len = (size_t )10;
#line 273
      msg_use = (size_t )0;
#line 274
      counter ++;
#line 276
      tmp___1 = malloc(msg_len * sizeof(char ));
#line 276
      bluff = (char *)tmp___1;
#line 278
      if ((unsigned long )bluff == (unsigned long )((void *)0)) {
#line 279
        return ((char **)((void *)0));
      }
#line 281
      memset((void *)bluff, '\000', msg_len * sizeof(char ));
#line 282
      *(msg + counter) = bluff;
#line 284
      goto __Cont;
    }
#line 287
    if (! (msg_len < msg_use)) {
#line 288
      msg_len += 10UL;
#line 290
      tmp___2 = realloc((void *)*(msg + counter), msg_len * sizeof(char ));
#line 290
      bluff = (char *)tmp___2;
#line 292
      if ((unsigned long )bluff == (unsigned long )((void *)0)) {
#line 293
        return ((char **)((void *)0));
      }
#line 295
      *(msg + counter) = bluff;
    }
#line 298
    strncat((char * __restrict  )*(msg + counter), (char const   * __restrict  )(txt + i),
            (size_t )1);
#line 299
    msg_use ++;
    __Cont: 
#line 270
    i ++;
  }




#line 323
  i = (size_t )0;
#line 325
  while (*msg) {
#line 326
    free((void *)*msg);
#line 327
    msg ++;
#line 328
    i ++;
  }


#line 384
  i = 0;
#line 384
  while (i < 6) {
#line 386
    if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 387
      break;
    } else
#line 386
    if ((int )*q == 0) {
#line 387
      break;
    }
#line 389
    p = q;
#line 392
    tmp___1 = __builtin_strchr(q, ':');
#line 392
    q = tmp___1;
#line 392
    if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 393
      tmp = q;
#line 393
      q ++;
#line 393
      *tmp = (char )'\000';
    }
#line 396
    tmp___2 = strstr((char const   *)p, "0x");
#line 396
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 397
      snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"0x%s",
               p);
    } else {
#line 400
      snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%s",
               p);
    }
#line 403
    tmp___3 = strtod((char const   * __restrict  )(buf), (char ** __restrict  )((void *)0));
#line 403
    *(macstorage + i) = (int )tmp___3;
#line 384
    i ++;
  }




#line 432
  i = 0;
#line 432
  while (i < 6) {
#line 434
    if (i == 4) {
#line 435
      retpos = 0;
    }
#line 438
    x = 0;
#line 438
    while (x < 8) {
#line 439
      if (mac[i] & (1 << x)) {
#line 440
        if (i <= 3) {
#line 441
          ret[0] |= 1 << retpos;
        } else {
#line 443
          ret[1] |= 1 << retpos;
        }
      }
#line 438
      x ++;
#line 438
      retpos ++;
    }
#line 432
    i ++;
  }




#line 480
  i = 0;
#line 480
  while (i < 48) {
#line 481
    c = 0;
#line 483
    x = 0;
#line 483
    while (1) {
#line 483
      if (x < 8) {
#line 483
        if (! (i < 48)) {
#line 483
          break;
        }
      } else {
#line 483
        break;
      }
#line 484
      if (i < 32) {
#line 484
        if (ret[0] & (1 << i)) {
#line 485
          c |= 1 << x;
        } else {
#line 484
          goto _L;
        }
      } else
      _L: 
#line 487
      if (i >= 32) {
#line 487
        if (ret[1] & (1 << i)) {
#line 488
          c |= 1 << x;
        }
      }
#line 483
      x ++;
#line 483
      i ++;
    }
#line 492
    tmp = strlen((char const   *)macbuf);
#line 492
    tmp___0 = strlen((char const   *)macbuf);
#line 492
    snprintf((char * __restrict  )(macbuf + tmp___0), macbuf_size - tmp * sizeof(char ),
             (char const   * __restrict  )"%.2X:", c);
  }



#line 169
  while (1) {
#line 169
    x = z;
#line 169
    if (! ((unsigned long )x != (unsigned long )((void *)0))) {
#line 169
      break;
    }
#line 170
    z = z->next;
#line 171
    i = 0U;
#line 173
    if ((unsigned long )x->key != (unsigned long )((void *)0)) {
#line 174
      free((void *)x->key);
    }
#line 176
    while (1) {
#line 176
      if (x->param_use > 0U) {
#line 176
        if (! (i < x->param_use)) {
#line 176
          break;
        }
      } else {
#line 176
        break;
      }
#line 177
      free((void *)*(x->param + i));
#line 178
      i ++;
    }
#line 181
    free((void *)x);
  }



#line 235
  while (i < *buffer_len) {
#line 236
    *(buffer + i) = (char )'\000';
#line 235
    i ++;
  }



#line 272
  while (1) {
#line 272
    tmp___7 = feof(f);
#line 272
    if (tmp___7) {
#line 272
      break;
    }
#line 273
    chr = fgetc(f);
#line 275
    if (chr == 10) {
#line 277
      if (have_key == 0U) {
#line 278
        tmp___0 = oz_confsetkey(x, buffer);
#line 278
        if (tmp___0 == -2) {
#line 279
          return (-2);
        }
      } else
#line 282
      if (have_key == 1U) {
#line 283
        tmp___1 = oz_confnewsub(x, buffer);
#line 283
        if (tmp___1 == -2) {
#line 284
          return (-2);
        }
      }
#line 287
      tmp___2 = line_no;
#line 287
      line_no ++;
#line 287
      x->line_no = tmp___2;
#line 288
      x = oz_confnewnode(x);
#line 290
      if ((unsigned long )x == (unsigned long )((void *)0)) {
#line 291
        return (-2);
      }
#line 293
      have_key = 0U;
#line 295
      buffer = buffer_reset(buffer, & buffer_len, & buffer_use);
#line 295
      if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 296
        return (-2);
      }
#line 298
      continue;
    } else
#line 301
    if (chr == 35) {
#line 302
      while (1) {
#line 302
        tmp___3 = feof(f);
#line 302
        if (tmp___3) {
#line 302
          break;
        } else
#line 302
        if (! (chr != 10)) {
#line 302
          break;
        }
#line 303
        chr = fgetc(f);
      }
#line 306
      line_no ++;
    } else
#line 310
    if (chr == 32) {
#line 310
      if (have_key == 0U) {
#line 311
        have_key = 1U;
#line 313
        tmp___4 = oz_confsetkey(x, buffer);
#line 313
        if (tmp___4 == -2) {
#line 314
          return (-2);
        }
#line 316
        buffer = buffer_reset(buffer, & buffer_len, & buffer_use);
#line 316
        if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 317
          return (-2);
        }
#line 319
        continue;
      } else {
#line 310
        goto _L___0;
      }
    } else
    _L___0: 
#line 323
    if (chr == 32) {
#line 323
      if (have_key == 1U) {
#line 324
        tmp___5 = oz_confnewsub(x, buffer);
#line 324
        if (tmp___5 == -2) {
#line 325
          return (-2);
        }
#line 327
        buffer = buffer_reset(buffer, & buffer_len, & buffer_use);
#line 327
        if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 328
          return (-2);
        }
#line 330
        continue;
      } else {
#line 323
        goto _L;
      }
    } else {
      _L: 
#line 334
      if (buffer_use > 2U) {
#line 334
        if (buffer_use == buffer_len - 2U) {
#line 335
          buffer = buffer_enlarge(buffer, & buffer_len);
#line 335
          if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 336
            return (-2);
          }
        }
      }
#line 339
      tmp___6 = buffer_use;
#line 339
      buffer_use ++;
#line 339
      *(buffer + tmp___6) = (char )chr;
    }
  }


#line 29
    while (j > 256L) {
#line 30
      if (j < 1L) {
#line 31
        tmp___2 = oz_rand_myrand(f);
#line 31
        j = (long )tmp___2;
      } else {
#line 33
        j /= 2L;
      }
    }



#line 66
    while (1) {
#line 66
      if (number >= 65) {
#line 66
        if (number <= 90) {
#line 66
          break;
        } else {
#line 66
          goto _L;
        }
      } else
      _L: 
#line 66
      if (number >= 97) {
#line 66
        if (number <= 122) {
#line 66
          break;
        }
      }
#line 67
      if (number > 90) {
#line 68
        tmp = oz_rand_myrand(f);
#line 68
        number -= tmp;
      } else
#line 69
      if (number < 65) {
#line 70
        tmp___0 = oz_rand_myrand(f);
#line 70
        number += tmp___0;
      } else
#line 71
      if (number > 122) {
#line 72
        tmp___1 = oz_rand_myrand(f);
#line 72
        number -= tmp___1;
      } else
#line 73
      if (number < 97) {
#line 74
        tmp___2 = oz_rand_myrand(f);
#line 74
        number += tmp___2;
      }
    }



#line 74
  i = 0;
#line 76
  while (1) {
#line 76
    line = index((char const   *)line, ':');
#line 76
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 76
      break;
    }
#line 77
    line ++;
#line 78
    i ++;
  }



#line 275
  tmp = pi;
#line 275
  old = tmp;
#line 277
  while (1) {
#line 278
    tmp = tmp->pi_next;
#line 279
    free((void *)old);
#line 277
    old = tmp;
#line 277
    if (! ((unsigned long )old != (unsigned long )((void *)0))) {
#line 277
      break;
    }
  }



#line 153
  i = 0;
#line 153
  while (1) {
#line 154
    if (oz_errno_codes[i].error_code == (int const   )errorcode) {
#line 155
      return ((char *)oz_errno_codes[i].error_message);
    }
#line 157
    if (oz_errno_codes[i].error_code == 0) {
#line 158
      break;
    }
#line 153
    i ++;
  }



#line 97
  i = 0;
#line 97
  while (i < 100) {
#line 98
    threads[i].id = -1;
#line 97
    i ++;
  }
#line 100
  i = 0;
#line 100
  while (i < 50) {
#line 101
    memset((void *)(servers[i].address), '\000', sizeof(servers[i].address));
#line 102
    servers[i].port = 0;
#line 100
    i ++;
  }
#line 105
  i = 0;
#line 105
  while (i < 500) {
#line 106
    channels[i] = (char *)((void *)0);
#line 105
    i ++;
  }



#line 148
  i = 0;
#line 148
  while ((unsigned int )i < listen_socks_no) {
#line 149
    tmp___13 = oz_listen(& (listen_socks + i)->sockfd, 1, (int )(listen_socks + i)->port,
                         (char const   *)((listen_socks + i)->address));
#line 149
    if (tmp___13 == -1) {
#line 150
      tmp___11 = __errno_location();
#line 150
      tmp___12 = strerror(*tmp___11);
#line 150
      logit("Could not listen on address=%s:%i, error=%s.", (listen_socks + i)->address,
            (listen_socks + i)->port, tmp___12);
#line 151
      (listen_socks + i)->sockfd = -1;
    } else {
#line 155
      logit("SuperVixen listening on address=%s:%i.", (listen_socks + i)->address,
            (listen_socks + i)->port);
    }
#line 148
    i ++;
  }



#line 161
  while (1) {
#line 162
    new_fd = -2;
#line 164
    i = 0;
#line 164
    while ((unsigned int )i < listen_socks_no) {
#line 165
      if ((listen_socks + i)->sockfd == -1) {
#line 166
        goto __Cont;
      }
#line 168
      tmp___14 = oz_isdatawaiting(& (listen_socks + i)->sockfd);
#line 168
      if (tmp___14 == 1) {
#line 169
        new_fd = accept((listen_socks + i)->sockfd, (struct sockaddr * __restrict  )((void *)0),
                        (socklen_t * __restrict  )((void *)0));
#line 170
        break;
      }
      __Cont: /* CIL Label */ 
#line 164
      i ++;
    }
#line 174
    if (! (new_fd == -2)) {
#line 176
      if (new_fd == -1) {
#line 177
        tmp___15 = __errno_location();
#line 177
        tmp___16 = strerror(*tmp___15);
#line 177
        logit("Server: .. could not accept connection, error=%s.", tmp___16);
      } else {
#line 181
        logit("Server: Got connection ..");
#line 183
        i = thread_register(0);
#line 185
        if (i == -1) {
#line 187
          logit("Server: .. could not find free slot for new thread, error=Too many threads running!");
#line 188
          oz_writefl(& new_fd, ":%s 372 Anon :Too may clients are currently connected to this server, disconnecting!",
                     settings.hostname);
#line 189
          close(new_fd);
        } else {
#line 194
          threads[i].sockfd = new_fd;
#line 195
          rev = pthread_create((pthread_t * __restrict  )(& threads[i].thread), (pthread_attr_t const   * __restrict  )((void *)0),
                               (void *(*)(void * ))((void *)(& sp_handle_servconn)),
                               (void * __restrict  )(& threads[i]));
#line 197
          if (rev != 0) {
#line 199
            oz_writefl(& new_fd, ":%s 372 Anon: Unable to create thread.", settings.hostname);
#line 200
            tmp___17 = strerror(rev);
#line 200
            logit("Server: .. could not create a new thread, error=%s.", tmp___17);
#line 201
            close(new_fd);
#line 202
            thread_unregister(i);
          } else {
#line 206
            curconn ++;
          }
        }
      }
    }
#line 210
    sp_sleep();
  }



#line 218
  args = "vh";
#line 220
  while (1) {
#line 220
    flag = getopt((int )argc, (char * const  *)((char **)argv), args);
#line 220
    if (! (flag != -1)) {
#line 220
      break;
    }
#line 221
    switch (flag) {
    case 104: 
#line 223
    show_usage(*(argv + 0));
#line 224
    exit(0);
#line 225
    break;
    case 118: 
#line 228
    textout("This is SuperVixen version %s !", settings.version);
#line 229
    exit(0);
#line 230
    break;
    }
  }




#line 51
  while (1) {
#line 51
    if (sysrev == 0) {
#line 51
      if (authenticated == 0) {
#line 51
        tmp___8 = time((time_t *)((void *)0));
#line 51
        if (tmp___8 < connect_time + (time_t )settings.max_unauth_time) {
#line 51
          if (! (auth_tries < settings.max_auth_tries)) {
#line 51
            break;
          }
        } else {
#line 51
          break;
        }
      } else {
#line 51
        break;
      }
    } else {
#line 51
      break;
    }
#line 52
    data_waiting = oz_isdatawaiting(sockfd);
#line 55
    if (data_waiting == 0) {
#line 56
      sp_sleep();
#line 57
      continue;
    } else
#line 61
    if (data_waiting != 1) {
#line 62
      sysrev = -1;
#line 63
      break;
    }
#line 66
    sysrev = oz_read(sockfd, & buf, (char const   )'\n');
#line 69
    if (sysrev == 0) {
#line 69
      tmp___7 = strn_comp((char const   *)buf, "PASS ");
#line 69
      if (tmp___7 == 0UL) {
#line 70
        rev = sp_verifyuser((char const   *)buf);
#line 72
        if (rev == 1) {
#line 73
          authenticated = 1;
#line 74
          logit("Server: Sucessfully authenticated client!");
#line 76
          tmp___2 = oz_writefl(sockfd, ":%s 372 %s :Login correct. Welcome... ", settings.hostname,
                               settings.nickname);
#line 76
          sysrev -= tmp___2;
#line 77
          tmp___3 = oz_writefl(sockfd, ":%s 372 %s :Your host is SuperVixen, faking version 2.10.3p3 of IRCd.",
                               settings.hostname, settings.nickname);
#line 77
          sysrev -= tmp___3;
#line 79
          tmp___4 = sp_lcache_fetch(sockfd);
#line 79
          sysrev -= tmp___4;
#line 80
          queue_add_globalmessage(1, thread->id, "MOTD");
#line 82
          cache_spitchannels(thread->id, sockfd);
        } else
#line 85
        if (rev == 0) {
#line 86
          logit("Server: .. authentication failure!");
#line 87
          tmp___5 = oz_writefl(sockfd, ":%s 372 Anon :Login incorrect!", settings.hostname);
#line 87
          sysrev -= tmp___5;
        }
#line 90
        auth_tries ++;
      } else {
#line 69
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 93
    if (sysrev == 0) {
#line 93
      tmp___6 = strn_comp((char const   *)buf, "QUIT");
#line 93
      if (tmp___6 == 0UL) {
#line 94
        break;
      }
    }
  }


#line 102
    tmp___9 = queue_fetchmessages(thread->id, sockfd);
#line 102
    sysrev -= tmp___9;
#line 105
    while (1) {
#line 105
      tmp___10 = commands_fetch(thread->id, & command);
#line 105
      if (! (tmp___10 == 0)) {
#line 105
        break;
      }
#line 106
      logit("Server: Got a command through the command-queue, but we don\'t support it! to=%i, from=%i.",
            command.id, command.from);
    }



  atfound = 0;
#line 96
  markfound = 0;
#line 100
  str_len = strlen(str);
#line 102
  while (i < str_len) {
#line 103
    switch ((int const   )*(str + i)) {
    case 33: 
#line 105
    if (markfound == 1) {
#line 106
      markfound = 0;
    } else {
#line 108
      markfound = 1;
    }
#line 109
    break;
    case 64: 
#line 112
    if (atfound == 1) {
#line 113
      atfound = 0;
    } else {
#line 115
      atfound = 1;
    }
#line 116
    break;
    }
#line 119
    i ++;
  }



#line 167
  while ((unsigned long )*(str + i) != (unsigned long )((void *)0)) {
#line 168
    tmp = check_regline((char const   *)*(str + i));
#line 168
    if (tmp == 0) {
#line 170
      split = sp_ircsplit((char const   *)*(str + i));
#line 171
      foundparam = (size_t )1;
#line 172
      break;
    }
#line 175
    i ++;
  }


#line 451
    while (1) {
#line 451
      queue_buf = queue_fetchmessagess(thread->id);
#line 451
      if (queue_buf) {
#line 451
        if (! ((unsigned long )queue_buf != (unsigned long )((void *)0))) {
#line 451
          break;
        }
      } else {
#line 451
        break;
      }
#line 452
      free((void *)queue_buf);
    }



#line 515
      while (rev == 0) {
#line 517
        while (rev == 0) {
#line 518
          tmp___6 = oz_isdatawaiting(sockfd);
#line 518
          if (tmp___6 == 0) {
#line 519
            break;
          }
#line 521
          rev = oz_read(sockfd, & buf, (char const   )'\n');
#line 523
          if (rev == -1) {
#line 524
            break;
          }
#line 532
          tmp___8 = strn_comp((char const   *)buf, "PING");
#line 532
          if (tmp___8 == 0UL) {
#line 533
            rev = oz_writefl(sockfd, "PONG :%s", & settings.hostname);
#line 535
            lastping = time((time_t *)((void *)0));
#line 536
            pingsent = 0;
          } else {
#line 539
            tmp___7 = strn_comp((char const   *)buf, "ERROR :Closing Link: ");
#line 539
            if (tmp___7 == 0UL) {
#line 540
              logit("Client: ... disconnected from server, reconnection in progress!");
#line 541
              logit("Client: ... message from server=%s", buf);
#line 542
              queue_add_fmessage(1, 0, thread->id, (char *)"Disconnected from server, reconnection in progress!");
#line 543
              rev = -1;
            } else {
#line 551
              pingsent = 0;
#line 552
              lastping = time((time_t *)((void *)0));
#line 560
              queue_add_globalmessage(0, thread->id, (char const   *)buf);
#line 561
              queue_add_globalmessage(3, thread->id, (char const   *)buf);
#line 567
              c = 0U;
#line 567
              while (c < 10U) {
#line 568
                ic[c].param1 = (void *)buf;
#line 567
                c ++;
              }
#line 570
              c = 11U;
#line 570
              while (c < 15U) {
#line 571
                ic[c].param1 = (void *)buf;
#line 570
                c ++;
              }
#line 573
              ic[10].param2 = (void *)buf;
#line 576
              sp_parse_server_msg(ic, buf);
            }
          }
        }
#line 581
        tmp___9 = queue_fetchmessages(thread->id, sockfd);
#line 581
        rev -= tmp___9;
#line 584
        while (1) {
#line 584
          tmp___10 = commands_fetch(thread->id, & command);
#line 584
          if (! (tmp___10 == 0)) {
#line 584
            break;
          }
#line 585
          if (command.cmdid == 2) {
#line 586
            rev = oz_writefl(sockfd, "QUIT :Requested");
#line 587
            rev = -1;
#line 588
            sleep(2U);
          }
        }
#line 593
        if (pingsent == 0) {
#line 593
          tmp___12 = time((time_t *)((void *)0));
#line 593
          if (lastping + (time_t )settings.cli_pingsend < tmp___12) {
#line 595
            rev = oz_writefl(sockfd, "PING :%s", settings.hostname);
#line 596
            pingsent = 1;
          } else {
#line 593
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 599
        if (pingsent == 1) {
#line 599
          tmp___11 = time((time_t *)((void *)0));
#line 599
          if (lastping + (time_t )settings.cli_pingtimeout < tmp___11) {
#line 600
            logit("Self ping check failed, reconnecting to server!");
#line 601
            queue_add_fmessage(1, 0, thread->id, (char *)"Self ping check failed, reconnecting to server!");
#line 602
            rev = -1;
          }
        }
#line 605
        sp_sleep();
      }



#line 28
  i = 0U;
#line 28
  while (i < 100U) {
#line 29
    if (threads[i].id == -1) {
#line 30
      threads[i].id = (int )i;
#line 31
      threads[i].pid = 0;
#line 32
      threads[i].kind = kind;
#line 33
      pthread_mutex_unlock(& threads_lock);
#line 34
      return ((int )i);
    }
#line 28
    i ++;
  }



#line 102
  pthread_mutex_lock(& threads_lock);
#line 104
  i = 0U;
#line 104
  while (i < 100U) {
#line 105
    if (threads[i].id == id) {
#line 106
      threads[i].id = -1;
    }
#line 104
    i ++;
  }




#line 114
    while (1) {
#line 115
      if (tmpcmd->id == id) {
#line 116
        if ((unsigned long )tmpq != (unsigned long )((void *)0)) {
#line 117
          commands_del(tmpq);
#line 118
          tmpq = (tcommands *)((void *)0);
        }
#line 121
        if ((unsigned long )tmpcmd->param1 != (unsigned long )((void *)0)) {
#line 122
          free(tmpcmd->param1);
        }
#line 124
        if ((unsigned long )tmpcmd->param2 != (unsigned long )((void *)0)) {
#line 125
          free(tmpcmd->param2);
        }
#line 127
        if ((unsigned long )tmpcmd->param3 != (unsigned long )((void *)0)) {
#line 128
          free(tmpcmd->param3);
        }
#line 130
        if ((unsigned long )tmpcmd->param4 != (unsigned long )((void *)0)) {
#line 131
          free(tmpcmd->param4);
        }
#line 133
        tmpq = tmpcmd;
      }
#line 114
      tmpcmd = tmpcmd->next;
#line 114
      if (! ((unsigned long )tmpcmd != (unsigned long )((void *)0))) {
#line 114
        break;
      }
    }


#line 196
    p = commands;
#line 196
    last = p;
#line 199
    while ((unsigned long )p->next != (unsigned long )((void *)0)) {
#line 200
      p = p->next;
#line 200
      last = p;
    }


#line 276
  i = 0U;
#line 276
  while (i < 100U) {
#line 277
    if (threads[i].id != -1) {
#line 277
      if (threads[i].kind == kind) {
#line 278
        commands_add(threads[i].id, from, cmdid, param1, param2, param3, param4);
      } else
#line 277
      if (kind == 2) {
#line 278
        commands_add(threads[i].id, from, cmdid, param1, param2, param3, param4);
      }
    }
#line 276
    i ++;
  }



#line 353
  while (1) {
#line 354
    if (tmpcmd->id == id) {
#line 354
      if (tmpcmd->cmdid != 6) {
#line 355
        command->id = tmpcmd->id;
#line 356
        command->from = tmpcmd->from;
#line 357
        command->cmdid = tmpcmd->cmdid;
#line 358
        command->param1 = tmpcmd->param1;
#line 359
        command->param2 = tmpcmd->param2;
#line 360
        command->param3 = tmpcmd->param3;
#line 361
        command->param4 = tmpcmd->param4;
#line 363
        commands_del(tmpcmd);
#line 364
        pthread_mutex_unlock(& commands_lock);
#line 365
        return (0);
      }
    }
#line 353
    tmpcmd = tmpcmd->next;
#line 353
    if (! ((unsigned long )tmpcmd != (unsigned long )((void *)0))) {
#line 353
      break;
    }
  }


#line 430
  i = 0U;
#line 434
  pthread_mutex_lock(& threads_lock);
#line 436
  i = 0U;
#line 436
  while (i < 100U) {
#line 437
    if (threads[i].id != -1) {
#line 437
      if (threads[i].id != from) {
#line 437
        if (threads[i].kind == kind) {
#line 438
          queue_addmessage(threads[i].id, from, txt);
        } else
#line 437
        if (kind == 2) {
#line 438
          queue_addmessage(threads[i].id, from, txt);
        }
      }
    }
#line 436
    i ++;
  }


#line 502
  rev = 0;
#line 505
  while (1) {
#line 505
    if (rev == 0) {
#line 505
      txt = queue_fetchmessagess(id);
#line 505
      if (! ((unsigned long )txt != (unsigned long )((void *)0))) {
#line 505
        break;
      }
    } else {
#line 505
      break;
    }
#line 506
    rev = oz_writel(sockfd, (char const   *)txt);
#line 507
    free((void *)txt);
  }



#line 539
    tmpcmd = commands;
#line 541
    while (1) {
#line 542
      if (tmpcmd->id == id) {
#line 542
        if (tmpcmd->cmdid == 6) {
#line 543
          txt = (char *)tmpcmd->param1;
#line 544
          commands_del(tmpcmd);
#line 545
          pthread_mutex_unlock(& commands_lock);
#line 546
          return (txt);
        }
      }
#line 541
      tmpcmd = tmpcmd->next;
#line 541
      if (! ((unsigned long )tmpcmd != (unsigned long )((void *)0))) {
#line 541
        break;
      }
    }


#line 660
  while (linecache_size <= i) {
#line 661
    if ((unsigned long )*(linecache + i) != (unsigned long )((void *)0)) {
#line 662
      free((void *)*(linecache + i));
    }
#line 663
    i ++;
  }


#line 700
  pthread_mutex_lock(& lcache_lock);
#line 702
  while ((size_t )i < linecache_size) {
#line 703
    if ((unsigned long )*(linecache + i) != (unsigned long )((void *)0)) {
#line 706
      rev = oz_writel(sockfd, (char const   *)*(linecache + i));
#line 708
      if (rev != 0) {
#line 709
        pthread_mutex_unlock(& lcache_lock);
#line 710
        return (rev);
      }
    }
#line 714
    i ++;
  }


#line 744
  i = 0U;
#line 744
  while (i < 500U) {
#line 745
    if ((unsigned long )channels[i] == (unsigned long )((void *)0)) {
#line 746
      tmp___4 = __strdup(chan);
#line 746
      channels[i] = tmp___4;
#line 748
      if ((unsigned long )channels[i] == (unsigned long )((void *)0)) {
#line 749
        pthread_mutex_unlock(& channels_lock);
#line 750
        logit("WARNING: SuperVixen was unable to allocate memory, some things may be wrong!");
#line 750
        return (-1);
      }
#line 753
      pthread_mutex_unlock(& channels_lock);
#line 754
      return (0);
    }
#line 744
    i ++;
  }


#line 784
  i = 0U;
#line 784
  while (i < 500U) {
#line 785
    if ((unsigned long )channels[i] != (unsigned long )((void *)0)) {
#line 785
      tmp = str_comp((char const   *)channels[i], chan);
#line 785
      if (tmp == 0UL) {
#line 786
        free((void *)channels[i]);
#line 787
        channels[i] = (char *)((void *)0);
      }
    }
#line 784
    i ++;
  }


#line 863
  i = 0;
#line 864
  rev = 0;
#line 866
  pthread_mutex_lock(& channels_lock);
#line 868
  while (i < 500) {
#line 869
    if ((unsigned long )channels[i] != (unsigned long )((void *)0)) {
#line 870
      tmp = oz_writefl(sockfd, "JOIN %s", channels[i]);
#line 870
      rev -= tmp;
#line 871
      free((void *)channels[i]);
#line 872
      channels[i] = (char *)((void *)0);
    }
#line 875
    i ++;
  }



#line 63
  i = (size_t )0;
#line 65
  while (*msg) {
#line 66
    i ++;
#line 67
    tmp = msg;
#line 67
    msg ++;
  }
#line 70



#line 114
      x = 0;
#line 114
      while ((ic + x)->code != -1) {
#line 115
        if (code == (unsigned int )(ic + x)->code) {
#line 116
          fp = (int (*)(void * , void * , void * , void * ))(ic + x)->handler;
#line 117
          (*fp)((ic + x)->param1, (ic + x)->param2, (ic + x)->param3, (ic + x)->param4);
        }
#line 114
        x ++;
      }



#line 127
      x = 0;
#line 127
      while ((ic + x)->code != -1) {
#line 128
        if (code == (unsigned int )(ic + x)->code) {
#line 129
          fp = (int (*)(void * , void * , void * , void * ))(ic + x)->handler;
#line 130
          (*fp)((ic + x)->param1, (ic + x)->param2, (ic + x)->param3, (ic + x)->param4);
        }
#line 127
        x ++;
      }


#line 138
      x = 0;
#line 138
      while ((ic + x)->code != -1) {
#line 139
        if (code == (unsigned int )(ic + x)->code) {
#line 140
          fp = (int (*)(void * , void * , void * , void * ))(ic + x)->handler;
#line 141
          (*fp)((ic + x)->param1, (ic + x)->param2, (ic + x)->param3, (ic + x)->param4);
        }
#line 138
        x ++;
      }



#line 147
      code = 1105U;
#line 149
      x = 0;
#line 149
      while ((ic + x)->code != -1) {
#line 150
        if (code == (unsigned int )(ic + x)->code) {
#line 151
          fp = (int (*)(void * , void * , void * , void * ))(ic + x)->handler;
#line 152
          (*fp)((ic + x)->param1, (ic + x)->param2, (ic + x)->param3, (ic + x)->param4);
        }
#line 149
        x ++;
      }


#line 160
      x = 0;
#line 160
      while ((ic + x)->code != -1) {
#line 161
        if (code == (unsigned int )(ic + x)->code) {
#line 162
          fp = (int (*)(void * , void * , void * , void * ))(ic + x)->handler;
#line 163
          (*fp)((ic + x)->param1, (ic + x)->param2, (ic + x)->param3, (ic + x)->param4);
        }
#line 160
        x ++;
      }


#line 171
      x = 0;
#line 171
      while ((ic + x)->code != -1) {
#line 172
        if (code == (unsigned int )(ic + x)->code) {
#line 173
          fp = (int (*)(void * , void * , void * , void * ))(ic + x)->handler;
#line 174
          (*fp)((ic + x)->param1, (ic + x)->param2, (ic + x)->param3, (ic + x)->param4);
        }
#line 171
        x ++;
      }



#line 216
  i = 0U;
#line 216
  while (i < 4U) {
#line 217
    tmp___0 = malloc((str_len + 4UL) * sizeof(char ));
#line 217
    *(split + i) = (char *)tmp___0;
#line 219
    if ((unsigned long )*(split + i) == (unsigned long )((void *)0)) {
#line 220
      return ((char **)((void *)0));
    }
#line 222
    memset((void *)*(split + i), '\000', (str_len + 4UL) * sizeof(char ));
#line 216
    i ++;
  }



#line 225
  str_pos = (size_t )0;
#line 225
  while (str_pos < str_len) {
#line 226
    if (got_nick == 0) {
#line 227
      if ((int const   )*(str + str_pos) == 33) {
#line 228
        got_nick = 1;
      } else {
#line 230
        strncat((char * __restrict  )*(split + 0), (char const   * __restrict  )(str + str_pos),
                (size_t )1);
      }
    } else
#line 233
    if (got_nick == 1) {
#line 233
      if (got_username == 0) {
#line 234
        if ((int const   )*(str + str_pos) == 64) {
#line 235
          got_username = 1;
        } else {
#line 237
          strncat((char * __restrict  )*(split + 1), (char const   * __restrict  )(str + str_pos),
                  (size_t )1);
        }
      } else {
#line 233
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 240
    if (got_nick == 1) {
#line 240
      if (got_username == 1) {
#line 240
        if (got_hostname == 0) {
#line 241
          if ((int const   )*(str + str_pos) == 0) {
#line 242
            got_hostname = 1;
#line 243
            break;
          } else {
#line 247
            strncat((char * __restrict  )*(split + 2), (char const   * __restrict  )(str + str_pos),
                    (size_t )1);
          }
        }
      }
    }
#line 225
    str_pos ++;
  }



  while (1) {
#line 30
    tmp = thread_info(& pos, & t_info);
#line 30
    if (! (tmp != -1)) {
#line 30
      break;
    }
#line 31
    if (t_info.id == -1) {
#line 32
      continue;
    }
#line 34
    if (t_info.kind == 0) {
#line 35
      type = (char *)"Client";
    } else
#line 37
    if (t_info.kind == 3) {
#line 38
      type = (char *)"Management thread";
    } else
#line 40
    if (t_info.kind == 1) {
#line 41
      type = (char *)"IRC server-connection thread";
    } else {
#line 44
      type = (char *)"Unknown!";
    }
#line 46
    queue_add_fmessage(0, id, from, (char *)"%i\t%i\t%s", t_info.id, t_info.pid, type);
  }



#line 68
  rev = 0;
#line 69
  servermessages = 0UL;
#line 72
  tmp = pthread_self();
#line 72
  pthread_detach(tmp);
#line 73
  thread->pid = getpid();
#line 77
  while (1) {
#line 82
    while (1) {
#line 82
      msg = queue_fetchmessagess(thread->id);
#line 82
      if (msg) {
#line 82
        if (! ((unsigned long )msg != (unsigned long )((void *)0))) {
#line 82
          break;
        }
      } else {
#line 82
        break;
      }
#line 83
      if ((int )*(msg + 0) == 58) {
#line 84
        servermessages ++;
      }
#line 86
      free((void *)msg);
    }
#line 90
    rev = commands_fetch(thread->id, & command);
#line 92
    if (rev == -1) {
#line 93
      sp_sleep();
#line 94
      continue;
    }
#line 97
    switch (command.cmdid) {
    case 1: 
#line 99
    tmp___0 = time((time_t *)((void *)0));
#line 99
    queue_add_fmessage(0, command.from, thread->id, (char *)"SuperVixen statistics; Server messages=%lu; number of clients connected=%i; uptime=%lu",
                       servermessages, curconn, tmp___0 - startuptime);
#line 100
    break;
    case 3: 
#line 103
    queue_add_fmessage(1, 0, thread->id, (char *)"A exit request message was recieved. Exiting in ~5 seconds.");
#line 104
    queue_add_fmessage(1, 0, thread->id, (char *)"ERROR :Closing Link: Bouncer exiting.");
#line 105
    sleep(5U);
#line 107
    commands_groupmsg(1, thread->id, 2, (void *)0, (void *)0, (void *)0, (void *)0);
#line 108
    sysexit("Management: Recieved request to exit.");
#line 109
    break;
    case 4: 
#line 112
    queue_add_fmessage(0, command.from, thread->id, (char *)"This is SuperVixen version %s.",
                       settings.version);
#line 113
    break;
    case 7: 
#line 116
    list_threads(thread->id, command.from);
#line 117
    break;
    case 5: 
#line 120
    queue_add_fmessage(0, command.from, thread->id, (char *)"The following commands are possible to use:");
#line 121
    queue_add_fmessage(0, command.from, thread->id, (char *)"\tSPINFO -- gives some statistics.");
#line 122
    queue_add_fmessage(0, command.from, thread->id, (char *)"\tSPDIE -- causes the boncer to disconnect from servers and exit.");
#line 123
    queue_add_fmessage(0, command.from, thread->id, (char *)"\tSPVERSION -- sends out the bouncers version info.");
#line 124
    queue_add_fmessage(0, command.from, thread->id, (char *)"\tSPDISCONNECT -- disconnects from IRC server and connects to the next one.");
#line 125
    queue_add_fmessage(0, command.from, thread->id, (char *)"\tSPTHREADS -- shows a list of currently running threads inside the program.");
#line 126
    queue_add_fmessage(0, command.from, thread->id, (char *)"\tSPHELP -- sends out this info.");
#line 127
    break;
    }
  }


