Two steps:
\begin{enumerate}
    \item \textbf{Rewrite the Program}
    It first rewrites the program $c$ by syntax in \cite{GulwaniJK09} and preserves the same semantics, based on $\absG(c)$.
\\
Each \emph{simple transition paths}, $\tpath \in \paths(\absG(c))$ in the rewritten program
corresponds to a path $\rho$ in the flatten program by Definition~4.1 in \cite{GulwaniJK09}.
%
It contains only the edges of atomic assignment or guard transition.
\item \textbf{Refined Program}
Then it computes the 
refined program, $\rprog$ by Algorithm~1 in paper~\cite{GulwaniJK09}.
\\
This step invokes the external algorithm REFINE from paper~\cite{GulwaniJK09} and compute the 
refined program $\rprog$ for a program $c$ given the input $c^{T}$.
\end{enumerate}

\paragraph{Rewrite the Program}
\begin{algorithmic}[1]
    \REQUIRE none
    \STATE finds all $c$'s \emph{simple transition path}s, $\tpath_1, \cdots, \tpath_n \in \paths(\absG(c))$.
    \STATE \textbf{init}: candidate set $W = \{c_1, \cdots, c_n\}$, $c_i = \tpath_i$ for all transition paths.
    \STATE \textbf{while} $W.size()> 1$:
    \STATE \quad create $c' = \rpchoose{c_1, \cdots, c_m}$ 
    s.t. $c_i \in W \land c_i[0] = c_j[0] \land c_i[-1] = c_j[-1], i, j = 1, \cdots, m$.
    \\ \quad $W.add(c')$ \qquad $W.remove(c_1, \cdots, c_m)$
    \STATE
    \quad create $c' = \rprepeat(c)$ s.t. $c_i \in W \land c[0] = c[-1]$
    \\ \quad $W.add(c')$, \qquad $W.remove(c)$
    \STATE \quad create $c' = c_1; c_2$ s.t. $c_1, c_2 \in W \land c_1[-1] = c_2[0]$
    \\
    \quad $W.add(c')$ \qquad $W.remove(c_1, c_2)$
    \STATE \textbf{Endwhile}
    \\ $c^T = W[0]$
    \RETURN $c^T$.
\end{algorithmic}
%
Line-2: initialize each candidate $c_i$ with a simple transition path $\tpath_i$.
\\
Line-4: for all the candidates $c_1, \cdots, c_m$ having the same starting and ending vertices, rewrite them into if statement as~\cite{GulwaniJK09}.
\\
Line-5: for every candidate $c'$, if it starts and ends with the same vertex, rewrite it into while loop statement as~\cite{GulwaniJK09}.
\\
Line-6: for every two candidates $c_1, c_2$, if $c_1$ ends with the same vertex as $c_2$'s starting label, rewrite them into sequence statement as~\cite{GulwaniJK09}.

\paragraph{Refined Program}
This step simply invokes the external algorithm REFINE from paper~\cite{GulwaniJK09} and compute the 
refined program $\rprog$ for a program $c$ given the input $c^{T}$.
