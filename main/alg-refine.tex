Two steps:
\begin{enumerate}
    \item \textbf{Rewrite the Program}
    It first rewrites the program $c$ by syntax in \cite{GulwaniJK09} and preserves the same semantics, based on $\absG(c)$.
\\
Each \emph{simple transition paths}, $\tpath \in \paths(\absG(c))$ in the rewritten program
corresponds to a path $\rho$ in the flatten program by Definition~4.1 in \cite{GulwaniJK09}.
%
It contains only the edges of atomic assignment or guard transition.
\item \textbf{Refined Program}
Then it computes the 
refined program, $\rprog$ by Algorithm~1 in paper~\cite{GulwaniJK09}.
\\
This step invokes the external algorithm REFINE from paper~\cite{GulwaniJK09} and compute the 
refined program $\rprog$ for a program $c$ given the input $c^{T}$.
\end{enumerate}

\paragraph{Rewrite the Program}
\begin{algorithmic}[1]
    \REQUIRE none
    \STATE finds all $c$'s \emph{simple transition path}s, $\tpath_1, \cdots, \tpath_n \in \paths(\absG(c))$.
    \STATE \textbf{init}: candidate set $W = \{c_1, \cdots, c_n\}$, where $c_i = \tpath_i$ and $i = 1, \cdots, n$
    \STATE \textbf{while} $W.size()> 1$:
    \STATE \quad create $c' = \rpchoose{c_1, \cdots, c_m}$ 
    s.t. $c_i \in W \land c_i[0] = c_j[0] \land c_i[-1] = c_j[-1], i, j = 1, \cdots, m$.
    \\ \quad $W.add(c')$ \qquad $W.remove(c_1, \cdots, c_m)$
    \STATE
    \quad create $c' = \rprepeat(c)$ s.t. $c_i \in W \land c[0] = c[-1] \land c[0] \in \loopl(c)$
    \\ \quad $W.add(c')$, \qquad $W.remove(c)$
    \STATE \quad create $c' = c_1; c_2$ s.t. $c_1, c_2 \in W \land c_1[-1] = c_2[0]$
    \\
    \quad $W.add(c')$ \qquad $W.remove(c_1, c_2)$
    \STATE \textbf{Endwhile}
    \\ $c^T = W[0]$
    \RETURN $c^T$.
\end{algorithmic}
%
Line-2: initialize each candidate $c_i$ with a simple transition path $\tpath_i$.
\\
Line-4: for all the candidates $c_1, \cdots, c_m$ having the same starting and ending vertices, rewrite them into if statement as~\cite{GulwaniJK09}.
\\
Line-5: for every candidate $c'$, if it starts and ends with the same vertex, rewrite it into while loop statement as~\cite{GulwaniJK09}.
\\
Line-6: for every two candidates $c_1, c_2$, if $c_1$ ends with the same vertex as $c_2$'s starting label, rewrite them into sequence statement as~\cite{GulwaniJK09}.
\\
We use simple depth first search strategy computes all the \emph{simple transition path}s satisfying the Definition~\ref{def:tpath} below.
It guarantees that  every $\tpath$ is equivalent to a path $\rho$ in Definition~4.1 of \cite{GulwaniJK09}.
  \begin{defn}[Simple Tansition Path]
    \label{def:tpath}
  A simple transition path
  $\tpath \in \paths(\absG(c))$ for the program $c$, is a path on the program $c$ abstract transition graph $\absG(c) = (\absV(c), \absE(c))$ with 
  \begin{itemize}
  \item a vertices sequence $(l_0, \cdots, l_n)$, where $l_i \in \absV(c)$ for every $i = 0, \cdots, n$ and
  %
  \item an edge sequence $(e_1, \cdots, e_n)$, where $e_i = (l_{i - 1}, dc_i, l_{i}) \in \absE(c)$ for every $i = 1, \cdots, n$,
  \end{itemize}
  %
  satisfying:
  \begin{itemize}
    \item $l_i \neq l_j$ for every $i = 0, \cdots, n$ and $j = 0, \cdots, {n - 1}$,
    \item $l_0$ is either the program point of a loop header or the program entrance ($l_0 = 0$),
    i.e., $l_0 \in \loopl(c) \cup \{ 0 \}$
    \item and $l_n$ is either the program point of a loop header or the program exit ($l_n = \lex$),
    i.e., $l_0 \in \loopl(c) \cup \{ \lex \}$.
  \end{itemize}
  \end{defn}

\paragraph{Refined Program}
This step simply invokes the external algorithm REFINE from paper~\cite{GulwaniJK09} and compute the 
refined program $\rprog$ for a program $c$ given the input $c^{T}$.
