
The three loop bound computation methods all computes the sound upper bounds, $BD(\rprepeat(\rprog'))$ for every loop $\rprepeat(\rprog')$ in a refined program $\rprog$:
\begin{enumerate}
    \item The Equation~\ref{eq:absBD} in Section~\ref{sec:rank} is path-insensitively and sound.
    Its soundness relies on the soundness of the $\absclr(\absevent, c)$ in Definition~\ref{def:ranking_bound} in Section~\ref{sec:rank}.
    For a program $c$ and an edge $\absevent \in \absE(c)$, $\absclr(\absevent, c)$ is a sound upper bound on the execution times of this transition, formally in Theorem~\ref{thm:pathinsensitive_rb_soundness} with proof in Appendix~\ref{apdx:pathinsensitive_rb_soundness}    
    \item The second computation fully relies on the soundness of $BOUND(\rprepeat(\rprog'))$ from paper\cite{GulwaniJK09}, we do not repeat their soundness in this paper.
    \item   The soundness of the alternative computation method we provided in Definition~\ref{def:loopbound} is presented below.
  \end{enumerate}

For every transition path $\rprog$, the $BD(\rprog)$
is a sound upper bound on its execution times.
\\
This bound is sound locally by assuming
that all the loops and transition paths where $\rprog$ is nested execute only once.
This assumption comes from the computation of the $\varGD$ and the depth first search strategy.
\\
%
\begin{lemma}[Soundness of Loop Bound]
    % \label{lem:loopbound_sound}
    For every program $c$ with its refined program $\rprog$,
    % for every loop $\rprepeat(\rprog')$ inside $\rprog$, 
    $BD(\rprog)$ is a sound upper bound on the iterating times of this program.
    \[
      \begin{array}{l}
      \forall c \in \cdom, \trace_0 \in \tdom_0(c), \trace \in \inftdom, \rprog \st 
      \rprog = REFINE(c)
      \\ \qquad
      \land 
      \config{c, \trace_0} \to^* 
      \config{\eskip, \trace_0 \tracecat \trace}
      \\ \qquad
      \implies
      \config{BD(\rprog)}(\trace_0) 
      \\ \qquad \geq 
      \# \Big\{\trace_{l_s \to l_f} ~\vert~ \trace_{l_s \to l_t}, \trace' \in \trace \land \trace_{l_s \to l_t} = [(\_, l_s, \_)] \tracecat \trace' \tracecat [(\_, l_f, \_)]
      \\ \qquad \qquad
      \land (l_{f}, \_) \in \absfinal(c)
      \land l_s = \absinit(c)
      \land \counter(\trace', l_s) = \counter(\trace', l_f) = 0 
      \Big\}.
      \end{array}
    \]
    \end{lemma}
    Informal Discussion:
    \\
  Lemma~\ref{lem:loopbound_sound} guarantees that
  the bound for every transition path $\rprog$, the $BD(\rprog)$
  is a sound upper bound on its execution times, by assuming
  that all the loops and transition paths where $\rprog$ is nested execute only once.
  
  For every base case, i.e., a simple transition path, 
$\varGD(\rprog) =  \rfinit(\tpath) - \rfnext(\rprog)$
counts the variables' changes only once. In this way, it assumes all the outside patterns and loops execution only once.
In paper \cite{sinn2017complexity} Definition~9, they informally discussed the local bound soundness.
$v$ is a local bound if it has the same decreasing time as the transition's execution time.
By assuming that certain program parts (those were e increases) are not executed,
then value of $v$ can limit the execution time of that transition.
\\
In our soundness, we assume all the code pieces not inside this transition path are executed at most once (once if they show up in front of the program
zero time if not).
In this case, this bound limits the execution time of this transition path.
\\
The soundness also relies on the operation $\frac{\rfinit(\rprog) - \rffinal(\rprog)}{\varGD(\rprog)}$,
which can be solved by external SMT solver,
or solved by Definition~\ref{def:ranking_bound} in Section~\ref{sec:rank}.

\begin{proof}
\emph{Soundness} of the \emph{Loop Bound}.
  \\
  Taking an arbitrary program $c$, let $\rprog$ be its refined program and $\tpath$ be an arbitrary transition path in this program.
  \\
Taking an arbitrary initial trace $\trace_0 \in \tdom_0(c)$  and an execution trace $\trace \in \tdom$
 such that $\config{{c}, \trace} \to^{*} \config{\eskip, \trace_0 \tracecat \vtrace}$,
 it is sufficient to show,
 \[
  \begin{array}{l}
  \config{BD(\rprog)}(\trace_0) 
  \# \Big\{\trace_{l_s \to l_f} ~\vert~ \trace_{l_s \to l_t}, \trace' \in \trace \land \trace_{l_s \to l_t} = [(\_, l_s, \_)] \tracecat \trace' \tracecat [(\_, l_f, \_)]
  \\ \qquad \qquad
  \land (l_{f}, \_) \in \absfinal(c)
  \land l_s = \absinit(c)
  \land \counter(\trace', l_s) = \counter(\trace', l_f) = 0 
  \Big\}.
  \end{array}
\]
By induction on the refined program, we have the following cases.
\caseL{$\rprog = \tpath$}
In this case, we have $BD(\tpath) = 1$.
\\
By Algorithm~\ref{alg:alg-refine_rewrite} and Definition~\ref{def:tpath}, we know program $c$ contains the only one transition path $\tpath$.
\\
So we know $\absinit(c) = 0$ and $\absfinal(c) = \{ (l_f, \_) \}$ for some $l_f \in \mathbb{N}$.
\\
We also know $\tpath$ will be executed at most once and $\trace_{0 \to l_f} = \trace$. So we have
\[
  \begin{array}{l}
  \# \Big\{\trace_{0 \to l_f} ~\vert~ \trace_{0 \to l_f}, \trace' \in \trace \land \trace_{l \to l_t} = [(\_, l_s, \_)] \tracecat \trace' \tracecat [(\_, l_f, \_)]
  \\ \qquad \qquad
  \land (l_{f}, \_) \in \absfinal(c)
  \land l_s = \absinit(c)
  \land \counter(\trace', l_s) = \counter(\trace', l_f) = 0 
  \Big\}
   = \# \Big\{\trace \Big\} = 1
  \end{array}
\]
Then we have this case proved.
\caseL{$\rprog = \rpchoose{\rprog_1, \ldots}$}
In this case, we have
\[
  BD(\rpchoose{\rprog_1, \ldots, \rprog_m }) = \max\left\{ BD(\rprog_1), \ldots, BD(\rprog_m) \right\}
\]
Let $c_1, \ldots, c_m \in \cdom$ be the while program corresponding to $\rprog_1, \ldots, \rprog_m$ such that $\algrewrite(c_1) = \rprog_1$, $\ldots$ and  $\algrewrite(c_m) = \rprog_m$.
According to the Algorithm~\ref{alg:alg-refine_rewrite} and the program refinement algorithm REFINE, we know each $\rprog_i$ is a loop program refined from multiple paths in $c$.
\\
% By the REFINE algorithm, we also in each refined $\rprog_i$, the know the multiple paths in $c$ is explicitly permutation.
% \\
In this sense, each $c_i$ is a loop program and execution of each $c_i$ corresponds to one possible execution of $c$.
%  with only one new execution path. 
\\
According to the operational semantics, let $\trace_1, \ldots, \trace_m \in \inftdom$ be the execution traces such that 
\[
  \config{c_i, \trace_0} \to^* 
  \config{\eskip, \trace_0 \tracecat \trace_i}
\]
By induction hypothesis, for each $c_i$, $\rprog_i$ and the execution trace $\trace_i$, we have 
\[
  \begin{array}{l}
  \config{BD(\rprog_i)}(\trace_0) 
  \# \Big\{\trace_{l_s \to l_f} ~\vert~ \trace_{l_s \to l_t}, \trace' \in \trace_i \land \trace_{l_s \to l_t} = [(\_, l_s, \_)] \tracecat \trace' \tracecat [(\_, l_f, \_)]
  \\ \qquad \qquad
  \land (l_{f}, \_) \in \absfinal(c_i)
  \land l_s = \absinit(c_i)
  \land \counter(\trace', l_s) = \counter(\trace', l_f) = 0 
  \Big\}.
  \end{array}
\]
Since execution of each $c_i$ corresponds to one possible execution of $c$, we also know
$\trace = \trace_i$ where $i$ could be either $1, \ldots, m$.
So we have for each $\trace_i$ if $\trace = \trace_i$, 
\[
  \begin{array}{l}
    \config{BD(\rprog_i)}(\trace_0) \geq
    \# \Big\{\trace_{l_s \to l_f} ~\vert~ \trace_{l_s \to l_t}, \trace' \in \trace \land \trace_{l_s \to l_t} = [(\_, l_s, \_)] \tracecat \trace' \tracecat [(\_, l_f, \_)]
    \\ \qquad \qquad
    \land (l_{f}, \_) \in \absfinal(c_i)
    \land l_s = \absinit(c_i)
    \land \counter(\trace', l_s) = \counter(\trace', l_f) = 0 
    \Big\}.
    \end{array}
\]
Then we have for all $\rprog_i$ the following and this case is proved.
\[
  \begin{array}{l}
    \config{BD(\rprog)}(\trace_0) = 
    \max\left\{ \config{BD(\rprog_1)}(\trace_0), \ldots, \config{BD(\rprog_m)(\trace_0)} \right\}
    \\ \qquad 
    \geq
    \# \Big\{\trace_{l_s \to l_f} ~\vert~ \trace_{l_s \to l_t}, \trace' \in \trace \land \trace_{l_s \to l_t} = [(\_, l_s, \_)] \tracecat \trace' \tracecat [(\_, l_f, \_)]
    \\ \qquad \qquad
    \land (l_{f}, \_) \in \absfinal(c_i)
    \land l_s = \absinit(c_i)
    \land \counter(\trace', l_s) = \counter(\trace', l_f) = 0 
    \Big\}.
    \end{array}
\]

\caseL{$\rprog = \rprog_1; \rprog_2$}
In this case, we have
\[
  BD(\rprog_1; \rprog_2) = \min \left\{BD(\rprog_1), BD(\rprog_2) \right\}
\]
Let $c_1, c_2 \in \cdom$ be the while program corresponding to $\rprog_1$ and $\rprog_2$ such that $\algrewrite(c_1) = \rprog_1$ and $\algrewrite(c_2) = \rprog_2$.
\\
According to the operational semantics, let $\trace_1, \trace_2 \in \inftdom$ be two execution traces such that 
\[
  \config{c_1; c_2, \trace_0} \to^* \config{c_2, \trace_0 \tracecat \trace_1} \to^* \config{\eskip, \trace_0 \tracecat \trace_1 \tracecat \trace_2}
\]
By the trace non-decreasing property in Lemma~\ref{lem:tracenondec}, we have $\trace = \trace_1 \tracecat \trace_2$.
\\
According to the Algorithm~\ref{alg:alg-refine_rewrite} and REFINE algorithm, we have $c = c_1; c_2$.
\\
By induction hypothesis on $\trace_0$, $c_1$, $\trace_1$ and $c_2$, we also have
\[
  \begin{array}{l}
    \config{BD(\rprog_1)}(\trace_0)
    \geq
    \# \Big\{\trace_{l_s \to l_f} ~\vert~ \trace_{l_s \to l_t}, \trace' \in \trace_1 \land \trace_{l_s \to l_t} = [(\_, l_s, \_)] \tracecat \trace' \tracecat [(\_, l_f, \_)]
    \\ \qquad \qquad
    \land (l_{f}, \_) \in \absfinal(c_1)
    \land l_s = \absinit(c_1)
    \land \counter(\trace', l_s) = \counter(\trace', l_f) = 0 
    \Big\}.
    \end{array}
\]
%
\[
  \begin{array}{l}
    \config{BD(\rprog_2)}(\trace_0)
    \geq
    \# \Big\{\trace_{l_s \to l_f} ~\vert~ \trace_{l_s \to l_t}, \trace' \in \trace_2 \land \trace_{l_s \to l_t} = [(\_, l_s, \_)] \tracecat \trace' \tracecat [(\_, l_f, \_)]
    \\ \qquad \qquad
    \land (l_{f}, \_) \in \absfinal(c_2)
    \land l_s = \absinit(c_2)
    \land \counter(\trace', l_s) = \counter(\trace', l_f) = 0 
    \Big\}.
    \end{array}
\]
By Definition~\ref{def:abs_event}, we know
$\absinit(c) = \absinit(c_1)$, $\absfinal(c) = \absfinal(c_2)$ and $(\absinit(c_2), \_) \in \absfinal(c_1)$. 
\\
By the label consistency, we know 
\[
  \begin{array}{l}
    \forall \trace \in
    \Big\{\trace_{l_s \to l_f} ~\vert~ \trace_{l_s \to l_t}, \trace' \in \trace_1 \land \trace_{l_s \to l_t} = [(\_, l_s, \_)] \tracecat \trace' \tracecat [(\_, l_f, \_)]
    \\ \qquad \qquad
    \land (l_{f}, \_) \in \absfinal(c_1)
    \land l_s = \absinit(c_1)
    \land \counter(\trace', l_s) = \counter(\trace', l_f) = 0 
    \Big\},
    \\
    \exists \trace_1 \in
     \Big\{\trace_{l_s \to l_f} ~\vert~ \trace_{l_s \to l_t}, \trace' \in \trace_1 \land \trace_{l_s \to l_t} = [(\_, l_s, \_)] \tracecat \trace' \tracecat [(\_, l_f, \_)]
    \\ \qquad \qquad
    \land (l_{f}, \_) \in \absfinal(c_1)
    \land l_s = \absinit(c_1)
    \land \counter(\trace', l_s) = \counter(\trace', l_f) = 0 
    \Big\},
    \\
    \trace_2 \in
    \Big\{\trace_{l_s \to l_f} ~\vert~ \trace_{l_s \to l_t}, \trace' \in \trace_2 \land \trace_{l_s \to l_t} = [(\_, l_s, \_)] \tracecat \trace' \tracecat [(\_, l_f, \_)]
   \\ \qquad \qquad
   \land (l_{f}, \_) \in \absfinal(c_2)
   \land l_s = \absinit(c_2)
   \land \counter(\trace', l_s) = \counter(\trace', l_f) = 0 
   \Big\} 
   \st 
   \\
   \trace = \trace_1 \tracecat \trace_2
    \end{array}
  \]
  Then we have
  \[
    \begin{array}{l}
      \# \Big\{\trace_{l_s \to l_f} ~\vert~ \trace_{l_s \to l_t}, \trace' \in \trace_1 \land \trace_{l_s \to l_t} = [(\_, l_s, \_)] \tracecat \trace' \tracecat [(\_, l_f, \_)]
      \\ \qquad \qquad
      \land (l_{f}, \_) \in \absfinal(c_1)
      \land l_s = \absinit(c_1)
      \land \counter(\trace', l_s) = \counter(\trace', l_f) = 0 
      \Big\},
      \\
      \leq 
      \min \Bigg\{ \#
       \Big\{\trace_{l_s \to l_f} ~\vert~ \trace_{l_s \to l_t}, \trace' \in \trace_1 \land \trace_{l_s \to l_t} = [(\_, l_s, \_)] \tracecat \trace' \tracecat [(\_, l_f, \_)]
      \\ \qquad \qquad
      \land (l_{f}, \_) \in \absfinal(c_1)
      \land l_s = \absinit(c_1)
      \land \counter(\trace', l_s) = \counter(\trace', l_f) = 0 
      \Big\},
      \\ \qquad \quad
      \#
      \Big\{\trace_{l_s \to l_f} ~\vert~ \trace_{l_s \to l_t}, \trace' \in \trace_2 \land \trace_{l_s \to l_t} = [(\_, l_s, \_)] \tracecat \trace' \tracecat [(\_, l_f, \_)]
     \\ \qquad \qquad
     \land (l_{f}, \_) \in \absfinal(c_2)
     \land l_s = \absinit(c_2)
     \land \counter(\trace', l_s) = \counter(\trace', l_f) = 0 
     \Big\} 
     \Bigg\}
      \end{array}
    \]
    Then we have this case proved by
    \[
      \begin{array}{l}
        \config{BD(\rprog)}(\trace_0) =
        \min \Big\{ \config{BD(\rprog_2)}(\trace_0), \config{BD(\rprog_2)}(\trace_0) \Big\}
        \\
        \geq
        \# \Big\{\trace_{l_s \to l_f} ~\vert~ \trace_{l_s \to l_t}, \trace' \in \trace_1 \land \trace_{l_s \to l_t} = [(\_, l_s, \_)] \tracecat \trace' \tracecat [(\_, l_f, \_)]
      \\ \qquad \qquad
      \land (l_{f}, \_) \in \absfinal(c_1)
      \land l_s = \absinit(c_1)
      \land \counter(\trace', l_s) = \counter(\trace', l_f) = 0 
      \Big\}.
        \end{array}
    \]
% \subcaseL{$c = \ewhile \clabel{ \ldots }^{\ldots} \edo \ldots $}
% In this case, we know $\rprog_1$ and $\rprog_2$ corresponds to two loops,
% each of them is a sub-loop program of
% one path in the loop of $c$.
% \\
% Then we know $c_1$ and $c_2$ are two while loop programs ($\ewhile$) with the same initial and final states.
% Then by Definition~\ref{def:abs_event} we know
% $\absinit(c) = \absinit(c_1) = \absinit(c_1)$, $\absfinal(c) = \absfinal(c_2)$ and $(\absinit(c_2), \_) \in \absfinal(c_1)$. 
% \\
% Because $c_1$ and $c_2$ are sub-loop program of $c$,
\caseL{$\rprog = l : \rprog_l$}
In this case, we have
\[
  BD(l: \rprog_l) = BD(\rprog_l)
\]
\caseL{$\rprog = \rprepeat(\rprog')$}
In this case, we have
\[
  BD(\rprepeat(\rprog')) =
  \max\limits_{\tpath \in \rprog, x = \locbound(\tpath)}
  \Big\{ \highlight{\frac{a - b}{a'}} ~\vert~ x = a \in \rfinit(\rprog')
  \land x = b \in \rffinal(\rprog') 
  \land x = a' \in \varGD(\rprog')
  \Big\} 
\]
Then we have the soundness guaranteed by the three states,
$\rfinit(\rprog)$, $\rffinal(\rprog)$, $\rfnext(\rprog)$ computed in Definition~\ref{def:alg-loopabsstate}.
\\
For each $\tpath \in \rprog$ and $x = \locbound(\tpath)$ the ranking function of this path, we prove the soundness of the three states respectively as follows.
\begin{itemize}
 \item \emph{Initial State} Soundness.
 By Definition~\ref{def:alg-absstate}, we have $\rfinit(\rprog)$ 
 \[
  \rfinit(\rprog) \triangleq 
  \bigcup_{\tpath \in \rprog, x = \locbound(\tpath)}
  \left \{ 
  x = \arg\max_{l_1}\left\{
    \varinvar(y) + v ~\middle\vert~ 
    \begin{array}{l} 
      (l_1, x' \leq y + v, l_2) \in \reset(x) \\
      \land l_1 \leq \absinit(\rprog)
  \end{array}
  \right\}
  \right\}
  \]
Let $\trace' \in \tdom$ be the execution trace before first execution of $l_t: \rprog_t$, then we have
\[
 \config{c_l, \trace_0} \to^* \config{c_t;c', \trace_0 \tracecat \trace'} \to^* \config{\eskip, \trace_0 \tracecat \trace}
\]
 By the soundness of the rank estimation in Lemma~\ref{lem:local_bound_sound} and Theorem~\ref{thm:pathinsensitive_rb_soundness}, we know 
 for each variable $y$ such that $(l_1, x' \leq y + v, l_2) \in \reset(x) $,
 $\varinvar(y)$ is the sound upper bound on its maximum value during the execution. Then we have
 \[
   \config{\varinvar(y)}(\trace_0) \geq \max \left\{ v ~|~  \env(\trace) y = v \right\}  \geq \env(\trace') y 
 \]
%
 In this sense, we have 
 $
 \arg\max_{l_1}\left\{
  \varinvar(y) + v ~\middle\vert~ 
  \begin{array}{l} 
    (l_1, x' \leq y + v, l_2) \in \reset(x) \\
    \land l_1 \leq \absinit(\rprog)
\end{array}
\right\}
 $
 is a sound initial value estimation of the value of $x$ before first execution of $\rprog$, i.e.,
 \[
   \config{\arg\max_{l_1}\left\{
    \varinvar(y) + v ~\middle\vert~ 
    \begin{array}{l} 
      (l_1, x' \leq y + v, l_2) \in \reset(x) \\
      \land l_1 \leq \absinit(\rprog)
  \end{array}
  \right\}}(\trace_0) 
   \geq \env(\trace') x
   \]
 %
 \item  
 The \emph{Next State}, $\rfnext(\tpath) \in \scexpr$ 
 is a
 symbolic expression describing how much $\tpath$'s ranking function ($\locbound(\tpath)$) is changed after the first execution of $\rprog$ and before the second execution.
\\
 By Definition~\ref{def:alg-loopabsstate}, we have $\rfnext(l:\rprog_)$ as
 \[
  \begin{array}{l}
  \rfnext(\tpath) \triangleq 
    \begin{array}{l}
 \sum\limits_{\absevent \in \inc(x) }
  \left\{ v ~\middle\vert~ \absevent = (l, x' \leq x + v, \_) \land l \in \tpath\right\}
  \\ \qquad 
  + \arg\max\limits_{l' }
     \left\{ \varinvar(y) + v ~\middle\vert~ (l, x' \leq y + v, l') \in \reset(x) \land l \in \tpath\right\}
     \\ \qquad 
    - \sum\limits_{ \absevent \in \dec(x) }\left\{ 
      v ~\middle\vert~ \absevent = (l, x' \leq x - v, \_) \land l \in \tpath 
      \right\}
    \end{array}
  \end{array}
\]
 Let $\trace' \in \tdom$ be the execution trace before the second execution of $\tpath$, then we have
 \[
   \config{c, \trace_0} \to^* \config{c', \trace_0 \tracecat \trace'} \to^* \config{\eskip, \trace_0 \tracecat \trace}
 \]
   By the soundness of the rank estimation in Lemma~\ref{lem:local_bound_sound} and Theorem~\ref{thm:pathinsensitive_rb_soundness}, we know 
   for each variable $y$ such that $(l_1, x' \leq y + v, l_2) \in \reset(x) $,
   $\varinvar(y)$ is the sound upper bound on its maximum value during the execution. 
   Then we have
   \[
     \config{\varinvar(y)}(\trace_0) \geq \max \left\{ v ~|~  \pi_3(\event) y = v \land \event \in \trace' \land \pi_1(\event) = y\right\}  \geq \env(\trace') y 
   \]
   Same for each abstract event such that $((l', x' \leq x + v, \_) \in \inc(x) $ and $(l', x' \leq x + v, \_) \in \dec(x)$,
   we know 
   $      
   \begin{array}{l}
    \sum\limits_{\absevent \in \inc(x) }
     \left\{ v ~\middle\vert~ \absevent = (l, x' \leq x + v, \_) \land l \in \tpath\right\}
     \\ \qquad 
     + \arg\max\limits_{l' }
        \left\{ \varinvar(y) + v ~\middle\vert~ (l, x' \leq y + v, l') \in \reset(x) \land l \in \tpath\right\}
        \\ \qquad 
       - \sum\limits_{ \absevent \in \dec(x) }\left\{ 
         v ~\middle\vert~ \absevent = (l, x' \leq x - v, \_) \land l \in \tpath 
         \right\}
       \end{array}
   $ bounds the value modification of $x$ in one execution of $\tpath$.
 %
 i.e.,
   \[
     \begin{array}{l}
       \config{
       \rfinit(l: \rprog)}(\trace_0)
       -
     \config{
      \begin{array}{l}
        \sum\limits_{\absevent \in \inc(x) }
         \left\{ v ~\middle\vert~ \absevent = (l, x' \leq x + v, \_) \land l \in \tpath\right\}
         \\ \qquad 
         + \arg\max\limits_{l' }
            \left\{ \varinvar(y) + v ~\middle\vert~ (l, x' \leq y + v, l') \in \reset(x) \land l \in \tpath\right\}
            \\ \qquad 
           - \sum\limits_{ \absevent \in \dec(x) }\left\{ 
             v ~\middle\vert~ \absevent = (l, x' \leq x - v, \_) \land l \in \tpath 
             \right\}
           \end{array}
     }(\trace_0) \\
     \leq \env(\trace') x
   \end{array}
   \]
 %
 \item $\rffinal(\tpath)$ computes the value of $\locbound(\tpath)$ after the iteration of $l_t:\rprog_t$ finished.
 \\
 Let $\trace' \in \tdom$ be the execution trace after the execution of $l_t: \rprog_t$ in the first iteration of $l:\rprog$ and the $c'$ be the program after the execution of $c_t$ in the first iteration of $l:\rprog$,  then we have
 \[
   \config{c_l, \trace_0} \to^* \config{c', \trace_0 \tracecat \trace'} \to^* \config{\eskip, \trace_0 \tracecat \trace}
 \]
And $\rffinal(\tpath)$ computes the lower bound on the value of $\locbound(\tpath)$ after the iteration of $l_t:\rprog_t$ finished.
 \\
Then we know $\rffinal(\tpath) \leq \env(\trace') x$ and this case is proved by
\[
  \rfinit(\rprog) - \rffinal(\rprog) \geq \env(\trace') x.
\]
\item   \emph{Variable Gradient Decent} Soundness.
$\varGD(\rprog)$ contains the equations $x = e$, where $e \in \scexpr$ is a
  symbolic expression describing the value of $x$ before the second execution of $\rprog$,
  for each transition path $\tpath$ in this program with $x$ as the ranking function.
\\
 By induction on the $\rprog$, we have the following subcases.
 \subcaseL{$\rprog = \tpath$}
 By Definition~\ref{def:alg-absstate}, we have
\[
   \varGD(\tpath) =  \left\{x = \rfnext(\tpath) ~|~ x = \locbound(\tpath) \right\}
\]
In this case, we have the soundness guaranteed by the soundness of $\rfnext(\tpath)$ for each transition path $\tpath$.
 \subcaseL{$\rprog = \rprog_1;\rprog_2$}
 By Definition~\ref{def:alg-absstate}, we have
\[
\varGD(\rprog_1;\rprog_2) =  \varGD(\rprog_1) \cup \varGD(\rprog_2)
\]
By induction hypothesis on $\rprog_1$ and $\rprog_2$, we know
\\
for each $\tpath_1 \in \rprog_1$ with $x_1$ as its ranking function,
$\varGD(\rprog_1)$ contains the equations $x_1 = \expr_1$, where $\expr_1 \in \scexpr$ is a
symbolic expression describing the value of $x_1$ before the second execution of $\rprog_1$;
\\
for each $\tpath_2 \in \rprog_2$ with $x_2$ as its ranking function,
$\varGD(\rprog_2)$ contains the equations $x_2 = \expr_2$, where $\expr_2 \in \scexpr$ is a
symbolic expression describing the value of $x_2$ before the second execution of $\rprog_2$.
\\
By the operational semantics, we know the second execution before $\rprog$ is also the second execution of both $\rprog_1$ and $\rprog_2$.
\\
Then we have this case proved by taking the union of them, i.e., $\varGD(\rprog_1) \cup \varGD(\rprog_2)$.
\subcaseL{$\rprog = \rprepeat(\rprog')$}
 By Definition~\ref{def:alg-absstate}, we have
\[
  \varGD(\rprepeat(\rprog')) =  BD(\rprog')  \times
  {\varGD(\rprog')}
\]
By induction hypothesis on $\rprog'$, we know
\\
for each $\tpath' \in \rprog'$ with $x'$ as its ranking function,
$\varGD(\rprog')$ contains the equations $x' = \expr'$, where $\expr' \in \scexpr$ is a
symbolic expression describing the value of $x'$ before the second execution of $\rprog'$.
\\
We also know $BD(\rprog')$ computes the maximum iteration times of $\rprog'$ from $\absinit(c')$ until the $l_f$ where $(l_f, \_) \in \absfinal(c')$ where $\rprog' = REFINE(c')$.
\\
Then we know $BD(\rprog')  \times
{\varGD(\rprog')}$
computes the value of $x'$ before the second execution of $\rprepeat(\rprog')$ for each each $\tpath' \in \rprog'$ with $x'$ as its ranking function.
\\
Then we have this case proved.
\end{itemize}
Based on the soundness of the three states above, we know that the initial value of the ranking function
subtracts its final value divided by the modified value soundly computes the maximum iteration times of this program from $\absinit(c)$ until the $l_f$ where $(l_f, \_) \in \absfinal(c)$.
\\
So we have for each $\tpath \in \rprog$ where $x = \locbound(\tpath)$,
and $a, b, a ' \in \scexpr$
such that $x = a \in \rfinit(\rprog')$, $x = b \in \rffinal(\rprog')$ and $x = a' \in \varGD(\rprog')$,
the following holds.
\[
  \begin{array}{l}
  \frac{a - b}{a'} \geq
    \# \Big\{\trace_{l_s \to l_f} ~\vert~ \trace_{l_s \to l_t}, \trace' \in \trace_2 \land \trace_{l_s \to l_t} = [(\_, l_s, \_)] \tracecat \trace' \tracecat [(\_, l_f, \_)]
    \\ \qquad \qquad
    \land (l_{f}, \_) \in \absfinal(c_2)
    \land l_s = \absinit(c_2)
    \land \counter(\trace', l_s) = \counter(\trace', l_f) = 0 
    \Big\}.
    \end{array}
\]
Then we have this case proved by
\[
  \begin{array}{l}
    \config{
      \max\limits_{\tpath \in \rprog, x = \locbound(\tpath)}
    \Big\{ \highlight{\frac{a - b}{a'}} ~\vert~ x = a \in \rfinit(\rprog')
    \land x = b \in \rffinal(\rprog') 
    \land x = a' \in \varGD(\rprog')
    \Big\}
    }(\trace_0) \\
    \geq
    \# \Big\{\trace_{l_s \to l_f} ~\vert~ \trace_{l_s \to l_t}, \trace' \in \trace_2 \land \trace_{l_s \to l_t} = [(\_, l_s, \_)] \tracecat \trace' \tracecat [(\_, l_f, \_)]
    \\ \qquad \qquad
    \land (l_{f}, \_) \in \absfinal(c_2)
    \land l_s = \absinit(c_2)
    \land \counter(\trace', l_s) = \counter(\trace', l_f) = 0 
    \Big\}.
    \end{array}
\]
\end{proof}