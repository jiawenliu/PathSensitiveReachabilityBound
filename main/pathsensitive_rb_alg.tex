% In this section, we present our algorithm for computing the upper bound for a program $c$'s adaptivity
% $A(c)$ defined~\ref{def:trace_adapt} through static program analysis.
% This section presents the key definitions
% for the static analysis algorithm in Section~\ref{sec:algorithm-keys} before going into the detail of the algorithm,
% then shows the complete static analysis algorithm.
% \mg{
% In this section, we present our static program analysis for computing an upper bound on the adaptivity a program $c$
% }
In this section, we present our static program analysis for computing an upper bound on the 
execution-based reachability times for every label $l$ of an arbitrary program $c$.
% , as defined in last section.
%
\subsection{Algorithm Overview}
\label{sec:alg_overview}
In order to have the upper bound of the reachability for every label of a program $c$, we design 
a path sensitive reachability bound analysis algorithm {\THESYSTEM}.
It can be summarized as the following steps: 
% \begin{figure}
%   \centering    
% \includegraphics[width=1.0\columnwidth]{adapfun.png}
%   \vspace{-0.3cm}
%   \caption{The overview of {\THESYSTEM}}
%   \label{fig:adaptfun}
%   \vspace{-0.5cm}
% \end{figure}
%
%
\begin{enumerate}
\item  In Section~\ref{sec:abscfg}, we first construct an abstract transition graph based on $c$, by computing an abstract transition 
for every labeled command. 
This graph is used in the following section from Section~\ref{sec:pathsensitive_rb-refine} to Section~\ref{sec:pathsensitive_rb-psrbcompute} for analyzing program's reachability bound.
% see Section~\ref{sec:alg_vertexgen}
\item Section~\ref{sec:pathsensitive_rb-refine} refines this program path sensitively, based on the abstract transition graph.
\item Section~\ref{sec:pathsensitive_rb-lbcompute} estimates path-insensitive reachability upper bound for every while loop command in $c$.
\item Section~\ref{sec:pathsensitive_rb-outinalg} performs the Outside-In compute path-sensitive local bounds.
\item Section~\ref{sec:pathsensitive_rb-inoutalg} computes path-sensitive reachability bound for each edge on the abstract transition graph.
\item Section~\ref{sec:pathsensitive_rb-psrbcompute} computes the path-sensitive reachability bound for every label in this program $c$ by summarizing 
the path-sensitive reachability bound of each edge on the abstract transition graph.
% \item The Section~\ref{sec:reachabilitybound_algorithm} computes program's reachability bound in two steps as follows.
\end{enumerate}
% Finally, with all the ingredients ready, we construct the final approximated program-based dependency graph in Section~\ref{sec:alg_graphgen}

% the algorithm  without extra static analysis technique.
% \\
% Overall, this program-based graph has a similar topology structure as 
% % the one
% % of 
% the Execution-Based Dependency Graph. It has the same
% vertices and query annotations, but approximated edges and weights. We call the graph generated by static analysis techniques, static analysis dedendency graph. 
% \item Then in the last phase in Section~\ref{sec:alg_adaptcompute}, $\THESYSTEM$
% % we compute the upper bound for adaptivity over this approximated graph:
% % , as an upper bound for
% % program's adaptivity
% computes the upper bound for adaptivity over this approximated graph.
% in the last phase of this algorithm in Section~\ref{sec:alg_adaptcompute}.
% \subsection{Adaptivity Based on Program Analysis in \THESYSTEM}
% In order to give a bound on the program's adaptivity, we first build a
% program-based data-dependency graph to {over-}approximate the
% trace-based dependency graph.  Then, we define a program-based
% adaptivity over this approximated graph, as an upper bound for
% $A(c)$.
% %
% \subsection{ $\THESYSTEM$ Analysis Algorithm}
% \subsection{Dependency Graph Estimation}
% \subsection{Vertices Estimationn}
% \label{sec:alg_vertexgen}
% The first component of every vertex in the static analysis dependency graph are actually identical as the  Execution-Based Dependency Graph, which are assigned variables in the program annotated with the unique label(line number). 
% These vertices are collected by statically scanning the program, like what we do for vertices of its Execution-Based Dependency Graph. 
% The vertices are defined formally as follows.

%   \highlight{
% \[
%     \progV^0(c) \triangleq \left\{ 
%   (x^l, w) \in \mathcal{LV} \times \mathcal{A}_{\lin}
%   ~ \middle\vert ~
%   x^l \in \lvar(c)
%   \right\}
%   \]
%   }
%   %
% where $\mathcal{A}_{\lin}$ is the set of arithmetic expressions over $\mathbb{N}$ and program's input variables. 
% The weight $w$ for every vertex will be computed in following step in Section~\ref{sec:alg_weightgen}.
% The static scanning of the programs also tells us whether one vertice(assigned variable) is assigned by a query request. We have similar definition when defining the Execution-Based Dependency Graph, 
% a set of pairs $\progF(c) \in \mathcal{P}(\mathcal{LV} \times \{0, 1\} )$ 
% % is the set of pairs 
% % The weight for each vertex in $\progV(c)$ is computed 
% mapping each $x^l \in \progV(c)$ to a flag, either $0$ or $1$, where $1$  means $x^{l}$ is a member of $ \qvar_{c}$, a set of those variables assigned with query requests, and $0$ means $x^{l}$ not in this set. It is defined formally below.

% \[\progF(c) =\left\{(x^l, n)  \in  \mathcal{LV} \times \{0, 1\} 
% ~ \middle\vert ~
% x^l \in \lvar_{c},
% n = 1 \iff x^l \in \qvar_{c} \land n = 0 \iff  x^l \not\in \qvar_{c} .
% \right\}\]
%

% \wq{To do: Add $\THESYSTEM$, a data flow analysis algorithm to scan the program and give a graph.}
% {\THESYSTEM} consists of three phases: 
% \begin{enumerate}
%     \item Generating an abstract transition graph with each edge representing an abstract event transiting between two command labels. 
%     \item Computing the value bound invariant for each variable in the event and 
%     the event transition closure over the abstract transition graph,
%     we get the reachability bound for each labeled command.
%     \item Refining the abstract transition graph with data-flow, by performing the reaching definition analysis, we generate a weighted data control flow graph.
%     \item An algorithm to find the appropriate path in the weighted data control flow graph
% \end{enumerate}

% \begin{enumerate}
%     \item An algorithm to generate a precise data control flow graph
%     \item An algorithm to perform a Reachability number analysis to calculate the weight of each node in the graph generated in phase 1.
%     \item An algorithm to find the appropriate path in the weighted data control flow graph
% \end{enumerate}

% \subsection{Edge and Weight Estimation}
% \label{sec:alg_weightedgegen}

% Since the edges of the execution-based graph of a program relies on the dependency relation, which handles both control flow and data flow, as an over-approximation of this graph, the edges of our static anlaysis dependency graph also covers these two kind of flows. We develop a feasible data flow relation to catch these two flows, in Section~\ref{sec:alg_edgegen}.


% The weight of every vertice in the execution-based graph is built on all possible execution traces.
% In order to over-approximate the weight statically but still tightly, we present a symbolic reachability bound analysis for estimation of the weight of each vertice(label) in Section~\ref{sec:alg_weightgen},
% in spirit of some reachablility bound techiniques.


% The edges and weight estimation are both performed on basis of an abstract transition graph of the program, we first show how to generate this abstract transition graph before the introduction of  the edge and weight estimation.  

% This analysis first 
%  generate an abstract transition graph
%  over all program labels, 
% in order to analyzing the data flow relations through variables assigned in every labeled command,
% and the reaching time of each variable.
% Then, it refines this control flow graph 
% % into a weighted data-dependency graph, 
% and generate the Program-Based Dependency Graph,
% through the data flow and reaching bound analysis results.
% In the last step, it finds the longest finite walk in this weighted data control flow graph w.r.t. the query variables,
% and return the number of query vertices traversed alongside.
% % \wq{To do: Add $\THESYSTEM$, a data flow analysis algorithm to scan the program and give a graph.}
% To be more specific, {\THESYSTEM} consists of five phases as follows,
% \\
% % \jl{Better to have a graph or picture of overview of the algorithm}
% \todo{graph}
% \todo{pass again}
% This analysis
% \begin{enumerate}
%     % \item Generating 
%     \item first generate 
%     an abstract transition graph
%     %  over all labels,
%     (remove?? with program's labels as vertices and abstract transitions as edges)
%     in Section~\ref{sec:abscfg},
%     % used to analyze 
%     for analyzing the weight of every vertex in $\progV(c)$ and edges between every vertex in $\progV(c)$ in the next two steps;
%     %  \ref{sec:alg_weightgen} and 
%     % \ref{sec:alg_edgegen}.

%     % which are used as program's control locations,
%     %
%     \item then use the abstract transition graph generated above, 
%     compute the weight of every vertex in $\progV(c)$ by computing a symbolic reachability bound for each label in Section~\ref{sec:alg_weightgen},
%     % \\
%     \item and then use the same graph again to estimate the edges between every vertex in $\progV(c)$ by computing the feasible data flow relation between every labeled variables in Section~\ref{sec:alg_edgegen}.
  
% \end{enumerate}

\subsection{Constraint Program (Abstract Transition Graph)}
\label{sec:abscfg}

This path-sensitive reachability-bound algorithm
is performed on basis of a \emph{Constraint Program}.
A constraint program is an abstract transition graph.
We first show how to generate this abstract transition graph before the introduction of  the edge and weight estimation.  
We discuss the vertices and edge of the
abstract transition graph for a program $c$, $\absG(c)$.

\subsubsection{Vertices Construction}
\label{sec:abscfg-vertex}
Every 
vertex corresponds to the unique
label.
Specifically,
the vertices of this graph is the set of $c$'s labels with the exit label ${\lex}$, 
\[ 
  \absV(c) = \lvar(c)\cup\{{\lex}\}
  \]
%  corresponding to a label command in the program.

\subsubsection{Edge Construction}
\label{sec:abscfg-edge}
  The vertices can be easily collected and the key point of construction of the abstract
  transition graph for a program is the edge.
  It relies on the control flow analysis and the abstraction of the program's each command.
  %  and abstract transition (we also call it abstract event).
  To make it easy to understand, it
  is a control flow graph, with annotations on every edge.
  The annotation of each edge is generated by abstracting the program's every command.
It is computed as follows.
  % The edge in the abstract transition graph comes from the abstract execution trace of the program. 
  % The abstract execution trace, an abstract representation of the execution, consists of a set of abstract events. 
%   The edge in the abstract transition graph comes from the program's abstract events set $\absflow(c)$.
%   Each abstract event $(l_1, dc, l_2)$ in this set represents an edge in $\absE(c)$.
%   % Then, every abstract transition in the abstraction execution trace corresponds to an edge in the abstract transition graph. In another word, the edge $(l_1, dc, l_2)$ in the abstract transition graph, represents an abstract transition 
% %  from $l_1$ to $l_2$, with a set of difference constraints $dc$. 
%  Also notice, the difference constraints generated during the abstract transition appears in the edge as annotation.
%
\paragraph{Constraint}
Given a program $c$,
every expression in an assignment command or in the guard of a $\eif$ or $\ewhile$ command
is transformed into a constraint.

\highlight{Notations / Formal Definitions:}
\begin{itemize}
\item Operator: $\absexpr : \mathcal{A} \cup \mathcal{B} \to DC(\mathcal{VAR}  \cup \constdom)\cup \booldom \cup \{\top\}$
%
\item Constraints $\dcdom^{\top}: DC(\mathcal{VAR}  \cup \constdom) \cup \booldom \cup \top$  contains:
%
\begin{itemize}
\item Difference Constraints $DC(\mathcal{VAR}  \cup \constdom)$ is the set of all the inequality of form $x \leq y + v$ where $x \in \mathcal{VAR} $, 
$y \in \mathcal{VAR}$ and $v \in \constdom$.
The \emph{Symbolic Variables} $\constdom = \mathbb{N} \cup \inpvar$ is the set of natural number and input variables. 
%
\item The Boolean Expressions $\booldom$
%
\item The infinity $\top$.
\end{itemize}
\end{itemize}

\highlight{Computation Steps:}
\begin{defn}{Constraint Computation}
  \[
    \begin{array}{ll} 
      \absexpr(x - v, x)  = x' \leq x - v  & x \in \grdvar \land v \in \mathbb{N} \\
      \absexpr(y + v, x)  = x' \leq y + v  & x \in \grdvar \land v \in \mathbb{Z} \land y \in (\grdvar \cup \constdom) \\
      \absexpr(v, x)  = x' \leq v + 0  & x \in \grdvar \land v \in (\grdvar \cup \constdom) \\
      \absexpr(y + v, x)  = x' \leq y + v & \\
      \grdvar = \grdvar \cup \{y\} & x \in \grdvar \land v \in \mathbb{Z} \land y \notin (\grdvar \cup \constdom)  \\
      % \absexpr(\qexpr, x)  = x' \leq 0 + Q_m & x \in \grdvar \land \qexpr \text{ is a query expression}  \\
      \absexpr(\bexpr, \top) = \bexpr   & \\
      % \absexpr(y + v, x)  = x' \leq y + v & \\
      \grdvar = \grdvar \cup FV(\bexpr) &  x \in \grdvar \land \bexpr \text{ is a boolean expression} \\
      \absexpr(\expr, x) = x' \leq \infty  &  x \in \grdvar \land \expr \text{ doesn't have any of the forms as above} \\
      \absexpr(\expr, x) = \top  &  x \notin \grdvar \\
    \end{array}
    \]
  \end{defn}
  
  % \wq{ 
    $\grdvar$ is the set of variables used in the guard expression of every while command in the program $c$. 
  % }. 
  In the case 4, if a variable $x$, belonging to the set 
  $\grdvar$ is updated by a variable $y$, which isn't in this set, 
  we add $y$ into the set $\grdvar$ and repeat 
  above procedure  until $\grdvar$ and $\absexpr(\expr, x)$ is stabilized. 
  % \wq{I do not understand this sentence:-(}
  \\
Specifically 
% understanding the intuition, 
we handle a 
% simplified 
normalized guard expression ($ x > 0$ for $x^l \in \lvar_c$)
 in $\ewhile$, and 
%  \wq{I do not understand this sentence:-(}
%  .
% \\
% The counter variables only increase, decrease or reset by expression in the form of arithmetic minus and plus (able to extend to max and min.)
the counter variables only increase, decrease or reset by 
% expression in the form of 
simple arithmetic expression (mainly multiplication, division, minus and plus (able to extend to max and min)). 
This is the same as in paper \cite{sinn2017complexity}. 
\\
For more complex expression assignments, where the counter reset, or calculated from $\elog$, 
multiplication or division, and expressions involving multiple variables, the constraint is approximated as reset of $\infty$.
\\
% This simplification \wq{which part we simplify here?} 
This approximation strategy
doesn't affect our analysis results in our examples. It is easy to extend the normalized expression 
into more complex forms as in \cite{sinn2017complexity}, as well as the 
counter variable manipulation with more advanced expressions.
% \\ 
% The boolean expression in the guard of $\ewhile$ command is normalized into form of $ x > 0$ where $x^l \in \lvar_c$ for some $l$.
\begin{defn}[Symbolic Expression ($\mathcal{A}_{S}$)]
  $\mathcal{A}_{S}$ is the set of all the symbolic expressions 
over $\constdom$.
% For concise, $\mathcal{A}_{\lin}$ is used as the same meaning of $EXPR(\constdom)$ in the follows, to denote the arithmetic expression 
% over the symbolic variables, (i.e., $\mathbb{N}$ with input variables).
\end{defn}
The symbolic expression set is a subset of arithmetic expressions over $\mathbb{N}$ with input variables, 
i.e., $\mathcal{A}_{S} \subseteq \mathcal{A}_{\lin}$.
% \subsubsection{Abstract Transition Graph through an Example}
\paragraph{Abstract Initial and Final State} are enriched program's initial and final states from the standard control flow analysis.

%
\highlight{Notations / Formal Definitions:}
\begin{itemize}
\item The abstract initial state: $\absinit(c) \in \ldom$.
%
\item The abstract Final State: $\absfinal(c) \in \mathcal{P}(\ldom \times \dcdom^{\top})$
\end{itemize}

\highlight{Computation Steps:}
\begin{itemize}
  \item The \emph{Abstract initial state} for a program $c$ is the initial label of this program.
This label corresponds to the first labeled command of this program 
when executing this program.
\\
Given a program $c$, its abstract initial state is computed as follows,
%
\[
  \begin{array}{ll}
    \absinit(\clabel{\assign{x}{\expr}}{}^l)  & = l  \\
    \absinit(\clabel{\assign{x}{\expr}}{}^l)  & = l \\
    \absinit(\clabel{\eskip}^{l})  & = l \\
    \absinit(\eif [b]^l \ethen c_1 \eelse c_2)  & = l \\
    \absinit(\ewhile [b]^l \edo c)  & = l \\
    \absinit(c_1 ; c_2)  & = \absinit(c_1) \\
 \end{array}
 \]
%
%
\item The \emph{Abstract Final State} of the program $c$, 
$\absfinal(c) \in \mathcal{P}(\ldom \times \dcdom^{\top})$
is a set of pairs, with a label as first component and a constraint as the second component.
Every pair in $\absfinal(c)$ corresponds to a labeled command of $c$,
and the constraint in this pair is computed by $\absexpr$ in the first step.
\\
Given a program $c$, its final state is computed as follows,
$\absfinal: \cdom \to \mathcal{P}(\ldom \times \dcdom^{\top})$,
% computes the set of Abstract Final State for the command. 
 \[
  \begin{array}{ll}
    \absfinal(\clabel{\assign{x}{\expr}}{}^l)  & = \{(l, \absexpr\eapp (\expr, x))\}  \\
    %  \absfinal(\clabel{\assign{x}{\query(\qexpr)}}{}^l)  & = \{
    %   (l, x' \leq 0 + Q_m )\}  \\
     \absfinal(\clabel{\eskip}^{l})  
     & = \{(l, \top)\} \\
     \absfinal(\eif [b]^l \ethen c_1 \eelse c_2)  & = \absfinal(c_1) \cup \absfinal(c_2) \\
     \absfinal(\ewhile [b]^l \edo c)  & = \{(l, \absexpr(\bexpr, \top))\} \\
     \absfinal(c_1 ; c_2)  & =  \absfinal(c_2) \\
 \end{array}
 \]
 %
\end{itemize}
 \paragraph{Abstract Event} is the edge between control locations in the abstract transition graph.
 
 \highlight{Notations / Formal Definitions:}
 \begin{itemize}
  \item \emph{Abstract Event}: 
  $\absevent \in $
  $\ldom \times \dcdom^{\top} \times \ldom$
  \item \emph{Abstract Event Computation}: $\absflow \in \cdom \to \mathcal{P}( \ldom \times \dcdom^{\top} \times \ldom )$
 \end{itemize}
 Its type is defined as follows,
 \begin{defn}[Abstract Event]
   \label{def:abs_event}
   Abstract Event: 
   $\absevent \in $
   $\ldom \times \dcdom^{\top} \times \ldom$
   is a 
   % pair of abstract initial state and final state.
   triple where the first and third components are labels,
   second component is a constraint from $\dcdom^{\top}$.
   % the thrid % computed from program's abstract final and initial state, $\absfinal(c)$ and $\absinit(c)$ with formal definition, and algorithm detail in Appendix.
   %  the constraint and the third corresponds to a final state.
   \end{defn}
   Specifically, in an abstract event, 
   the first label correspond to an initial state, and 
   the second label and the constraint correspond to an abstract final state.
  The abstract initial state is a label from $\ldom$.
 The abstract final state is a pair from $\ldom \times \dcdom^{\top}$,  
 where first component is a label from $\ldom$ and the second component is a constraint from $\dcdom^{\top}$.
 %
 For simplicity, we use $\mathcal{P}(\absevent)$ represent the power set of all abstract events.

 \highlight{Computation Steps:}
\\
The abstract event is computed for w.r.t the program in Definition~\ref{def:absevent_compute}, 
%  generated during computing its abstract execution trace, 
%  , and we have $\absflow(c) \in \mathcal{P}(\absevent)$.
%  Now, we  extract the abstract execution trace  $\absflow(c)$ for a program, which computes the 
%  The \emph{Abstract Execution Trace} for program $c$ is a s
The set of the abstract events $\absflow(c)$ for a program $c$
% .
%  Its type is formally defined 
is computed as follows in Definition~\ref{def:absevent_compute}.
 %
 \begin{defn}[Abstract Event Computation]
 \label{def:absevent_compute}
  $\absflow \in \cdom \to \mathcal{P}( \ldom \times \dcdom^{\top} \times \ldom )$
  \end{defn}
 %
 The \emph{Abstract Execution Trace} for program $c$ is computed as follows.
 \\
  % We now show how to compute the abstract execution trace. 
 We first append a $\eskip$ command with 
%  a symbolic label $l_e$, i.e., $\clabel{\eskip}^{l_e}$ at the end of the program $c$, and compute the $\absflow(c) = \absflow'(c')$ for $c'$, where $c' = c;\clabel{\eskip}^{l_e}$ as follows,
the label $\lex$, i.e., $\clabel{\eskip}^{l_{ex}}$ at the end of the program $c$, and construct 
the program $c' = c;\clabel{\eskip}^{l_{ex}}$.
Then, we compute the $\absflow(c) = \absflow'(c')$ for $c'$ as follows,
 %
 {\footnotesize
 \[
   \begin{array}{ll}
      \absflow'(\clabel{\assign{x}{\expr}}{}^l)  & = \emptyset  \\
      \absflow'(\clabel{\assign{x}{\query(\qexpr)}}{}^l)  & = \emptyset  \\
      \absflow'([\eskip]^{l})  & = \emptyset \\
      \absflow'(\eif [b]^l \ethen c_t \eelse c_f)  & =  \absflow'(c_t) \cup \absflow'(c_f)
        \\ & \quad 
        \cup \{(l, \absexpr(\bexpr, \top),  \absinit(c_t) ) ,  (l, \absexpr(\neg\bexpr, \top), \absinit(c_f)) \} \\
       \absflow'(\ewhile [b]^l \edo c_w)  & =  \absflow'(c_w) \cup \{(l, \absexpr(\bexpr, \top), \absinit(c_w)) \} 
       \\ & \quad 
       \cup \{(l', dc, l)| (l', dc) \in \absfinal(c_w) \} \\
       \absflow'(c_1 ; c_2)  & = \absflow'(c_1) \cup  \absflow'(c_2) 
       \\ & \quad 
       \cup \{ (l, dc, \absinit(c_2)) | (l, dc) \in \absfinal(c_1) \} \\
   \end{array}
   \]
   }
   Notice $\absflow'([x := \expr]^{l})$, $\absflow'([x := \query(\qexpr)]^{l})$ and $\absflow'([\eskip]^{l})$ are all empty set. 
   For every event $\event$ with label $l$ in an execution trace $\trace$ of program $c$, 
   there is an abstract event in program's abstract execution trace of form $(l, \_, \_)$.  
   We also show the soundness of the abstract events computation in Appendix.

 \highlight{Theorem Guarantee:}
   \begin{lem}[Soundness of the Abstract Events Computation]
     \label{lem:abscfg_sound}
   Given a program ${c}$, we have:
   %
   \[
     \begin{array}{l}
       \forall \vtrace_0, \trace \in \mathcal{T} ,  \event = (\_, l, \_) \in \eventset \st
   \config{{c}, \trace_0} \to^{*} \config{\eskip, \trace_0 \tracecat \vtrace} 
   \land \event \in \trace 
   \\
   \qquad \implies \exists \absevent = (l, \_, \_) \in (\ldom\times \dcdom^{\top} \times \ldom) \st 
   \absevent \in \absflow(c)
   \end{array}
   \]
   \end{lem}
%    This lemma is proved formally in Appendix~\ref{apdx:pathinsensitive_rb_soundness}.
% For every event $\event$ with label $l$ in an execution trace $\trace$ of program $c$, 
% there is an abstract event in program's abstract events computation of form $(l, \_, \_)$. 
This lemma is proved formally in Lemma~\ref{lem:abscfg_sound} in Appendix~\ref{apdx:pathinsensitive_rb_soundness}.
\\
For every labeled variable in program $c$, $x^l \in \lvar_c$, 
there is a unique abstract event in the program's abstract events set $\absevent \in \absflow(c)$ of form $(l, \_, \_)$. 
\begin{lem}[Uniqueness of the Abstract Events Computation]
  \label{lem:abscfg_unique}
Given a program ${c}$, we have:
%
\[
  \begin{array}{l}
    \forall \vtrace_0, \trace \in \mathcal{T} ,  \event = (\_, l, \_, \_) \in \eventset^{\asn} \st
\config{{c}, \trace_0} \to^{*} \config{\eskip, \trace_0 \tracecat \vtrace} 
\land \event \in \trace 
\\
\qquad \implies \exists! \absevent = (l, \_, \_) \in (\ldom\times \dcdom^{\top} \times \ldom) \st 
\absevent \in \absflow(c)
\end{array}
\]
\end{lem}
This lemma and proof is also 
formalized in Lemma~\ref{lem:absevent_unique} in Appendix~\ref{apdx:pathinsensitive_rb_soundness}.

  \paragraph{Edge Construction}
  we build the edge for $c$'s abstract transition graph as follos,
  \[
    \absE(c) = \{(l_1, dc, l_2) | (l_1, dc, l_2) \in \absflow(c)\}
    \]
    The edge in the abstract transition graph comes from the program's abstract events set $\absflow(c)$.
  Each abstract event $(l_1, dc, l_2)$ in this set represents an edge in $\absE(c)$.
  % Then, every abstract transition in the abstraction execution trace corresponds to an edge in the abstract transition graph. In another word, the edge $(l_1, dc, l_2)$ in the abstract transition graph, represents an abstract transition 
%  from $l_1$ to $l_2$, with a set of difference constraints $dc$. 
 The constraints generated in the abstract event appears in the edge as annotation.
% We have a pre-processing algorithm to go through the programs and returns the list of labels associating with a loop and whose visiting times need to be analyzed.
%
\subsubsection{Constraint Program (Abstract Transition Graph) Construction} 
With the vertices $\absV(c)$ and edges $\absE(c)$ ready, we construct the abstract transition graph, formally 
% Through a program $c$'s abstract events computation, its abstract transition graph is computed 
defined in 
Definition~\ref{def:abs_cfg}.
%
\begin{defn}[Abstract Transition Graph (Constraint Program)]
\label{def:abs_cfg}
Given a program $c$, 
its \emph{abstract transition graph} (\emph{constraint program}) $\absG(c) =(\absV(c), \absE(c))$ is defined as follows,
\\
$\absE(c) = \{(l_1, dc, l_2) | (l_1, dc, l_2) \in \absflow(c)\}$,
\\
$\absV(c) = \lvar(c)\cup\{l_{ex}\}$
% \\
%  $\absW(c) 
% \triangleq \left\{ (l, w) \in \mathbb{L} \times EXPR(\constdom) \right\}$.
\end{defn}
% \\
% Notice we also define the $\absW(c)$ in this graph without giving an actual value.
% This $\absW(c)$ is the set of weight for every 
% % vertex 
% label. 
% The weight $w \in EXPR(\constdom)$ is a symbolic expression over the symbolic constant, 
% which is the estimated upper bound on the number of visiting time for every control location
% through the reachability bound analysis as follows.
%
% $EXPR(\constdom)$ is the set of all the symbolic expressions 
% over $\constdom$, which is a subset of arithmetic expressions over $\mathbb{N}$ with input variables.
% For concise, $\mathcal{A}_{\lin}$ is used as the same meaning of $EXPR(\constdom)$ in the follows, to denote the arithmetic expression 
% over the symbolic variables, (i.e., $\mathbb{N}$ with input variables).
\subsubsection{Constraint Program (Abstract Transition Graph) through An Example}
\label{sec:abscfg_example}
% 
% Look at the two-round example again, its generated abstract control is shown as in Figure~\ref{fig:adapfun_tworound}(a).
% In this abstract transition graph, every vertex is a label,
% corresponding to a label command in the program.
% Each directed 
% edge represents an abstract transition 
% between two control locations, 
% i.e., the labels of two commands (we call the labels also control location and they refer to the same thing), 
% where the second labeled command will be executed after execution of the command with first label.
% For example, the edge $0, a \leq 0, 1$ on the top, represents,
% from location $0$, the command 
% $\clabel{\assign{a}{0}}^0$ is executed with next continuation location $1$,
% where the 
% command $\clabel{\assign{j}{k}}^1$ will be executed next.
% The constraint $a \leq 0$ is generated by abstracting from the assignment command $\assign{a}{0}$,
% representing that value of $a$ is less than or equals to $0$ after 
% location $0$ before executing command at line $1$.
% %
% The same way for the rest edges' constructions.
%
\input{examples_psrb/whileSim_abscfg}
%
\subsection{\highlight{Program Refinement}}
\label{sec:pathsensitive_rb-refine}
In order to analyze the reachability bound path-sensitively, we first refine the constraint program.
%
  \paragraph{Simple Transition Path}
%
A \emph{simple transition path} is a path of a constraint program, $\tpath \in \paths(\absG(c))$.
It either
\begin{itemize}
  \item contains only one loop (without any nested loop) starting from a loop header at location $l$ and go back to the same $l$;
  \item or doesn't contain a loop, starting from a loop header $l$ (or the program entrance $l_0$)
and ending with different loop header $l'$ (or the program exist $\lex$).
\end{itemize}
  \begin{defn}[Simple Tansition Path]
  A simple transition path
  $\tpath \in \paths(\absG(c))$, is a path on this program's abstract transition graph $\absG(c)$ with 
  \begin{itemize}
  \item vertices sequence $(l_1 \to \cdots \to l_n)$ and
  %
  \item edge sequence $(l_i, dc_i, l_{i + 1}) \in \absE(c)$ for every $i = 1, \cdots, n-1$,
  \end{itemize}
  %
  satisfying:
  \begin{itemize}
    \item $l_1 \to \cdots \to l_n \in \lvar(c)$,
    \item $l_i \neq l_j$ for all $l_i\in (l_1 \to \cdots \to l_{n})$ and $l_j \in (l_1 \to \cdots \to l_{n - 1})$,
    \item $l_1$ is the control location of a loop header or $l_1 = l_0$,
    \item and $l_n$ is the control location of a loop header or $l_n = \lex$.
  \end{itemize}
  \end{defn}

  % For the part of the graph not in any SCC:

  % and end of $p'$ are both $l$;
  % \\
  %
% \item 
\paragraph{Repeat Pattern}
A \emph{Repeat Pattern} ($\rprog \in \mathcal{P}({\absG(c)})$) is either a simple path or sequence of repeat patterns of this program $c$. 
\[
  \rpattern := \tpath ~|~ \rprepeat(\rpattern) ~|~ \rpattern; \rpattern
\]
Every $\rprog'$ with the annotation $\rprepeat$, (for example, $\rpattern = \rprepeat(\rpattern')$)
can consecutively execute at least twice.
Every two sub-repeat patterns following each other in a $\rprog$ can execute in sequence, for example in $\rpattern = \rpattern_1; \rpattern_2$,
$\rpattern_2$ can execute after $\rpattern_1$.
Every sub-repeat patterns in the sequence are distinct.
%  , i.e.,
% $rprog_i, rprog_j \in \rprog_1; \cdots; \rprog_n$, $\rprog_i \neq \rprog_j$.
% \\
% \begin{defn}[Repeat Pattern]
%   A \emph{Repeat Pattern} is a simple path or a sequence of \emph{Repeat Pattern}
%   \[
%     \rprog := \tpath ~|~ \rprepeat(\rprog) ~|~ \rprog; \rprog
%   \] 
%   satisfying,
%   \begin{itemize}
%   \item $\rprog$ can consecutively execute at least twice, and
%   \item
%   for every 
%   $\rprog_i, \rprog_j \in \rprog_1; \cdots; \rprog_n$, $\rprog_i \neq \rprog_j$.
%   \end{itemize}
% \end{defn}
%

\highlight{\textbf{Formal Definition:}}
\begin{defn}[Repeat Pattern of A Program]
  Given a constraint program $\absG(c)$,
  $\rpattern(c)$ is a \emph{Repeat Pattern} of $\absG(c)$ if and only if, it is a simple path or
  a sequence of \emph{repeat pattern}
  has the following syntax
  \[
    \rpattern := \tpath ~|~ \rprepeat(\rpattern) ~|~ \rpattern; \rpattern
  \] 
  and satisfying,
  \begin{itemize}
  \item every sub-repeat pattern $\rpattern' \in \rpattern(c)$ with the annotation $\rpattern$
  can consecutively execute twice
  %  when executing this program $c$ 
  w.r.t. some initial trace,
  \item every sub-repeat patter in a sequence is distinct, i.e., $\rpattern(c) = \rpattern_1; \cdots; \rpattern_n$ and 
  $\rpattern_i, \rpattern_j \in \rpattern_1; \cdots; \rpattern_n$, $\rpattern_i \neq \rpattern_j$,
  \item and every two continuous sub-repeat patters in a sequence can execute after each other w.r.t some initial trace,
  i.e., $\rpattern(c) = \rpattern_1; \cdots; \rpattern_n$ and 
  $\rpattern_{i - 1}, \rpattern_{i} \in \rpattern_1; \cdots; \rpattern_n$, 
  $\rpattern_2$ can execute after $\rpattern_1$ under some initial trace.
  \end{itemize}
\end{defn}
%
\highlight{\textbf{Computation Steps Summary:}}
\begin{enumerate}
  \item Checking the precondition and post-condition of every simple transition path,
  \item 
Recursively checking the precondition and post-condition of every $\rpattern$ in the output set.
Append a pattern to another if the execution condition of the first one
is true after the previous's executing condition is false.
\item Repeating the two steps until the output set is stabilized.
\end{enumerate}

\highlight{\textbf{Pseudocode:}}
\begin{algorithm}
\caption{
{Repeat Pattern Computation}
\label{alg:repeat-pattern}
}
\begin{algorithmic}[1]
\REQUIRE the constraint program $\absG(c)$
% the target while loop with label $l$.
\STATE  \textbf{Init} $R(c) = \emptyset$
\\
\qquad Finding all simple transition paths $ \tpath_1, \cdots, \tpath_m \in \absG(c)$.
\STATE  
\textbf{For} every simple transition paths $\tpath_1, \cdots, \tpath_m$:
%  having the same starting and ending label:
\\
\quad Generating
$\rpattern_{i} = (\tpath_i)$ and add into $R(c)$.
%  otherwise $\rpattern_i = \tpath_i$.
% \\
% \quad Adding $\rpattern_{i}$ into $R(c)$.
\STATE  \textbf{Loop} until there isn't new repeat patterns generated, i.e., $R(c)$ is stabilized.
\STATE  \quad \textbf{For} every repeat pattern $\rpattern_i \in R(c)$ having the same starting and ending label:
\STATE  \quad \quad Generating $\rpattern_{i}' = \rprepeat(\rpattern_i)$ if $\rpattern_i$ can consecutively execute twice.
\STATE  \quad \textbf{For} every repeat pattern $\rpattern_1, \cdots, \rpattern_m \in R(c)$
\STATE \quad \quad  Generate $\rpattern' = \rpattern_{i}; \rpattern_{j} $ 
if the execution condition of $\rpattern_{j}$
is true after $\rpattern_{j}$'s executing condition is false.
\RETURN $R(c)$
\end{algorithmic}
\end{algorithm}
% \\
% % Through Path-Sensitive Refinement / Contextualization algorithm \cite{GulwaniJK09, ZulegerGSV11},
% % this step computes the repeat patterns over all \emph{simple transition path}s.
% \\
%   $\rprog \in \mathcal{RP}$.
%   % For a Loop $L$,
%   % computes all the transition Paths : $\tpath \in \absG(c)$
%   % ->  $\rprog \in \mathcal{RP}$
%   % in this loop and generate the refined statement.
%   \\
%   $p \triangleq \tpath $ if $\tpath \in \paths(\absG(c))$ and $\tpath \not\in SCC(\absG(c))$;
%   \\
%   $p \triangleq \rpchoose\{p_1, p_2 \}$ if $p_1$ and $p_2$ has the same head and end;
%   \\
%   $p \triangleq p_1; p_2$ if head of $p_1$ is the same as head of $p_2$ and either $p_1$ or $p_2$ isn't a simple path. 
%   % \\
%   % For the part of the graph not in some SCCs:
%   % \\
%   % For every while loop with guard label $l$:
%   % \\
%   % $p \triangleq \tpath $ if $\tpath \in \paths(\absG(c))$
%   \\
%   $p \triangleq L_l : \rprepeat(\rpchoose\{p_1, \cdots, p_m\})$ if head and end of $p'$ are both $l$;
%   Given a rephrased program $p$, its refined program is computed as follows,
%   \\
%   $\rprog \triangleq \tpath $ if $p = \tpath$\\
%   $\rprog \triangleq \rpchoose\{\rprog_1, \rprog_2 \}$ where $p \triangleq \rpchoose\{p_1, p_2 \}$ and 
%     $\rprog_1$ and $\rprog_2$ are refined $p_1$ and $p_2$. 
%     \\
%   $\rprog \triangleq L_l : \kw{REFINE(p_w)}$  if $p = \rprepeat(p_w)$ and  $\kw{REFINE(p_w)}$ is the algorithm in \\
%   $\rprog \triangleq \kw{REFINE(p_1)}; \kw{REFINE(p_2)}$  if $p = p_1; p_2$ 
\paragraph{Refined Program}
A \emph{Refined Program} for a program $c$, ($\rprog \in \mathcal{P}(\mathcal{P}(\absG(c)))$),
is either a repeat pattern, or a set of refined program, or sequence of refined program
% ($\rprog \in \mathcal{P}({\absG(c)})$) is either a simple path or sequence of repeat patterns. 
\[
  \rprog :=  \rprepeat ~|~ \rpchoose{\rprog} ~|~ \rprog; \rprog.
\]
It satisfies,
\begin{itemize}
  \item every refined program in the same set starts and ends with the same label
  \item and for every two sub-refined programs following each other in a sequence,
    the first refined program's ending label is the same 
    as the starting label of the second refined program.
    For example if
    $\rprog = \rprog_0; \cdots; \rprog_n$,
    $\rpattern_1 \in \rprog_i$
    and $\rpattern_2 \in \rprog_{i + 1}$,
    then $\rpattern_1$ ends with the same label as $\rpattern_2$'s starting label.
\end{itemize}
%

\highlight{\textbf{Formal Definition:}}
\begin{defn}[Refined Program of A Program]
  Given a constraint program $\absG(c)$,
  its \emph{Refined Program} is either a repeat pattern, or a set of refined program, or sequence of refined program has
  the following syntax,
  \[
    \rprog :=  \rprepeat ~|~ \rpchoose{\rprog} ~|~ \rprog; \rprog.
  \]
  It satisfies that for every sub refined program $\rprog' \in \rprog$
  % $\rprog = \rprog_1, \cdots; \rprog_n$ and
  % $\rprog_i = \{\rpattern_{0}; \cdots; \rpattern_{i_n}\}$, $n, i_n \in \mathbb{N}$ and
  \begin{itemize}
  \item if
   $\rprog' = \rpchoose{\rprog_1, \cdots, \rprog_m}$,
   then all the $\rprog_1, \cdots, \rprog_m$ have the same starting and ending label,
  \item if $\rprog' = \rprog_1; \rprog_2$, then
  % and for every $\rpattern_1 \in \rprog_i$ and $\rpattern_2 \in \rprog_{i + 1}$,
  $\rprog_1$'s ending label is the same label as $\rprog_2$'s starting label.
  \end{itemize}
\end{defn}
%
\highlight{\textbf{Computation Steps Summary:}}
\begin{itemize}
\item Computing the repeat pattern set $RP(c)$ by Algorithm~\ref{alg:repeat-pattern}.
% 
\item For all patterns which is a simple transition path and not in any SCC,
generating a repeat pattern set for all
repeat patterns starting and ending with the same label.
\[
  \rprog_{s} \triangleq 
  \rpchoose{
  \rpattern ~|~ l_1, l_2 \in \lvar(c) \land 
  \rpattern = l_1 \to \cdots \to l_2 \in RP(c) 
  \land  \rpattern \notin SCC
    }
\]
%
\item 
For every \emph{outermost loop} with the header at location $l$,
recursively 
find all the repeat patterns $\rpattern_{i}, \cdots, \rpattern_{m}$ starting form $l$ and go back to $l$, where $m \in \mathbb{N}$.
\\
Adding a loop head annotation $l$ on the beginning of every repeat pattern $l: \rpattern$.
\\
% For every \emph{outermost loop} with the header at location $l$ as follows ,
Generating a repeat pattern set for this loop recursively,
\[
  \rprog_l \triangleq 
  \rpchoose{
   l: \rpattern_{i}, \cdots, l: \rpattern_{m}
  }
\]
% \\%
\item
Generating the \emph{refined program} $\rprog$ as a sequence of repeat pattern sets.
%
\[
\rprog \triangleq \rprog_0; \cdots; \rprog_{\lex}
\]
%
% $\tpath_0$ is the simple path with the program entrance as the starting point
% and $\tpath_{\lex}$ is the simple path going to the program exit point.
% \\
Each repeat pattern set in $\rprog$ is either a set of simple transition paths $\rprog_{s}$ not in any while loop computed from step 1,
or a set of repeat patterns for a while loop $\rprog_l$.
\\
$\rprog_0$ contains the repeat patterns with the program entrance as the starting point
and $\rprog_{\lex}$ contains the repeat patterns going to the program exit point.
%
\end{itemize}
%

\highlight{\textbf{Pseudocode:}}
% \todo{algorithm} 
\begin{algorithm}
\caption{
{Program Refinement}
\label{alg:prog_refine}
}
\begin{algorithmic}[1]
\REQUIRE the constraint program $\absG(c)$
\STATE  compute repeat pattern set $PR(c)$ by Algorithm~\ref{alg:repeat-pattern}
% \\
\STATE  \textbf{For} $\rpattern \in RP(c)$:
\\ \quad 
$\rprog_{s} \triangleq 
  \rpchoose{
  \rpattern ~|~ l_1, l_2 \in \lvar(c) \land 
  \rpattern = l_1 \to \cdots \to l_2 \in RP(c) 
  \land  \rpattern \notin SCC
    }
$
\STATE \textbf{For} $\rpattern \in RP(c)$:
\\ \quad
$\rprog_l \triangleq 
\rpchoose{
 l: \rpattern_{i} ~|~ \rpattern \in RP(c) \land \text{ head and ending of } \rpattern \text{ are both } l.
}$
\STATE \textbf{For} every $\rprog_{s}$ and $\rprog_l$:
\\ \quad
      if any of them has a starting label equal to the ending label of another one,
put them into a sequence.
\\ 
$\rprog \triangleq \rprog_0; \cdots; \rprog_{\lex}$.
\RETURN $\rprog$
\end{algorithmic}
\end{algorithm}
%
%
\subsection{\highlight{Ranking Function / Local Bound Computation}}
\label{sec:pathsensitive_rb-lbcompute}
% The \emph{Path-Insensitive Reachability Bound} analysis is performed 
Ranking Function / Local Bound is computed on the abstract transition graph, 
through the edges in $\absG(c)$.
Every edge in $\absG(c)$ corresponds to the program $c$'s abstract transition between a pair of two labels.
We infer the invariant for every variable, and compute the transition closure for every abstract transition. By solving the closure
with the invariants of variables involved in this closure for every transition, we compute
the symbolic reachability bound of every commands corresponding to this transition. Specifically, this analysis can be performed in four steps:
 Variable Modification Tracking, Local Bounds Computation,
Variable Invariant Computation and Closure Generation, and Reachability Bound Computation,
% 
% We present the details of invariant, closure generation, and reachability bound computation as follows.
with details as follows.
%
%
\paragraph*{Variable Modifications Collection}
Identify the abstract events where each variable is increased, decreased and reset:
\\
$\inc: \mathcal{VAR} \to \mathcal{P}(\absevent) $
the set of the abstract events where the variable increase.
\\
$\inc(x) = \{(\absevent, c) | \absevent = (l, l', x' \leq x + v)\}$
\\
$\reset: \mathcal{VAR} \to \mathcal{P}(\absevent) $
The set of the abstract events where the variable is reset.
\\
$\dec: \mathcal{VAR} \to \mathcal{P}(\absevent) $
The set of abstract events where the variable decrease.
% \\
% $\dec(x) = \{(\absevent, c) | \absevent = (l, l', x' \leq x - v)\}$
\\
$Incr(v) \triangleq \sum\limits_{(\absevent, c) \in \inc(v)}\{\absclr(\absevent) \times v\}$
%
Based on this, 
Instead of just identifying the abstract events where each variable is reset,
this improvement identifies the chain of the events where a given variable is reset by the 
variables of the abstract events through the chain.
\\
$\resetchain: \mathcal{VAR} \to \mathcal{P}(\mathcal{P}(\absevent)) $
The set of the chain of abstract events where the variable is reset through the chain.
%
\paragraph*{Assign Ranks / Local Bound to Edges}
\begin{defn}[Ranks / Local Bounds Generatation]
  \label{def:lbgen}
Given a program $c$ with its abstract transition graph 
$\absG(c) = (\absV, \absE)$
\\
Local Bounds Computation:
$\locbound: \absevent \to \mathcal{VAR} \cup \constdom$.
%
\[ 
\begin{array}{ll}
  \locbound(\absevent) \triangleq 1 
  & \absevent \notin SCC(\absG(c))
  \\
  \locbound(\absevent) \triangleq (x, v) 
  & \absevent \in SCC(\absG(c)) \land \absevent \in \dec(x) \land  \absevent = (\_, \_ , x' \leq x - v) \\
  \locbound(\absevent) \triangleq (x, \max(\dec(x))) 
  & \absevent \in SCC(\absG(c)) \land 
  \absevent  \notin \bigcup_{x \in \mathcal{VAR}} \dec(x)
  \land \absevent \notin SCC(\absG(c) \setminus \dec(x)) 
\end{array}
  \]
\end{defn}
  The first case is straightforward. 
  For the label $l$ which is not in any while loop, 
  the labeled command with the label $l$ will be 
  evaluated at most once. 
  % we do not need to analyze the visiting times of every node in the graph from phase 1.
  The second and third cases are guaranteed by the \emph{Discussion on Soundness} in Section 4 in~\cite{sinn2017complexity}.
  Then soundness proof is in Lemma~\ref{lem:local_bound_sound} in Appendix~\ref{apdx:pathinsensitive_rb_soundness}.
%
% \paragraph*{Invariant Inference and Closure Generation }
% Then, computing the bound invariants for variables and the transition closures for abstract events:
% \\ 
% $ \varinvar: \mathcal{VAR} \cup \constdom \to EXPR(\constdom)$
% \\
% $\absclr: \absevent \to EXPR(\constdom)$
% \\
% $EXPR(\constdom)$ is symbolic expression 
% over $\constdom$, which is a subset of arithmetic expressions over $\mathbb{N}$ with input variables and $ $.
% We use $\mathcal{A}_{\lin}$ denotes the arithmetic expression 
% over the symbolic variables, (i.e., $\mathbb{N}$ with input variables and $ $).
% Then, the symbolic invariant for each variable 
% as well as the symbolic transition closure for each transition is calculated as follows:
% \[ 
% \begin{array}{lll}
%   \varinvar(x) & \triangleq c & c \in \constdom \\
%   \varinvar(x) & \triangleq Incr(v) + \max(\{\varinvar(a) + c | (t, a, c) \in \reset(x)\}) & c \notin \constdom
% \end{array}
% \]
% %
% \begin{defn}
%   \label{def:transition_closure_base}
% \[ 
% \begin{array}{lll}
%   \absclr(\absevent) 
%   & \triangleq x / v & \\ 
%   & \locbound(\absevent) = (x, v) \in \constdom \times \mathbb{N} & \\
%   \absclr(\absevent) 
%   & \triangleq (Incr(x) + 
%   \sum\limits_{(\absevent', y, v') \in \reset(x)}
%   \absclr(\absevent') \times \max(\varinvar(y) + v', 0) ) / v & \\
%   & \locbound(\absevent) = (x, v) \land x \notin \constdom & 
% \end{array}
%   \]
% \end{defn}
% %
% \paragraph*{Improved Variable Modification Tracking}
% \\
% $Incr(v) \triangleq \sum\limits_{(\absevent, c) \in \inc(v)}\{\absclr(\absevent) \times v\}$
%
\paragraph*{Ranks / Local Bounds Estimation}
% Then, computing the bound for vriables and the transition closures for abstract events:
First estimating the bounds on the (ranks'/ local bounds') maximum value.
% , the 
\\ 
$ \varinvar: \mathcal{VAR} \cup \constdom \to \mathcal{A}_{\lin}$
\\
$\absclr: \absevent \to \mathcal{A}_{\lin}$
\\
Then, the symbolic invariant for each variable 
as well as the symbolic transition closure for each transition is calculated as follows:
\[ 
\begin{array}{lll}
  \varinvar(x) & \triangleq c & c \in \constdom \\
  \varinvar(x) & \triangleq Incr(v) + \max(\{\varinvar(a) + c | (t, a, c) \in \reset(x)\}) & c \notin \constdom
\end{array}
\]
%
% \paragraph*{Path-Insensitive Loop Bound Computation}
Based on the bounds on ranks / local bounds' maximum value,
we estimate the bounds on the iteration times
% of the ranks / local bounds 
for each edge in a path-insensitive fashion.
% \\
% computing the loop bound in a path-insensitive way as the base step.
\\ 
$ \varinvar: \mathcal{VAR} \cup \constdom \to \mathcal{A}_{\lin}$
\\
$\absclr: \absevent \to \mathcal{A}_{\lin}$
\\
% Then, the symbolic invariant for each variable 
% as well as the symbolic transition closure for each transition is calculated as follows:
% \[ 
% \begin{array}{lll}
%   \varinvar(x) & \triangleq c & c \in \constdom \\
%   \varinvar(x) & \triangleq Incr(v) + \max(\{\varinvar(a) + c | (t, a, c) \in \reset(x)\}) & c \notin \constdom
% \end{array}
% \]
%
\begin{defn}
  \label{def:transition_closure}
\[ 
\begin{array}{lll}
  \absclr(\absevent) 
  & \triangleq x / v & \\ 
  & \locbound(\absevent) = (x, v) \in \constdom \times \mathbb{N} & \\
  \absclr(\absevent) 
  & \triangleq \Big(
    \sum\limits_{y \in \{ y ~|~ 
    ch \in \resetchain(x), (l_1, x, y, v, l_2) \in ch \} } Incr(x) & \\
    & \quad + 
  \sum\limits_{ch \in \resetchain(x)}
  \big( \min\limits_{\absevent' \in ch}({\absclr(\absevent')}) \times 
  \max(\varinvar(y) + \sum\limits_{(l_1, x, y, v, l_2) \in ch } v, 0)\big) \Big) / v & \\
  & \locbound(\absevent) = (x, v) \land x \notin \constdom & 
\end{array}
  \]
\end{defn}
  %
% \paragraph*{Adding the Reachability Bounds for Every Vertex in the Data-Control Flow Graph}
% Updating the weight of every vertex in the $\progG(c) = (\progV, \progE)$ for program $c$ generated from phase 1. 
% For every $x^l \in \progV$, find the abstract event $\absevent \in \absflow(c)$ of the form $(l, \_, \_)$, updating the $\progW(x^l) $ by the transition closure of this event.
% \\
% The \emph{Path-Insensitive Reachability Bound} 
\paragraph{Theorem Guarantee}
For a program $c$ is sound upper bound for every label $l$ in this program formally in Theorem~\ref{thm:pathinsensitive_rb_soundness}. 
Proof of this theorem is in Appendix~\ref{apdx:pathinsensitive_rb_soundness}.
%
\begin{thm}[Soundness of the Path-Insensitive Local Bound /Rank Estimation]
  \label{thm:pathinsensitive_rb_soundness}
Given a program ${c}$, for every label $l \in \lvar(c)$,
its \emph{Path-Insensitive Rank Bound} $w^p$ 
 is a sound upper bound for its 
 execution-based reachability bound $w^t$ 
 where $(l, w^p) \in \absW(c)$ and  $(l, w^t) \in \exeRB(c)$.
% $\traceG = (\traceV, \traceE, \traceW, \traceF)$, 
% we have:
  %
  \[
    \begin{array}{l}
      \forall c \in \cdom, l \in \lvar(c),\trace_0 \in \mathcal{T}_0(c), 
      \trace' \in \mathcal{T}, v \in \mathbb{N}
      % , (v, n) \in \mathcal{VAR} \times \mathbb{N} \times \mathbb{N}
       \st 
      %  \\ \quad
      (l, w_p) \in \absW(c)
      \land 
      (l, w_t) \in \exeRB(c)
      \\ \quad
      \land \config{{c}, \trace_0} \to^{*} \config{\eskip, \trace_0\tracecat\vtrace'} 
      \land 
      \config{w_{p}, \trace_0} \earrow v
      \implies
      % \right\} 
      w_{t}(\trace) \leq v
    \end{array}
    \]
\end{thm}

\subsection{Outside-In Algorithm}
\label{sec:pathsensitive_rb-outinalg}
%
% \\
For the refined program $\rprog \in \mathcal{RP}$, the \emph{Outside-In Algorithm}
computes the path-sensitive local bound 
% for the refined program $\rprog$ recursively 
$\outinB: \rprog \to \mathcal{A}_{in}$ as follows,
% \\
\\
The \emph{State}: 
$\absstate \in \mathcal{P}(\dcdom^{\top})$ : conjunctions of the edge annotations.
%  constraints.
\\
For a refined program ($\rprog$), there are the 
\\
\emph{Initial State} ($\rfinit(\rprog)$), 
\emph{Final State} ($\rffinal(\rprog)$), and \emph{Next State} ($\rfnext(\rprog)$)  $\in \absstate$.
% The \emph{Initial State}: $\rfinit : \rprog \to \absstate $.
\\
The \emph{Variable Grade Decedent}: $\varGD : \rprog \to \mathcal{A}_{in}$, is the set of the variables' variation in one iteration;
\\
Given a refined program $\rprog$, its path-sensitive local reachability bound is computed as follows,
\\
$\outinB(\rpchoose\{\rprog_i\}) =  \max\{\outinB(\rprog_i)\}$
\\
$\outinB(\rprepeat\{\rprog\}) =  \frac{\rfinit(\rprog) - \rffinal(\rprog)}{\varGD(\rprog)}$
\\
$\outinB(\rpseq(\rprog_1, \rprog_2)) =  \outinB(\rprog_1)+ \outinB( \rprog_2)$
\\
$\outinB(\tpath) =  1$.
\\
$\outinB(\rprepeat\{\rprog\})$ can also be computed using the algorithm
\\
$\kw{BOUNDFINDERD(INITD(c, l_0, \absinit(\rprog)), NEXTD(c, l_0, \absinit(\rprog), V_{\lin} )}$ 
in paper~\cite{GulwaniJK09} with equivalent results.
\\
% Formally defined as follows,
% \begin{defn}[Path-Sensitive Local Reachability Bound]
%   \label{def:pathsensitive_lrb}
% \end{defn}
The computations of the operations: $\rfinit(\rprog)$,
$\rffinal(\rprog)$ $\rfnext(\tpath)$ and $\varGD : \rprog \to \mathcal{A}_{in}$
are formally defined as follows,
\begin{itemize}
\item \emph{Initial State} ($\rfinit(\rprog)$).
\\
 For a refined program $\rprog$, its initial refined abstract $\rfinit(\rprog) \in \mathcal{P}(\absstate)$ is computed as follows,
\[
  \rfinit(\rprog) \triangleq 
  \bigwedge_{x \in VAR(\rprog)}
  \left\{ 
  x = v ~\middle\vert~ 
  v = arg\max_{l_1}\left\{ 
    v~\middle\vert~ 
    (v, \absevent) \in \reset(x) 
    \land \absevent = (l_1, dc, l_2)
    \land l_1 \leq \absinit(\rprog)
    \right\}
  \right\}
  \]
% \\
The $\rfinit : \rprog \to \absstate $  can also be computed using $INIT(c, l_0, \absinit(\rprog))$ algorithm in \cite{GulwaniJK09}. 
$INIT(c, l_0, \absinit(\rprog))$ computes the equivalent results.
%
\item  \emph{Final State} $\rffinal(\rprog) \in \absstate$.\\
The program $\rprog$'s final refined abstract state $\rffinal(\rprog) \in \mathcal{P}(\absstate) $ is computed as follows, 
\[
  \rffinal(\rprog) \triangleq 
  \bigwedge_{x \in VAR(\rprog)}
  \left\{ 
    \varinvar(x)
  \right\} \land \neg Invariant(\rprog)
  \]
  % \\
\item \emph{Next State} $\rfnext(\rprog) \in \absstate$.
\\
 For a transition path $\tpath \in \paths(\absG(c))$, its $\rfnext(\tpath)$ is computed as follows,
%
\[
  \begin{array}{l}
  \rfnext(\tpath) \triangleq 
  \bigwedge\limits_{x \in VAR(\rprog)}
  \left\{ 
    \begin{array}{l}
  x =   \sum\limits_{(x, \absevent) \in \inc(x) }\left\{ 
    \varinvar(y) + c ~\middle\vert~ \absevent = (l, (y, c), \_) \land l \in \lvar(\rprog)\right\}
    \\ \qquad 
    - \sum\limits_{(x, \absevent) \in dec(x) }\left\{ 
      \varinvar(y) + c ~\middle\vert~ \absevent = (l, (y, c), \_) \land l \in \lvar(\rprog) \right\}
    \end{array}
  \right\}
  \end{array}
\]
\item  The program $\rprog$'s Variable Gradient Decent set is computed as follows,
\\
$\varGD(\rpchoose\{\rprog_i\}) =  \max\{\varGD(\rprog_i)\}$
\\
$\varGD(\rprepeat\{\rprog\}) =  \outinB(\rprepeat\{\rprog\}) \times {\varGD(\rprog)}$
\\
$\varGD(\rpseq(\rprog_1, \rprog_2)) =  \varGD(\rprog_1)+ \varGD( \rprog_2)$
\\
$\varGD(\tpath) =  \rfinit(\tpath) - \rfnext(\tpath)$
\\
\end{itemize}
%
\subsection{Inside-Out Algorithm}
\label{sec:pathsensitive_rb-inoutalg}
For the refined program $\rprog \in \mathcal{RP}$, the \emph{Inside-Out Algorithm}
computes the path-sensitive bound on the iteration numbers for every simple transition path in this program $\rprog$,
through following steps.

\begin{enumerate}
  \item \emph{Local Repeat Chain Bound}.
  \\
  For every transition path $\tpath$, its \emph{Local Repeat Chain Bound} is the 
  path sensitive local bound for it, inside its closet while loop.
  It is computed as follows,
  \begin{enumerate}
\item \emph{Repeat Chain Set}
\\
\emph{Repeat Chain} $\rpch(L, \tpath) \in \mathcal{P}(\rprog)$.
\\
$L, \tpath$ 
repeat chain w.r.t a transition path
is a list of repeat pattern $\rprog$ with loop header annotation $L$,
and the $\tpath$ is contained by these repeat patterns recursively.
% inside the same while loop $L$ as the $\tpath$. It is computed as follows,
% For a refined while loop program $\rprog_{l} = L_l : \rprog \in \mathcal{RP}$, 
% with its refined statement $\rprog \in \mathcal{RP}$,
\\
\emph{Repeat chain set}
$\rpchset(L, \tpath, \rprog) \in \mathcal{P}(\mathcal{P}(\rprog))$.
\\
For each transition path in the refined program $\tpath \in \rprog$, 
its repeat chain set 
$\rpchset(L, \tpath, \rprog) \in \mathcal{P}(\mathcal{P}(\rprog))$
 is a set of all the repeat chains for $L, \tpath \in \rprog$ in this program.
 %
 \begin{defn}[Repeat China ($\rpch(L, \tpath) \in \mathcal{P}(\rprog)$)]
  \label{def:repeatchain}
 Every repeat chain is a list of refined program contained inside the same while loop $L$ as the $\tpath$. It is computed as follows,
\\
  % $\rpch(L_l, \tpath) \in \mathcal{P}(\rprog)$\\
  $\rpch(L, \tpath) \triangleq \rprog_n \to \rprog_{n-1} \to \cdots \to \tpath $
 such that 
 $\rprog_{i}= L : \rprepeat(\cdots, \rprog_{i - 1}, \cdots)$ and
 there isn't any loop label (i.e., $L'$) or $\rprepeat_i$ between $\rprog_{i}$ and $\rprog_{i - 1}$ for $i = n, \cdots, 1$.
\end{defn}
%
%
%
\begin{defn}[Repeat China Set ($\rpchset(L, \tpath, \rprog) \in \mathcal{P}(\mathcal{P}(\rprog))$)]
  \label{def:repeatchainset}
 Every repeat chain is a list of refined program contained inside the same while loop $L$ as the $\tpath$. It is computed as follows,
\\
 $\rpchset(L_l, \tpath, \rprog) \triangleq 
 \{\rpch(L, \tpath) ~|~  
 \forall \rprog' \in \rpch(L, \tpath) \st \rprog' \in \rprog \}$
%  \rprepeat(\rprog) \in \rpchoose() \rprepeat(\rprog) = \rpch(L_l, \tpath) \} \mathcal{P}(\rpch(L_l, \tpath))$
\end{defn}
 % \\
% 2. 
% collect the loop chain: 
% $lpchain : \tpath \to \mathcal{P}(\mathcal{P}(\rprog)))$
% \\
% $lpchain(\tpath) = \rprog_n \to \rprog_{n-1} \to \cdots \to \tpath$
% % such that there is at least a $\rpchoose$ and isn't consecutive repeats $\rprepeat$ (i.e., at most one 
% % $\rprepeat$) between any $\rprog_{i - 1}$ and $\rprog_{i}$ for $i = n, \cdots, 1$.
% $\rprog_{i}= \rprepeat^{L_i}(\cdots, \rprog_{i - 1}, \cdots)$ and
%  there isn't any loop (i.e., $\rprepeat^{L}$) between $\rprog_{i}$ and $\rprog_{i - 1}$ for $i = n, \cdots, 1$.
% \\
% 2. Compute the local bound for every repeat chain as follows:
% \\
% $\rpchB(L, \tpath) = \prod\limits_{\rprog_i \in rpchain(\tpath)}
% % \frac{chsInit(\rprog_i, \tpath) - chsFinal(\rprog_i, \tpath)}{\varGD(\rprog_i, \tpath)}
% \outinB(\rprog_i)$
% % \\
% where $\rprepeat^{L}$ is the closet loop containing $\tpath$, $\rprepeat^{L}(\cdots, \rprog, \cdots)$.
% \\
% 4. Compute the nested local bound for every loop chain as follows, for every of 
% $(\rprog_i, \tpath)$ such that $\rprog_i \in lpchain(\tpath)$,
% \\
% $\lpchB(\rprog_i, \tpath) = 
% % \prod\limits_{\rprog_i \in lpchain(\tpath)}
% \frac{\lpinit(\rprog_i, \tpath) - lpFinal(\rprog_i, \tpath)}{\varGD(\rprog_i, \tpath)}$
% \\
\item  \emph{Local Repeat Chain Bound}.
\\
For every transition path $\tpath$
in its closet enclosed while loop $L$,
the \emph{Local Repeat Chain Bound} $\rpchB(L, \tpath) \in \mathcal{A}_{in}$ is computed as follows,
% $rpRB: \tpath \to \mathcal{A}_{in}$, $chsRB: (\rprog \times \tpath) \to \mathcal{A}_{in}$
% \\
% For each transition path $\tpath \in \rprog$,
% \\
% 1. First compute the path sensitive reachability choosing bound through their choose chain:
% \\
% $chsRB(\rprog_n, \tpath) = \prod\limits_{\rprog_i \in lpchain(\rprog_n, \tpath)}
% \frac{chsInit(\rprog_i, \tpath) - chsFinal(\rprog_i, \tpath)}{\varGD(\rprog_i, \tpath)}$
  \\
  $\rpchB(L, \tpath) = \max \left\{ \prod\limits_{\rprog_i \in ch}  \outinB(\rprog_i) 
  ~\middle\vert~ ch \in \rpchset(L_l, \tpath) \right\}
  $;
  \\
  $\rpchB(L, \tpath) = \bot$ if $L$ isn't the closest while loop containing $\tpath$.
  %
  \end{enumerate}
% \\
% \\
% 2. Then compute the path sensitive reachability repeating bound for $\tpath$ as:
% \\
% $RB(\tpath) = \max\limits_{l \in lpchains(\tpath)} \{\rpchB(n, \tpath) \prod\limits_{\rprog_i \in l} lpRB(\rprog_i, \tpath) \}$
% % For $chain \in rpchain(\tpath)$:
% where $lpchains(\tpath)$ is set of $lpchains(\tpath)$ containing all the loop chains of $\tpath$.
%
\item \emph{Related Loop Bound}.
\\
For every transition path $\tpath \in \rprog$, 
the \emph{Nested Loop Bound} $\lpchB(L_i, \tpath, \rprog) \in \mathcal{A}_{\lin}$ is computed as follows.
\begin{enumerate}
  \item \emph{Nested Loop Chain}.
  Each loop chain $\lpch(\tpath, \rprog) \in \mathcal{P}(\rprog)$ 
  is a list of refined program $\rprog' \in \rprog$
  $\tpath$ is nested in, and every $\rprog'$ has different loop header annotation.
  \\
For each transition path in the refined program $\tpath \in \rprog$, 
its \emph{Loop Chain} is computed as follows,
% repeat chain.
% then there is loop tree as follows for a program:
% $P = \rprepeat^{L_n}(\cdots, \rprepeat^{L_{n'}}(\cdots), \cdots, \rprepeat^{L_{n''}}(\cdots))$.
% \\
% For each transition path $\tpath$, we:
% from the head of the while loop.
% 1. firstly collect the loop chain: 
% $lp\mathcal{C}(\tpath) \in \mathcal{P}(\mathcal{P}(\rprog)) \triangleq \mathcal{P}(\lpch(\tpath))$
\begin{defn}[Nested Loop Chain]
  \label{def:loopchain}
$\lpch(\tpath, \rprog) \in \mathcal{P}(\rprog) \triangleq 
L_n \to L_{n-1} \to \cdots \to \tpath$
\\
% such that there is at least a $\rpchoose$ and isn't consecutive repeats $\rprepeat$ (i.e., at most one 
% $\rprepeat$) between any $\rprog_{i - 1}$ and $\rprog_{i}$ for $i = n, \cdots, 1$.
such that 
$\rprog_{i}= L_i : (\cdots, L_{i - 1} : \rprog_{i-1}, \cdots)$ and
 there isn't any loop label (i.e., $L'$) between $\rprog_{i}$ and $\rprog_{i - 1}$ for $i = n, \cdots, 1$.
\end{defn}
\item  \emph{Related Loop Bound}.
$\lpchB(L_i, \tpath, \rprog) \in \mathcal{A}_{\lin}$.
\\
Given a loop label $L_i \in \rprog$ and a transition path $\tpath \in \rprog$ in a refined program $\rprog$,
the \emph{Related Loop Bound} $\lpchB(L_i, \tpath, \rprog)$ is a symbolic expression in $\mathcal{A}_{\lin}$.
\\
This expression is the path-sensitive
reachability bound on the number of $L_i$'s iteration numbers,
%  will 
% bound the execution times of $L_{t_0}$
% in each single execution of the $L_{t_i}$ for every
such that, during these iterations, $\tpath$ will be executed. 
%  bound of $\tpath$ in the while loop with loop label $L_i$.
\\
For a refined program $\rprog$, 
% with its refined statement $\rprog \in \mathcal{RP}$,
% \\
% for 
each transition path in this refined program, $\tpath \in \rprog$ with its loop chain set $\rpchset(\tpath)$,
\\
and every loop label $L_i \in \lpch(\tpath) $ and $\lpch(\tpath)  \in \rpchset(\tpath)$:
% \\
% $(L_i, \tpath)$ such that $L_i \in \lpch(\tpath)$,
\\
$\lpchB(L_i, \tpath, \rprog) = \rpchB(L_i, \tpath, \rprog)$ if $\rpchB(L_i, \tpath, \rprog) \neq \bot$.
\\
$\lpchB(L_i, \tpath, \rprog) = 
% \prod\limits_{\rprog_i \in lpchain(\tpath)}
\frac{\lpinit(L_i, \tpath) - \rffinal(\tpath)}{\lpinit(L_i, \tpath) - \lpnext(L_i, \tpath)}$
% \\
\begin{defn}[Related Loop Bound ($\lpchB(L_i, \tpath, \rprog) \in \mathcal{A}_{\lin}$)]
  \label{def:relatedloop_bound}
For each transition path in a refined program $\tpath \in \rprog$
and every loop $L_i \in \lpch(\tpath, \rprog)$,
% where $\lpch(\tpath)  \in \rpchset(\tpath)$, 
the \emph{Related Loop Bound} $\lpchB(L_i, \tpath, \rprog)$ is computed as follows,
\\
$\lpchB(L_i, \tpath, \rprog) = \rpchB(L_i, \tpath, \rprog)$ if $\rpchB(L_i, \tpath) \neq \bot$.
\\
$\lpchB(L_i, \tpath, \rprog) = 
% \prod\limits_{\rprog_i \in lpchain(\tpath)}
\frac{\lpinit(L_i, \tpath) - \rffinal(\tpath)}{\lpinit(L_i, \tpath) - \lpnext(L_i, \tpath)}$
\end{defn}
The computations of the operations $\lpinit(L_i, \tpath)$ and $\lpnext(L_i, \tpath)$
are formally computed as follows,
\begin{itemize}
\item For a transition path $\tpath \in \paths(\absG(c))$ and a loop label $L_i$ in this transition path's loop chain.
Let $\rprog_i$ be the refined program with this loop label $L_i$, i.e., $L_i: \rprog_i \in \rprog$, 
the abstract loop chain initial state $\lpinit(L_i, \tpath) \in \mathcal{P}(\absstate)$ is computed as follows,
\[
  \lpinit(L_i, \tpath) \triangleq 
  \bigwedge_{x \in VAR(c)}
  \left\{ 
  x = arg\max_{l_1}
  \left\{
      \begin{array}{l}
    (v, (l_1, dc, l_2)) \in \reset(x) 
        \\ 
    % \qquad
    \land \absinit(\rprog_i) \leq l_1 \leq \absinit(\tpath)
    \end{array}
    \right\}
  \right\}
  \]
\item
For a transition path $\tpath \in \paths(\absG(c))$ and a refined program $\rprog_i$ with the loop label $L_i: \rprog_i$, its $\rfnext(L_i, \tpath)$ is computed as follows,
%
\[
  \begin{array}{l}
  \lpnext(L_i, \tpath) \triangleq 
  \bigwedge\limits_{x \in VAR(\rprog)}
  \left\{ 
    \begin{array}{l}
  x =   \sum\limits_{(x, \absevent) \in \inc(x) }\left\{ 
    \varinvar(y) + c ~\middle\vert~ \absevent = (l, (y, c), \_) \land l \in \lvar(\rprog_i)\right\}
    \\ \qquad 
    - \sum\limits_{(x, \absevent) \in dec(x) }\left\{ 
      \varinvar(y) + c ~\middle\vert~ \absevent = (l, (y, c), \_) \land l \in \lvar(\rprog_i) \right\}
    \end{array}
  \right\}
  \end{array}
\]
$\lpinit(L_i, \tpath)$, and $\lpnext(L_i, \tpath)$ can be computed using the 
$INIT(c, i, \absinit(\tpath))$ and $NEXT(c, i, \absinit(\tpath))$ from paper \cite{GulwaniJK09}.
% \\
The $\lpchB(L_i, \tpath)$ can also be computed using the algorithm 
$\kw{BOUNDFINDERD(INIT(c, i, \absinit(\tpath)), NEXT(c, i, \absinit(\tpath)), V_{\ln})}$
from paper \cite{GulwaniJK09} with the equivalent result.
\end{itemize}
% $rpRB: \tpath \to \mathcal{A}_{in}$, $chsRB: (\rprog \times \tpath) \to \mathcal{A}_{in}$
% \\
% For each transition path $\tpath \in \rprog$,
% \\
% 1. First compute the path sensitive reachability choosing bound through their choose chain:
% \\
% $chsRB(\rprog_n, \tpath) = \prod\limits_{\rprog_i \in lpchain(\rprog_n, \tpath)}
% \frac{chsInit(\rprog_i, \tpath) - chsFinal(\rprog_i, \tpath)}{\varGD(\rprog_i, \tpath)}$
% \\
\end{enumerate}
\item The \emph{Inside-Out Bound} ($\inoutB(\tpath, \rprog) \in \mathcal{A}_{in}$).
\\
For every transition path $\tpath \in \rprog$, its \emph{Inside-Out Loop Bound}
 $\inoutB(\tpath, \rprog) \in \mathcal{A}_{in}$ is 
% Compute 
the path sensitive reachability bound on the iteration numbers of this path in this refined program $\rprog$. 
It is computed in Definition~\ref{def:outin_bound}.
\begin{defn}[{Inside-Out Loop Bound} ($\inoutB(\tpath, \rprog) \in \mathcal{A}_{in}$)]
  \label{def:outin_bound}
  Given a refined program $\rprog$, for every transition path $\tpath \in \rprog$, 
  its \emph{Inside-Out Loop Bound}
  $\inoutB(\tpath, \rprog)$ is 
 % Compute 
 computed as follows,
$\inoutB(\tpath, \rprog) =
  \prod\limits_{L \in \lpch(\tpath, \rprog)} \rpchB(L, \tpath, \rprog)
% lpRB(\rprog_i, \tpath) 
% ~ \middle\vert~ l \in lp\mathcal{C}(\tpath) \right
$
\end{defn}
% For $chain \in rpchain(\tpath)$:
% where $lpchains(\tpath)$ is set of $lpchains(\tpath)$ containing all the loop chains of $\tpath$.
\end{enumerate}
%
\subsection{Path Sensitive Reachability Bound Computation for Every Location}
\label{sec:pathsensitive_rb-psrbcompute}
$psRB(c, l) \in \mathcal{A}_{in}$
\\
For every program control location $l \in \lvar(c)$, with $\rprog$ as its refined program,
%  in a program $c$,
%  refined program $l \in \lvar(\rprog)$,
 $\psRB(l, \rprog)$ is its path sensitive reachability bound on the executing times of this location $l$.
 \\
 \begin{defn}
  \label{def:label_psrb}
Given a program $c$ with its refined program $\rprog \in \mathcal{RP}$
%  with 
% \emph{Global Loop Bound} $\inoutB(\tpath)$
% computed for its every transition path $\tpath \in \rprog$  notated by $\inoutB(\tpath)$,
%  for each of its transition path $\tpath \in \rprog$ 
% with the \emph{Global Loop Bound}
% computed as above, notated by $\inoutB(\tpath)$.
the $\psRB(c, l)$ for every label $l \in \lvar(c)$ is computed as follows,
\\
\[ \psRB(c, l) = \sum\limits_{\tpath \in \rprog \land 
l \in \tpath} \inoutB(\tpath)\]
 \end{defn}
\begin{thm}[Soundness of the Path Sensitive Reachability Bound Estimation]
  \label{thm:pathsensitive_rb_soundness}
Given a program ${c}$, for every label $l$ of this program $c$ such that $(l, w) \in \exeRB(c)$, 
and any initial trace $\trace_0 \in \mathcal{T}_0(c)$ with 
% $\config{{c}, \trace_0} \to^{*} \config{\eskip, \trace_0\tracecat \vtrace} $ 
and $\config{\psRB(c, l), \trace_0} \earrow v$,
% for some generated evaluation trace $\vtrace \in \mathcal{T}$,
we have $ w(\trace_0) \leq v $.
%
\[
  \begin{array}{l}
  \forall (l, w_{t}) \in \exeRB(c),
  % (x^l, w_{p}) \in \progV, 
  \trace_0 \in \mathcal{T}_0(c), 
  v \in \mathbb{N} \st
  \config{\psRB(c, l), \trace_0} \earrow v
  \implies
  % \right\} 
  w_{t}(\trace_0) \leq v
  \end{array}
\]
\end{thm}
%
Proof of this theorem is in Appendix~\ref{apdx:pathsensitive_rb_soundness}.
\paragraph*{Path Sensitive Reachability Bound through An Example}
\input{examples_psrb/whileSim}